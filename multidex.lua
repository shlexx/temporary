-- idk who this is from

--[[
	New Dex
	Final Version
	Developed by Moon
	Modified for Infinite Yield
	
	Dex is a debugging suite designed to help the user debug games and find any potential vulnerabilities.
	Credits to all decompilers!
]]

function otherdecompile(v:Script)
	local source
	if v.Name == "Vehicle" and v.Parent:FindFirstChild("LocalVehiclePromptGui") then
		source = [[local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")

local Scripts = script.Parent
local TopModel = Scripts.Parent

local UniqueName = TopModel.Name.. "_" ..HttpService:GenerateGUID()

local ChassisModel = TopModel.Chassis
local EffectsFolder = TopModel.Effects

local Effects = require(Scripts.Effects)
local Chassis = require(Scripts.Chassis)
local VehicleSeating = require(Scripts.VehicleSeating)
local RemotesFolder = TopModel.Remotes
local BindableEventsFolder = TopModel.BindableEvents


-- LocalScripts that are cloned and deployed
local DriverScriptPrototype = Scripts.Driver
local PassengerScriptPrototype = Scripts.Passenger
local LocalGuiModulePrototype = Scripts.LocalVehicleGui

-- Note that this has not been refactored into a class yet
Chassis.InitializeDrivingValues()

-- This module is a class with a new() constructor function
local EffectsInstance = Effects.new(ChassisModel, EffectsFolder, TopModel)

VehicleSeating.SetRemotesFolder(RemotesFolder)
VehicleSeating.SetBindableEventsFolder(BindableEventsFolder)

local CharacterRemovingConnection = nil

local DriverSeat = Chassis.GetDriverSeat()
local AdditionalSeats = Chassis.GetPassengerSeats()

local LEG_PARTS_TO_REMOVE = {"RightFoot", "RightLowerLeg", "LeftFoot", "LeftLowerLeg"}
local ATTACHMENTS_TO_REMOVE = {"BodyBackAttachment", "WaistBackAttachment", "HatAttachment"}

local function setHatsAndLegsTransparency(obj, transparency)
	if obj:IsA("Humanoid") then
		obj = obj.Parent
	elseif obj:IsA("Player") then
		obj = obj.Character
	end

	for _, child in ipairs(obj:GetChildren()) do
		if child:IsA("Accoutrement") then
			local handle = child:FindFirstChild("Handle")
			if handle then
				local shouldRemove = false
				for _, attachmentName in ipairs(ATTACHMENTS_TO_REMOVE) do
					if handle:FindFirstChild(attachmentName) then
						shouldRemove = true
					end
				end

				if shouldRemove then
					handle.Transparency = transparency
				end
			end
		end
	end

	for _, legName in ipairs(LEG_PARTS_TO_REMOVE) do
		local legPart = obj:FindFirstChild(legName)
		if legPart then
			legPart.Transparency = transparency
		end
	end
end

local function onExitSeat(obj, seat)
	if obj:IsA("Player") then
		RemotesFolder.ExitSeat:FireClient(obj, false)

		local playerGui = obj:FindFirstChildOfClass("PlayerGui")
		if playerGui then
			local scriptContainer = playerGui:FindFirstChild(UniqueName .. "_ClientControls")
			if scriptContainer then
				scriptContainer:Destroy()
			end
		end
	end

	setHatsAndLegsTransparency(obj, 0)

	if obj:IsA("Humanoid") then
		obj.Sit = false
	end

	if CharacterRemovingConnection then
		CharacterRemovingConnection:Disconnect()
		CharacterRemovingConnection = nil
	end

	if seat == DriverSeat then
		DriverSeat:SetNetworkOwnershipAuto()
		Chassis.Reset()
		EffectsInstance:Disable()
	end
end

local function onEnterSeat(obj, seat)
	if seat and seat.Occupant then
		local ShouldTakeOffHats = true
		local prop = TopModel:GetAttribute("TakeOffAccessories")

		if prop ~= nil then
			ShouldTakeOffHats = prop
		end

		if ShouldTakeOffHats then
			setHatsAndLegsTransparency(seat.Occupant, 1)
		end
	end

	if not obj:IsA("Player") then
		return
	end

	local playerGui = obj:FindFirstChildOfClass("PlayerGui")
	if playerGui then
		local screenGui = Instance.new("ScreenGui")
		screenGui.Name = UniqueName .. "_ClientControls"
		screenGui.ResetOnSpawn = true
		screenGui.Parent = playerGui

		CharacterRemovingConnection = obj.CharacterRemoving:Connect(function()
			onExitSeat(obj)
		end)

		local localGuiModule = LocalGuiModulePrototype:Clone()
		localGuiModule.Parent = screenGui

		if seat == DriverSeat then
			local driverScript = DriverScriptPrototype:Clone()
			driverScript.CarValue.Value = TopModel
			driverScript.Parent = screenGui
			driverScript.Disabled = false

			DriverSeat:SetNetworkOwner(obj)
			EffectsInstance:Enable()
		else
			local passengerScript = PassengerScriptPrototype:Clone()
			passengerScript.CarValue.Value = TopModel
			passengerScript.Parent = screenGui
			passengerScript.Disabled = false
		end

		local scriptsReference = Instance.new("ObjectValue")
		scriptsReference.Name = "ScriptsReference"
		scriptsReference.Value = Scripts
		scriptsReference.Parent = screenGui
	end
end

--Listen to seat enter/exit
VehicleSeating.AddSeat(DriverSeat, onEnterSeat, onExitSeat)

for _, seat in ipairs(AdditionalSeats) do
	VehicleSeating.AddSeat(seat, onEnterSeat, onExitSeat)
end

local function playerAdded(player)
	local playerGui = player:WaitForChild("PlayerGui")

	if not playerGui:FindFirstChild("VehiclePromptScreenGui") then
		local screenGui = Instance.new("ScreenGui")
		screenGui.ResetOnSpawn = false
		screenGui.Name = "VehiclePromptScreenGui"
		screenGui.Parent = playerGui

		local newLocalVehiclePromptGui = Scripts.LocalVehiclePromptGui:Clone()
		newLocalVehiclePromptGui.CarValue.Value = TopModel
		newLocalVehiclePromptGui.Parent = screenGui
	end
end

Players.PlayerAdded:Connect(playerAdded)

for _, player in ipairs(Players:GetPlayers()) do
	playerAdded(player)
end
]]
	elseif v.Name == "Health" and v.Parent:FindFirstChildOfClass("Humanoid") then
		source = [[-- Gradually regenerates the Humanoid's Health over time.

local REGEN_RATE = 1/100 -- Regenerate this fraction of MaxHealth per second.
local REGEN_STEP = 1 -- Wait this long between each regeneration step.

--------------------------------------------------------------------------------

local Character = script.Parent
local Humanoid = Character:WaitForChild'Humanoid'

--------------------------------------------------------------------------------

while true do
	while Humanoid.Health < Humanoid.MaxHealth do
		local dt = wait(REGEN_STEP)
		local dh = dt*REGEN_RATE*Humanoid.MaxHealth
		Humanoid.Health = math.min(Humanoid.Health + dh, Humanoid.MaxHealth)
	end
	Humanoid.HealthChanged:Wait()
end]]
	elseif v.Name == "BathroomSinkScript" then
		source = [[local water = script.Parent.Water.Mesh
local hotWater = 1
local coldWater = 1
local waterTemp = nil
local plugged = script.Parent.Plugged
local coldOn = script.Parent.ColdOn
local hotOn = script.Parent.HotOn
local faucet = script.Parent.Faucet
local drainSound = script.Parent.Water.WaterDrainSound
local waterSound = faucet.WaterRunningSound
local coldTap = script.Parent.ColdTapHandle
local hotTap = script.Parent.HotTapHandle
local plug = script.Parent.Plug

----- cold tap handler -----

coldTap.Interactive.ClickDetector.MouseClick:Connect(function()
	if coldOn.Value == false then
		coldOn.Value = true
		faucet.ParticleEmitter.Enabled = true
		waterSound:Play()
		coldTap:SetPrimaryPartCFrame(coldTap.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(-45), 0))
	else
		coldOn.Value = false
		if hotOn.Value == false then
			faucet.ParticleEmitter.Enabled = false
			waterSound:Stop()
		end
		coldTap:SetPrimaryPartCFrame(coldTap.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(45), 0))
	end
end)

----- hot tap handler -----

hotTap.Interactive.ClickDetector.MouseClick:Connect(function()
	if hotOn.Value == false then
		hotOn.Value = true
		faucet.ParticleEmitter.Enabled = true
		waterSound:Play()
		hotTap:SetPrimaryPartCFrame(hotTap.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(45), 0))
	else
		hotOn.Value = false
		if coldOn.Value == false then
			faucet.ParticleEmitter.Enabled = false
			waterSound:Stop()
		end
		hotTap:SetPrimaryPartCFrame(hotTap.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(-45), 0))
	end
end)

----- sink plug handler -----

plug.Interactive.ClickDetector.MouseClick:Connect(function()
	if plugged.Value == false then
		plugged.Value = true
		plug.Plug.CFrame = plug.Plug.CFrame * CFrame.new(0, -0.08, 0)
		plug.Interactive.CFrame = plug.Interactive.CFrame * CFrame.new(0, 0.14, 0)
		plug.Shaft.CFrame = plug.Shaft.CFrame * CFrame.new(0, 0.14, 0)
	else
		plugged.Value = false
		plug.Plug.CFrame = plug.Plug.CFrame * CFrame.new(0, 0.08, 0)
		plug.Interactive.CFrame = plug.Interactive.CFrame * CFrame.new(0, -0.14, 0)
		plug.Shaft.CFrame = plug.Shaft.CFrame * CFrame.new(0, -0.14, 0)
	end
end)

----- water handler -----

while true do
	if script.Parent.HotOn.Value == true and script.Parent.ColdOn.Value == true and script.Parent.Plugged.Value == true and water.Scale.Y <= 0.6 then -- if BOTH ON and PLUGGED		
		water.Scale = water.Scale + Vector3.new(0, 0.01, 0)
		water.Offset = Vector3.new(0, water.Scale.Y/2, 0)
		hotWater = hotWater + 1
		coldWater = coldWater + 1
		drainSound:Stop()
	elseif (script.Parent.HotOn.Value == true or script.Parent.ColdOn.Value == true) and script.Parent.Plugged.Value == true and water.Scale.Y <= 0.6 then -- if ON and PLUGGED
		water.Scale = water.Scale + Vector3.new(0, 0.01, 0)
		water.Offset = Vector3.new(0, water.Scale.Y/2, 0)
		if script.Parent.HotOn.Value == true then
			hotWater = hotWater + 1
		else
			coldWater = coldWater + 1
		end
		drainSound:Stop()
	elseif (script.Parent.HotOn.Value == true or script.Parent.ColdOn.Value == true) and script.Parent.Plugged.Value == false and water.Scale.Y <= 0.6 then -- if ON and NOT PLUGGED
		if script.Parent.HotOn.Value == true then
			coldWater = coldWater - 1			
		else
			hotWater = hotWater - 1
		end
		drainSound:Stop()
	elseif (script.Parent.HotOn.Value == false and script.Parent.ColdOn.Value == false) and script.Parent.Plugged.Value == false and water.Scale.Y > 0 then -- if NOT ON and NOT PLUGGED
		water.Scale = water.Scale + Vector3.new(0, -0.01, 0)
		water.Offset = Vector3.new(0, water.Scale.Y/2, 0)
		coldWater = coldWater - 1
		hotWater = hotWater - 1
		drainSound.TimePosition = 0
		drainSound:Play()
	end
	
	if coldWater < 1 then
		coldWater = 1
	end
	if hotWater < 1 then
		hotWater = 1
	end
	
	waterTemp = hotWater/coldWater	
	
	if waterTemp > 1 then
		water.Parent.SteamEmitter.Enabled = true
	else
		water.Parent.SteamEmitter.Enabled = false
	end
	wait(0.1)
	
	if script.Parent.ColdOn.Value == true or script.Parent.HotOn.Value == true then
		script.Parent.Splash.ParticleEmitter.Enabled = true
	else
		script.Parent.Splash.ParticleEmitter.Enabled = false
	end
	
	if water.Scale.Y <= 0 then
		drainSound:Stop()
	end
end]]
	elseif v.Name == "ToiletScript" then
		source = [[local interactive = script.Parent.Interactive
local handle = script.Parent.Handle
local flushing = false
local water = script.Parent.Water
local sound = water.FlushSound
local seat = script.Parent.Seat

seat.ChildAdded:connect(function(obj) -- if someone sits on the seat
	if obj.Name == "SeatWeld" then
		local player = game.Players:GetPlayerFromCharacter(obj.Part1.Parent)
		if player then
			script.Parent.Water.BrickColor = BrickColor.new("Cool yellow")
			script.Parent.ToiletUsed.Value = true
		end
	end
end)

function toiletHandle() -- handling toilet handle movement
	for i = 1, 5 do
		interactive.CFrame = handle.CFrame * CFrame.Angles(math.pi/2, 0, math.rad(12) * i) * CFrame.new(0, -0.1, -0.1)
		wait()
	end
	wait(1)
	for i = 5, 1, -1 do
		interactive.CFrame = handle.CFrame * CFrame.Angles(math.pi/2, 0, math.rad(12) * (i - 1)) * CFrame.new(0, -0.1, -0.1)
		wait()
	end
end

interactive.ClickDetector.MouseClick:Connect(function() -- when someone clicks on the handle
	if flushing == false then
		flushing = true
		spawn(toiletHandle)
		sound:Play()
		for i, v in pairs(script.Parent:GetChildren()) do
			if v.Name == "WaterSwirl" then
				v.ParticleEmitter.Transparency = NumberSequence.new(0.9)
				v.ParticleEmitter.Rate = 40
			end
		end
		
		for i = 1, 4 do
			water.CFrame = water.CFrame * CFrame.new(0, 0.01, 0)
			wait()
		end
		for i = 1, 22 do
			water.Mesh.Scale = water.Mesh.Scale + Vector3.new(-0.02, 0, -0.02)
			water.CFrame = water.CFrame * CFrame.new(0, -0.015, 0)
			wait()
		end
		
		if script.Parent.ToiletUsed.Value == true then
			water.BrickColor = BrickColor.new("Pastel yellow")
		end
		
		wait(1)
		
		for i = 1, 10 do
			for ii, v in pairs(script.Parent:GetChildren()) do
				if v.Name == "WaterSwirl" then
					v.ParticleEmitter.Transparency = NumberSequence.new(0.9 + (0.015 * i))
					if i == 10 then
						v.ParticleEmitter.Rate = 0
					end
				end
			end
			wait(0.2)
		end
		
		script.Parent.ToiletUsed.Value = false
		water.BrickColor = BrickColor.new("Fog")
		
		for i = 1, 66 do
			water.Mesh.Scale = water.Mesh.Scale + Vector3.new(0.0066, 0, 0.0066)
			water.CFrame = water.CFrame * CFrame.new(0, 0.00409, 0)
			wait()
		end
		water.CFrame = script.Parent.WaterResetPos.CFrame
		water.Mesh.Scale = Vector3.new(1,0,1)
		flushing = false
	end
end)]]
	elseif v.Name == "KitchenSinkScript" then
		source = [[local water = script.Parent.Water.Mesh
local hotWater = 1
local coldWater = 1
local waterTemp = nil
local plugged = script.Parent.Plugged
local coldOn = script.Parent.ColdOn
local hotOn = script.Parent.HotOn
local faucet = script.Parent.Faucet
local drainSound = script.Parent.Water.WaterDrainSound
local waterSound = faucet.WaterRunningSound
local coldTap = script.Parent.ColdTapHandle
local hotTap = script.Parent.HotTapHandle
local plug = script.Parent.Plug

----- cold tap handler -----

for i, v in pairs(coldTap:GetChildren()) do
	if v:FindFirstChild("ClickDetector") then
		v.ClickDetector.MouseClick:Connect(function()
			if coldOn.Value == false then
				coldOn.Value = true
				faucet.ParticleEmitter.Enabled = true
				waterSound:Play()
				coldTap:SetPrimaryPartCFrame(coldTap.PrimaryPart.CFrame * CFrame.Angles(math.rad(-45),0,0))
			else
				coldOn.Value = false
				if hotOn.Value == false then
					faucet.ParticleEmitter.Enabled = false
					waterSound:Stop()
				end
				coldTap:SetPrimaryPartCFrame(coldTap.PrimaryPart.CFrame * CFrame.Angles(math.rad(45),0,0))
			end
		end)
	end
end

----- hot tap handler

for i, v in pairs(hotTap:GetChildren()) do
	if v:FindFirstChild("ClickDetector") then
		v.ClickDetector.MouseClick:Connect(function()
			if hotOn.Value == false then
				hotOn.Value = true
				faucet.ParticleEmitter.Enabled = true
				waterSound:Play()
				hotTap:SetPrimaryPartCFrame(hotTap.PrimaryPart.CFrame * CFrame.Angles(math.rad(45),0,0))
			else
				hotOn.Value = false
				if coldOn.Value == false then
					faucet.ParticleEmitter.Enabled = false
					waterSound:Stop()
				end
				hotTap:SetPrimaryPartCFrame(hotTap.PrimaryPart.CFrame * CFrame.Angles(math.rad(-45),0,0))
			end
		end)
	end
end

----- sink plug handler -----

plug.Interactive.ClickDetector.MouseClick:Connect(function()
	if plugged.Value == false then
		plugged.Value = true
		plug.Plug.CFrame = plug.Plug.CFrame * CFrame.new(0,-0.1,0)
	else
		plugged.Value = false
		plug.Plug.CFrame = plug.Plug.CFrame * CFrame.new(0,0.1,0)
	end
end)

----- water handler -----

while true do
	if script.Parent.HotOn.Value == true and script.Parent.ColdOn.Value == true and script.Parent.Plugged.Value == true and water.Scale.Y <= 2 then -- if BOTH ON and PLUGGED		
		water.Scale = water.Scale + Vector3.new(0,0.01,0)
		water.Offset = Vector3.new(0,water.Scale.Y/2,0)
		hotWater = hotWater + 1
		coldWater = coldWater + 1
		drainSound:Stop()
	elseif (script.Parent.HotOn.Value == true or script.Parent.ColdOn.Value == true) and script.Parent.Plugged.Value == true and water.Scale.Y <= 2 then -- if ON and PLUGGED
		water.Scale = water.Scale + Vector3.new(0,0.01,0)
		water.Offset = Vector3.new(0,water.Scale.Y/2,0)
		if script.Parent.HotOn.Value == true then
			hotWater = hotWater + 1
		else
			coldWater = coldWater + 1
		end
		drainSound:Stop()
	elseif (script.Parent.HotOn.Value == true or script.Parent.ColdOn.Value == true) and script.Parent.Plugged.Value == false and water.Scale.Y <= 2 then -- if ON and NOT PLUGGED
		if script.Parent.HotOn.Value == true then
			coldWater = coldWater - 1			
		else
			hotWater = hotWater - 1
		end
		drainSound:Stop()
	elseif (script.Parent.HotOn.Value == false and script.Parent.ColdOn.Value == false) and script.Parent.Plugged.Value == false and water.Scale.Y > 0 then -- if NOT ON and NOT PLUGGED
		water.Scale = water.Scale + Vector3.new(0,-0.01,0)
		water.Offset = Vector3.new(0,water.Scale.Y/2,0)
		coldWater = coldWater - 1
		hotWater = hotWater - 1
		drainSound:Play()
	end
	
	if coldWater < 1 then
		coldWater = 1
	end
	if hotWater < 1 then
		hotWater = 1
	end
	
	waterTemp = hotWater/coldWater	
	
	if waterTemp > 1 then
		water.Parent.SteamEmitter.Enabled = true
	else
		water.Parent.SteamEmitter.Enabled = false
	end
	wait(0.1)
	
	
	if script.Parent.ColdOn.Value == true or script.Parent.HotOn.Value == true then
		script.Parent.Splash.ParticleEmitter.Enabled = true
	else
		script.Parent.Splash.ParticleEmitter.Enabled = false
	end	
	
	if water.Scale.Y <= 0 then
		drainSound:Stop()
	end
end]]
	elseif v.Name == "Put this inside your block" then
		source = [[---------------------------------
---Day/Night Script for Blocks---
---------------------------------
b = script.Parent

local oh,om = 6,10	-- Open Time (hours,minutes) DON'T TOUCH!
local ch,cm = 17,30	-- Close Time (hours, minutes) DON'T TOUCH!

local l = game:service("Lighting")
if (om == nil) then om = 0 end
if (cm == nil) then cm = 0 end


function TimeChanged()
	local ot = (oh + (om/60)) * 60
	local ct = (ch + (cm/60)) * 60
	if (ot < ct) then
		if (l:GetMinutesAfterMidnight() >= ot) and (l:GetMinutesAfterMidnight() <= ct) then
b.Material = ("SmoothPlastic")
b.Color = Color3.fromRGB(255, 195, 0)
		else
b.Material = ("Neon")
b.Color = Color3.fromRGB(180, 135, 0)
		end
	elseif (ot > ct) then
		if (l:GetMinutesAfterMidnight() >= ot) or (l:GetMinutesAfterMidnight() <= ct) then
b.Material = ("SmoothPlastic")
b.Color = Color3.fromRGB(255, 195, 0)
		else
b.Material = ("Neon")
b.Color = Color3.fromRGB(180, 135, 0)
		end
	end
end

TimeChanged()
game.Lighting.Changed:connect(function(property)
			if (property == "TimeOfDay") then
				TimeChanged()
			end
		end)

-- Ganondude]]
	elseif v.Name == "Put this inside your light" then
		source = [[b = script.Parent

local oh,om = 6,10	-- Open Time (hours,minutes)
local ch,cm = 17,30	-- Close Time (hours, minutes)

local l = game:service("Lighting")
if (om == nil) then om = 0 end
if (cm == nil) then cm = 0 end


function TimeChanged()
	local ot = (oh + (om/60)) * 60
	local ct = (ch + (cm/60)) * 60
	if (ot < ct) then
		if (l:GetMinutesAfterMidnight() >= ot) and (l:GetMinutesAfterMidnight() <= ct) then
b.Enabled = false
		else
b.Enabled = true
		end
	elseif (ot > ct) then
		if (l:GetMinutesAfterMidnight() >= ot) or (l:GetMinutesAfterMidnight() <= ct) then
b.Enabled = false
		else
b.Enabled = true
		end
	end
end

TimeChanged()
game.Lighting.Changed:connect(function(property)
			if (property == "TimeOfDay") then
				TimeChanged()
			end
		end)

-- Ganondude]]
	elseif v.Name == "Control" and v.Parent.Name == "HN" then
		source = [[if script.Parent.Parent:IsA("VehicleSeat") then
	script.Parent.Parent.ChildAdded:connect(function(child)
		if child:IsA("Weld") and game.Players:GetPlayerFromCharacter(child.Part1.Parent)~=nil then
			local p=game.Players:GetPlayerFromCharacter(child.Part1.Parent)
			local g=script.G:Clone()
			g.Parent=p.PlayerGui
			g:WaitForChild("src")
			g.src.Value=script.Parent
			g.Horn.Disabled=false		
		end
	end)
end]]
	elseif v.Parent.Name == "AC6_FE_Sounds" then
		source = [[local car = script.Parent.Parent
local Sounds = {}
local F = {}

F.newSound = function(name,par,id,pitch,volume,loop)
	for i,v in pairs(Sounds) do
		if i==name then
			v:Stop()
			v:Destroy()
		end
	end
	local sn = Instance.new("Sound",par)
	sn.Name = name
	sn.SoundId = id
	sn.Pitch = pitch
	sn.Volume = volume
	sn.Looped = loop
	Sounds[name]=sn
end

F.updateSound = function(sound,id,pit,vol)
	local sn = Sounds[sound]
	if id~=sn.SoundId then sn.SoundId = id end
	if pit~=sn.Pitch then sn.Pitch = pit end
	if vol~=sn.Volume then sn.Volume = vol end
end

F.playSound = function(sound)
	Sounds[sound]:Play()
end

F.pauseSound = function(sound)
	Sounds[sound]:Pause()
end

F.stopSound = function(sound)
	Sounds[sound]:Stop()
end

F.removeSound = function(sound)
	Sounds[sound]:Stop()
	Sounds[sound]:Destroy()
	Sounds[sound]=nil
end

script.Parent.OnServerEvent:connect(function(pl,Fnc,...)
	F[Fnc](...)
end)

car.DriveSeat.ChildRemoved:connect(function(child)
	if child.Name=="SeatWeld" then
		F.removeSound("Rev")
	end
end)]]
	elseif v.Parent.Name == "Backfire_FE" then
		source = [[local car = script.Parent.Parent
local F = {}

F.Backfire1 = function()
	car.Body.Exhaust.Backfire1.Backfire1:play()
	car.Body.Exhaust.Backfire2.Backfire1:play()
	car.Body.Exhaust.Backfire1.Fire.Enabled = true
	car.Body.Exhaust.Backfire2.Fire.Enabled = true
	car.Body.Exhaust.BFLight1.SpotLight.Enabled = true
	car.Body.Exhaust.BFLight2.SpotLight.Enabled = true
	wait (0.03)
	car.Body.Exhaust.Backfire1.Fire.Enabled = false
	car.Body.Exhaust.Backfire2.Fire.Enabled = false
	car.Body.Exhaust.BFLight1.SpotLight.Enabled = false
	car.Body.Exhaust.BFLight2.SpotLight.Enabled = false
	wait (0.07)
end

F.Backfire2 = function()
	car.Body.Exhaust.Backfire1.Backfire2:play()
	car.Body.Exhaust.Backfire2.Backfire2:play()
	car.Body.Exhaust.Backfire1.Fire.Enabled = true
	car.Body.Exhaust.Backfire2.Fire.Enabled = true
	car.Body.Exhaust.BFLight1.SpotLight.Enabled = true
	car.Body.Exhaust.BFLight2.SpotLight.Enabled = true
	wait (0.03)
	car.Body.Exhaust.Backfire1.Fire.Enabled = false
	car.Body.Exhaust.Backfire2.Fire.Enabled = false
	car.Body.Exhaust.BFLight1.SpotLight.Enabled = false
	car.Body.Exhaust.BFLight2.SpotLight.Enabled = false
	wait (0.07)
end


script.Parent.OnServerEvent:connect(function(pl,Fnc,...)
	F[Fnc](...)
end)

car.DriveSeat.ChildRemoved:connect(function(child)
	if child.Name=="SeatWeld" then
		car.Body.Exhaust.Backfire1.Fire.Enabled = false
		car.Body.Exhaust.Backfire2.Fire.Enabled = false
		car.Body.Exhaust.BFLight1.SpotLight.Enabled = false
		car.Body.Exhaust.BFLight2.SpotLight.Enabled = false
	end
end)]]
	elseif v.Parent.Name == "Smoke_FE" then
		source = [[local car = script.Parent.Parent
local F = {}

F.UpdateSmoke = function(rl,rr)
	car.Wheels.RL.Smoke.Rate = rl
	car.Wheels.RR.Smoke.Rate = rr
	car.Wheels.RL.SQ.Volume = rl/50
	car.Wheels.RR.SQ.Volume = rr/50
end

script.Parent.OnServerEvent:connect(function(pl,Fnc,...)
	F[Fnc](...)
end)

car.DriveSeat.ChildRemoved:connect(function(child)
	if child.Name=="SeatWeld" then
		car.Wheels.RL.SQ:Stop()
		car.Wheels.RR.SQ:Stop()
		car.Wheels.RL.Smoke.Rate=0
		car.Wheels.RR.Smoke.Rate=0
	end
end)

for i,v in pairs(car.Wheels:GetChildren()) do
	if v.Name=="RL" or v.Name=="RR" or v.Name=="R" then
		local sq = script.Parent.SQ:Clone()
		sq.Parent=v
		local sm = script.Parent.Smoke:Clone()
		sm.Parent=v
	end
end]]
	elseif v.Name == "Initialize" and v:FindFirstChild("MiscWeld") then
		source = [[--[[
		___      _______                _     
	   / _ |____/ ___/ /  ___ ____ ___ (_)__ 
	  / __ /___/ /__/ _ \/ _ `(_-<(_-</ (_-<
	 /_/ |_|   \___/_//_/\_,_/___/___/_/___/
 						SecondLogic @ Inspare
]

		--[[START]

		_BuildVersion = require(script.Parent.README)

		--[[Weld functions]

		local JS = game:GetService("JointsService")
		local PGS_ON = workspace:PGSIsEnabled()

		function MakeWeld(x,y,type,s) 
			if type==nil then type="Weld" end
			local W=Instance.new(type,JS) 
			W.Part0=x W.Part1=y 
			W.C0=x.CFrame:inverse()*x.CFrame 
			W.C1=y.CFrame:inverse()*x.CFrame 
			if type=="Motor" and s~=nil then 
				W.MaxVelocity=s 
			end 
			return W	
		end

		function ModelWeld(a,b) 
			if a:IsA("BasePart") then 
				MakeWeld(b,a,"Weld") 
			elseif a:IsA("Model") then 
				for i,v in pairs(a:GetChildren()) do 
					ModelWeld(v,b) 
				end 
			end 
		end

		function UnAnchor(a) 
			if a:IsA("BasePart") then a.Anchored=false  end for i,v in pairs(a:GetChildren()) do UnAnchor(v) end 
		end



		--[[Initialize]

		script.Parent:WaitForChild("A-Chassis Interface")
		script.Parent:WaitForChild("Plugins")
		script.Parent:WaitForChild("README")

		local car=script.Parent.Parent
		local _Tune=require(script.Parent)

		wait(_Tune.LoadDelay)

		--Weight Scaling
		local weightScaling = _Tune.WeightScaling
		if not workspace:PGSIsEnabled() then
			weightScaling = _Tune.LegacyScaling
		end

		local Drive=car.Wheels:GetChildren()

		--Remove Existing Mass
		function DReduce(p)
			for i,v in pairs(p:GetChildren())do
				if v:IsA("BasePart") then
					if v.CustomPhysicalProperties == nil then v.CustomPhysicalProperties = PhysicalProperties.new(v.Material) end
					v.CustomPhysicalProperties = PhysicalProperties.new(
						0,
						v.CustomPhysicalProperties.Friction,
						v.CustomPhysicalProperties.Elasticity,
						v.CustomPhysicalProperties.FrictionWeight,
						v.CustomPhysicalProperties.ElasticityWeight
					)
				end
				DReduce(v)
			end
		end
		DReduce(car)



		--[[Wheel Configuration]	

		--Store Reference Orientation Function
		function getParts(model,t,a)
			for i,v in pairs(model:GetChildren()) do
				if v:IsA("BasePart") then table.insert(t,{v,a.CFrame:toObjectSpace(v.CFrame)})
				elseif v:IsA("Model") then getParts(v,t,a)
				end
			end
		end

		--PGS/Legacy
		local fDensity = _Tune.FWheelDensity
		local rDensity = _Tune.RWheelDensity
		if not PGS_ON then
			fDensity = _Tune.FWLgcyDensity
			rDensity = _Tune.RWLgcyDensity
		end

		local fDistX=_Tune.FWsBoneLen*math.cos(math.rad(_Tune.FWsBoneAngle))
		local fDistY=_Tune.FWsBoneLen*math.sin(math.rad(_Tune.FWsBoneAngle))
		local rDistX=_Tune.RWsBoneLen*math.cos(math.rad(_Tune.RWsBoneAngle))
		local rDistY=_Tune.RWsBoneLen*math.sin(math.rad(_Tune.RWsBoneAngle))

		local fSLX=_Tune.FSusLength*math.cos(math.rad(_Tune.FSusAngle))
		local fSLY=_Tune.FSusLength*math.sin(math.rad(_Tune.FSusAngle))
		local rSLX=_Tune.RSusLength*math.cos(math.rad(_Tune.RSusAngle))
		local rSLY=_Tune.RSusLength*math.sin(math.rad(_Tune.RSusAngle))

		for _,v in pairs(Drive) do
			--Apply Wheel Density
			if v.Name=="FL" or v.Name=="FR" or v.Name=="F" then
				if v:IsA("BasePart") then
					if v.CustomPhysicalProperties == nil then v.CustomPhysicalProperties = PhysicalProperties.new(v.Material) end
					v.CustomPhysicalProperties = PhysicalProperties.new(
						fDensity,
						v.CustomPhysicalProperties.Friction,
						v.CustomPhysicalProperties.Elasticity,
						v.CustomPhysicalProperties.FrictionWeight,
						v.CustomPhysicalProperties.ElasticityWeight
					)
				end
			else
				if v:IsA("BasePart") then
					if v.CustomPhysicalProperties == nil then v.CustomPhysicalProperties = PhysicalProperties.new(v.Material) end
					v.CustomPhysicalProperties = PhysicalProperties.new(
						rDensity,
						v.CustomPhysicalProperties.Friction,
						v.CustomPhysicalProperties.Elasticity,
						v.CustomPhysicalProperties.FrictionWeight,
						v.CustomPhysicalProperties.ElasticityWeight
					)
				end		
			end

			--Resurface Wheels
			for _,a in pairs({"Top","Bottom","Left","Right","Front","Back"}) do
				v[a.."Surface"]=Enum.SurfaceType.SmoothNoOutlines
			end

			--Store Axle-Anchored/Suspension-Anchored Part Orientation
			local WParts = {}

			local tPos = v.Position-car.DriveSeat.Position
			if v.Name=="FL" or v.Name=="RL" then
				v.CFrame = car.DriveSeat.CFrame*CFrame.Angles(math.rad(90),0,math.rad(90))
			else
				v.CFrame = car.DriveSeat.CFrame*CFrame.Angles(math.rad(90),0,math.rad(-90))
			end
			v.CFrame = v.CFrame+tPos

			if v:FindFirstChild("Parts")~=nil then
				getParts(v.Parts,WParts,v)
			end
			if v:FindFirstChild("Fixed")~=nil then
				getParts(v.Fixed,WParts,v)
			end

			--Align Wheels
			if v.Name=="FL" or v.Name=="FR" then
				v.CFrame = v.CFrame*CFrame.Angles(math.rad(_Tune.FCamber),0,0)
				if v.Name=="FL" then
					v.CFrame = v.CFrame*CFrame.Angles(0,0,math.rad(_Tune.FToe))
				else
					v.CFrame = v.CFrame*CFrame.Angles(0,0,math.rad(-_Tune.FToe))
				end
			elseif v.Name=="RL" or v.Name=="RR" then
				v.CFrame = v.CFrame*CFrame.Angles(math.rad(_Tune.RCamber),0,0)
				if v.Name=="RL" then
					v.CFrame = v.CFrame*CFrame.Angles(0,0,math.rad(_Tune.RToe))
				else
					v.CFrame = v.CFrame*CFrame.Angles(0,0,math.rad(-_Tune.RToe))
				end
			end

			--Re-orient Axle-Anchored/Suspension-Anchored Parts
			for _,a in pairs(WParts) do
				a[1].CFrame=v.CFrame:toWorldSpace(a[2])
			end



			--[[Chassis Assembly]
			--Create Steering Axle
			local arm=Instance.new("Part",v)
			arm.Name="Arm"
			arm.Anchored=true
			arm.CanCollide=false
			arm.FormFactor=Enum.FormFactor.Custom
			arm.Size=Vector3.new(_Tune.AxleSize,_Tune.AxleSize,_Tune.AxleSize)
			arm.CFrame=(v.CFrame*CFrame.new(0,_Tune.StAxisOffset,0))*CFrame.Angles(-math.pi/2,-math.pi/2,0)
			arm.CustomPhysicalProperties = PhysicalProperties.new(_Tune.AxleDensity,0,0,100,100)
			arm.TopSurface=Enum.SurfaceType.Smooth
			arm.BottomSurface=Enum.SurfaceType.Smooth
			arm.Transparency=1

			--Create Wheel Spindle
			local base=arm:Clone()
			base.Parent=v
			base.Name="Base"
			base.CFrame=base.CFrame*CFrame.new(0,_Tune.AxleSize,0)
			base.BottomSurface=Enum.SurfaceType.Hinge

			--Create Steering Anchor
			local axle=arm:Clone()
			axle.Parent=v
			axle.Name="Axle"
			axle.CFrame=CFrame.new(v.Position-((v.CFrame*CFrame.Angles(math.pi/2,0,0)).lookVector*((v.Size.x/2)+(axle.Size.x/2))),v.Position)*CFrame.Angles(0,math.pi,0)
			axle.BackSurface=Enum.SurfaceType.Hinge

			if v.Name=="F" or v.Name=="R" then
				local axle2=arm:Clone()
				axle2.Parent=v
				axle2.Name="Axle"
				axle2.CFrame=CFrame.new(v.Position+((v.CFrame*CFrame.Angles(math.pi/2,0,0)).lookVector*((v.Size.x/2)+(axle2.Size.x/2))),v.Position)*CFrame.Angles(0,math.pi,0)
				axle2.BackSurface=Enum.SurfaceType.Hinge
				MakeWeld(arm,axle2)
			end

			--Create Suspension
			if PGS_ON and _Tune.SusEnabled then			
				local sa=arm:Clone()
				sa.Parent=v
				sa.Name="#SA"
				if v.Name == "FL" or v.Name=="FR" or v.Name =="F" then
					local aOff = _Tune.FAnchorOffset
					sa.CFrame=v.CFrame*CFrame.new(_Tune.AxleSize/2,-fDistX,-fDistY)*CFrame.new(aOff[3],aOff[1],-aOff[2])*CFrame.Angles(-math.pi/2,-math.pi/2,0)
				else
					local aOff = _Tune.RAnchorOffset
					sa.CFrame=v.CFrame*CFrame.new(_Tune.AxleSize/2,-rDistX,-rDistY)*CFrame.new(aOff[3],aOff[1],-aOff[2])*CFrame.Angles(-math.pi/2,-math.pi/2,0)
				end

				local sb=sa:Clone()
				sb.Parent=v
				sb.Name="#SB"
				sb.CFrame=sa.CFrame*CFrame.new(0,0,_Tune.AxleSize)

				sb.FrontSurface=Enum.SurfaceType.Hinge	

				local g = Instance.new("BodyGyro",sb)
				g.Name = "Stabilizer"
				g.MaxTorque = Vector3.new(0,0,1)
				g.P = 0

				local sf1 = Instance.new("Attachment",sa)
				sf1.Name = "SAtt"

				local sf2 = sf1:Clone()
				sf2.Parent = sb


				if v.Name == "FL" or v.Name == "FR" or v.Name == "F" then
					sf1.Position = Vector3.new(fDistX-fSLX,-fDistY+fSLY,_Tune.AxleSize/2)
					sf2.Position = Vector3.new(fDistX,-fDistY,-_Tune.AxleSize/2)
				elseif v.Name == "RL" or v.Name=="RR" or v.Name == "R" then
					sf1.Position = Vector3.new(rDistX-rSLX,-rDistY+rSLY,_Tune.AxleSize/2)
					sf2.Position = Vector3.new(rDistX,-rDistY,-_Tune.AxleSize/2)
				end

				sb:MakeJoints()

				local sp = Instance.new("SpringConstraint",v)
				sp.Name = "Spring"
				sp.Attachment0 = sf1
				sp.Attachment1 = sf2
				sp.LimitsEnabled = true

				sp.Visible=_Tune.SusVisible
				sp.Radius=_Tune.SusRadius
				sp.Thickness=_Tune.SusThickness
				sp.Color=BrickColor.new(_Tune.SusColor)
				sp.Coils=_Tune.SusCoilCount

				if v.Name == "FL" or v.Name=="FR" or v.Name =="F" then
					g.D = _Tune.FAntiRoll
					sp.Damping = _Tune.FSusDamping
					sp.Stiffness = _Tune.FSusStiffness
					sp.FreeLength = _Tune.FSusLength+_Tune.FPreCompress
					sp.MaxLength = _Tune.FSusLength+_Tune.FExtensionLim
					sp.MinLength = _Tune.FSusLength-_Tune.FCompressLim
				else
					g.D = _Tune.RAntiRoll
					sp.Damping = _Tune.RSusDamping
					sp.Stiffness = _Tune.RSusStiffness
					sp.FreeLength = _Tune.RSusLength+_Tune.RPreCompress
					sp.MaxLength = _Tune.RSusLength+_Tune.RExtensionLim
					sp.MinLength = _Tune.RSusLength-_Tune.RCompressLim
				end

				MakeWeld(car.DriveSeat,sa)
				MakeWeld(sb,base)
			else
				MakeWeld(car.DriveSeat,base)
			end

			--Lock Rear Steering Axle
			if v.Name == "RL" or v.Name == "RR" or v.Name=="R" then
				MakeWeld(base,axle)
			end

			--Weld Assembly
			if v.Parent.Name == "RL" or v.Parent.Name == "RR" or v.Name=="R" then
				MakeWeld(car.DriveSeat,arm)
			end

			MakeWeld(arm,axle)

			arm:MakeJoints()
			axle:MakeJoints()

			--Weld Miscelaneous Parts
			if v:FindFirstChild("SuspensionFixed")~=nil then
				ModelWeld(v.SuspensionFixed,car.DriveSeat)
			end
			if v:FindFirstChild("WheelFixed")~=nil then
				ModelWeld(v.WheelFixed,axle)
			end
			if v:FindFirstChild("Fixed")~=nil then
				ModelWeld(v.Fixed,arm)
			end

			--Weld Wheel Parts
			if v:FindFirstChild("Parts")~=nil then
				ModelWeld(v.Parts,v)
			end

			--Add Steering Gyro
			if v:FindFirstChild("Steer") then
				v:FindFirstChild("Steer"):Destroy()
			end

			if v.Name=="FL" or v.Name=="FR" or v.Name=="F" then
				local steer=Instance.new("BodyGyro",arm)
				steer.Name="Steer"
				steer.P=_Tune.SteerP
				steer.D=_Tune.SteerD
				steer.MaxTorque=Vector3.new(0,_Tune.SteerMaxTorque,0)
				steer.cframe=v.CFrame*CFrame.Angles(0,-math.pi/2,0)
			end

			--Add Stabilization Gyro
			local gyro=Instance.new("BodyGyro",v)
			gyro.Name="Stabilizer"
			gyro.MaxTorque=Vector3.new(1,0,1)
			gyro.P=0
			if v.Name=="FL" or v.Name=="FR"  or v.Name=="F" then
				gyro.D=_Tune.FGyroDamp
			else
				gyro.D=_Tune.RGyroDamp
			end

			--Add Rotational BodyMover
			local AV=Instance.new("BodyAngularVelocity",v)
			AV.Name="#AV"
			AV.angularvelocity=Vector3.new(0,0,0)
			AV.maxTorque=Vector3.new(_Tune.PBrakeForce,0,_Tune.PBrakeForce)
			AV.P=1e9
		end



		--[[Vehicle Weight]	
		--Determine Current Mass
		local mass=0

		function getMass(p)
			for i,v in pairs(p:GetChildren())do
				if v:IsA("BasePart") then
					mass=mass+v:GetMass()
				end
				getMass(v)
			end	
		end
		getMass(car)

		--Apply Vehicle Weight
		if mass<_Tune.Weight*weightScaling then
			--Calculate Weight Distribution
			local centerF = Vector3.new()
			local centerR = Vector3.new()
			local countF = 0
			local countR = 0

			for i,v in pairs(Drive) do
				if v.Name=="FL" or v.Name=="FR" or v.Name=="F" then
					centerF = centerF+v.CFrame.p
					countF = countF+1
				else
					centerR = centerR+v.CFrame.p
					countR = countR+1
				end
			end
			centerF = centerF/countF
			centerR = centerR/countR
			local center = centerR:Lerp(centerF, _Tune.WeightDist/100)  

			--Create Weight Brick
			local weightB = Instance.new("Part",car.Body)
			weightB.Name = "#Weight"
			weightB.Anchored = true
			weightB.CanCollide = false
			weightB.BrickColor = BrickColor.new("Really black")
			weightB.TopSurface = Enum.SurfaceType.Smooth
			weightB.BottomSurface = Enum.SurfaceType.Smooth
			if _Tune.WBVisible then
				weightB.Transparency = .75			
			else
				weightB.Transparency = 1			
			end
			weightB.Size = Vector3.new(_Tune.WeightBSize[1],_Tune.WeightBSize[2],_Tune.WeightBSize[3])
			weightB.CustomPhysicalProperties = PhysicalProperties.new(((_Tune.Weight*weightScaling)-mass)/(weightB.Size.x*weightB.Size.y*weightB.Size.z),0,0,0,0)
			weightB.CFrame=(car.DriveSeat.CFrame-car.DriveSeat.Position+center)*CFrame.new(0,_Tune.CGHeight,0)
		else
			--Existing Weight Is Too Massive
			warn( "\n\t [AC".._BuildVersion.."]: Mass too high for specified weight."
				.."\n\t    Target Mass:\t"..(math.ceil(_Tune.Weight*weightScaling*100)/100)
				.."\n\t    Current Mass:\t"..(math.ceil(mass*100)/100)
				.."\n\t Reduce part size or axle density to achieve desired weight.")
		end

		local flipG = Instance.new("BodyGyro",car.DriveSeat)
		flipG.Name = "Flip"
		flipG.D = 0
		flipG.MaxTorque = Vector3.new(0,0,0)
		flipG.P = 0



		--[[Finalize Chassis]
		--Misc Weld
		wait()
		for i,v in pairs(script:GetChildren()) do
			if v:IsA("ModuleScript") then
				require(v)
			end
		end

		--Weld Body
		wait()
		ModelWeld(car.Body,car.DriveSeat)

		--Unanchor
		wait()	
		UnAnchor(car)

		--[[Manage Plugins]

		script.Parent["A-Chassis Interface"].Car.Value=car
		for i,v in pairs(script.Parent.Plugins:GetChildren()) do
			for _,a in pairs(v:GetChildren()) do
				if a:IsA("RemoteEvent") or a:IsA("RemoteFunction") then 
					a.Parent=car
					for _,b in pairs(a:GetChildren()) do
						if b:IsA("Script") then b.Disabled=false end
					end	
				end
			end
			v.Parent = script.Parent["A-Chassis Interface"]
		end
		script.Parent.Plugins:Destroy()



		--[[Remove Character Weight]
		--Get Seats
		local Seats = {}
		function getSeats(p)
			for i,v in pairs(p:GetChildren()) do
				if v:IsA("VehicleSeat") or v:IsA("Seat") then
					local seat = {}
					seat.Seat = v
					seat.Parts = {}
					table.insert(Seats,seat)
				end
				getSeats(v)
			end	
		end
		getSeats(car)

		--Store Physical Properties/Remove Mass Function
		function getPProperties(mod,t)
			for i,v in pairs(mod:GetChildren()) do
				if v:IsA("BasePart") then
					if v.CustomPhysicalProperties == nil then v.CustomPhysicalProperties = PhysicalProperties.new(v.Material) end
					table.insert(t,{v,v.CustomPhysicalProperties})
					v.CustomPhysicalProperties = PhysicalProperties.new(
						0,
						v.CustomPhysicalProperties.Friction,
						v.CustomPhysicalProperties.Elasticity,
						v.CustomPhysicalProperties.FrictionWeight,
						v.CustomPhysicalProperties.ElasticityWeight
					)
				end
				getPProperties(v,t)
			end			
		end

		--Apply Seat Handler
		for i,v in pairs(Seats) do
			--Sit Handler
			v.Seat.ChildAdded:connect(function(child)
				if child.Name=="SeatWeld" and child:IsA("Weld") and child.Part1~=nil and child.Part1.Parent ~= workspace and not child.Part1.Parent:IsDescendantOf(car) then
					v.Parts = {}
					getPProperties(child.Part1.Parent,v.Parts)
				end
			end)

			--Leave Handler
			v.Seat.ChildRemoved:connect(function(child)
				if child.Name=="SeatWeld" and child:IsA("Weld") then
					for i,v in pairs(v.Parts) do
						if v[1]~=nil and v[2]~=nil and v[1]:IsDescendantOf(workspace) then
							v[1].CustomPhysicalProperties = v[2]
						end
					end
					v.Parts = {}
				end
			end)
		end



		--[[Driver Handling]

		--Driver Sit	
		car.DriveSeat.ChildAdded:connect(function(child)
			if child.Name=="SeatWeld" and child:IsA("Weld") and game.Players:GetPlayerFromCharacter(child.Part1.Parent)~=nil then
				--Distribute Client Interface
				local p=game.Players:GetPlayerFromCharacter(child.Part1.Parent)
				car.DriveSeat:SetNetworkOwner(p)
				local g=script.Parent["A-Chassis Interface"]:Clone()
				g.Parent=p.PlayerGui
			end
		end)

		--Driver Leave
		car.DriveSeat.ChildRemoved:connect(function(child)
			if child.Name=="SeatWeld" and child:IsA("Weld") then
				--Remove Flip Force
				if car.DriveSeat:FindFirstChild("Flip")~=nil then
					car.DriveSeat.Flip.MaxTorque = Vector3.new()
				end

				--Remove Wheel Force
				for i,v in pairs(car.Wheels:GetChildren()) do
					if v:FindFirstChild("#AV")~=nil then
						if v["#AV"]:IsA("BodyAngularVelocity") then
							if v["#AV"].AngularVelocity.Magnitude>0 then
								v["#AV"].AngularVelocity = Vector3.new()
								v["#AV"].MaxTorque = Vector3.new()
							end
						else
							if v["#AV"].AngularVelocity>0 then
								v["#AV"].AngularVelocity = 0
								v["#AV"].MotorMaxTorque = 0
							end
						end
					end
				end
			end
		end)

		--[END]]
	elseif v.Name == "SwordScript" then
		source = [[--Rescripted by Luckymaxer
--EUROCOW WAS HERE BECAUSE I MADE THE PARTICLES AND THEREFORE THIS ENTIRE SWORD PRETTY AND LOOK PRETTY WORDS AND I'D LIKE TO DEDICATE THIS TO MY FRIENDS AND HI LUCKYMAXER PLS FIX SFOTH SWORDS TY LOVE Y'ALl
--Updated for R15 avatars by StarWars
--Re-updated by TakeoHonorable

Tool = script.Parent
Handle = Tool:WaitForChild("Handle")

function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end

local BaseUrl = "rbxassetid://"

Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")

DamageValues = {
	BaseDamage = 5,
	SlashDamage = 10,
	LungeDamage = 30
}

--For R15 avatars
Animations = {
	R15Slash = 522635514,
	R15Lunge = 522638767
}

Damage = DamageValues.BaseDamage

Grips = {
	Up = CFrame.new(0, 0, -1.70000005, 0, 0, 1, 1, 0, 0, 0, 1, 0),
	Out = CFrame.new(0, 0, -1.70000005, 0, 1, 0, 1, -0, 0, 0, 0, -1)
}

Sounds = {
	Slash = Handle:WaitForChild("SwordSlash"),
	Lunge = Handle:WaitForChild("SwordLunge"),
	Unsheath = Handle:WaitForChild("Unsheath")
}

ToolEquipped = false

--For Omega Rainbow Katana thumbnail to display a lot of particles.
for i, v in pairs(Handle:GetChildren()) do
	if v:IsA("ParticleEmitter") then
		v.Rate = 20
	end
end

Tool.Grip = Grips.Up
Tool.Enabled = true

function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end

function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end

function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end

function Blow(Hit)
	if not Hit or not Hit.Parent or not CheckIfAlive() or not ToolEquipped then
		return
	end
	local RightArm = Character:FindFirstChild("Right Arm") or Character:FindFirstChild("RightHand")
	if not RightArm then
		return
	end
	local RightGrip = RightArm:FindFirstChild("RightGrip")
	if not RightGrip or (RightGrip.Part0 ~= Handle and RightGrip.Part1 ~= Handle) then
		return
	end
	local character = Hit.Parent
	if character == Character then
		return
	end
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid or humanoid.Health == 0 then
		return
	end
	local player = Players:GetPlayerFromCharacter(character)
	if player and (player == Player or IsTeamMate(Player, player)) then
		return
	end
	UntagHumanoid(humanoid)
	TagHumanoid(humanoid, Player)
	humanoid:TakeDamage(Damage)	
end


function Attack()
	Damage = DamageValues.SlashDamage
	Sounds.Slash:Play()

	if Humanoid then
		if Humanoid.RigType == Enum.HumanoidRigType.R6 then
			local Anim = Instance.new("StringValue")
			Anim.Name = "toolanim"
			Anim.Value = "Slash"
			Anim.Parent = Tool
		elseif Humanoid.RigType == Enum.HumanoidRigType.R15 then
			local Anim = Tool:FindFirstChild("R15Slash")
			if Anim then
				local Track = Humanoid:LoadAnimation(Anim)
				Track:Play(0)
			end
		end
	end	
end

function Lunge()
	Damage = DamageValues.LungeDamage

	Sounds.Lunge:Play()
	
	if Humanoid then
		if Humanoid.RigType == Enum.HumanoidRigType.R6 then
			local Anim = Instance.new("StringValue")
			Anim.Name = "toolanim"
			Anim.Value = "Lunge"
			Anim.Parent = Tool
		elseif Humanoid.RigType == Enum.HumanoidRigType.R15 then
			local Anim = Tool:FindFirstChild("R15Lunge")
			if Anim then
				local Track = Humanoid:LoadAnimation(Anim)
				Track:Play(0)
			end
		end
	end	
	--[[
	if CheckIfAlive() then
		local Force = Instance.new("BodyVelocity")
		Force.velocity = Vector3.new(0, 10, 0) 
		Force.maxForce = Vector3.new(0, 4000, 0)
		Debris:AddItem(Force, 0.4)
		Force.Parent = Torso
	end
	]

		wait(0.2)
		Tool.Grip = Grips.Out
		wait(0.6)
		Tool.Grip = Grips.Up

		Damage = DamageValues.SlashDamage
	end

	Tool.Enabled = true
	LastAttack = 0

	function Activated()
		if not Tool.Enabled or not ToolEquipped or not CheckIfAlive() then
			return
		end
		Tool.Enabled = false
		local Tick = RunService.Stepped:wait()
		if (Tick - LastAttack < 0.2) then
			Lunge()
		else
			Attack()
		end
		LastAttack = Tick
		--wait(0.5)
		Damage = DamageValues.BaseDamage
		local SlashAnim = (Tool:FindFirstChild("R15Slash") or Create("Animation"){
			Name = "R15Slash",
			AnimationId = BaseUrl .. Animations.R15Slash,
			Parent = Tool
		})

		local LungeAnim = (Tool:FindFirstChild("R15Lunge") or Create("Animation"){
			Name = "R15Lunge",
			AnimationId = BaseUrl .. Animations.R15Lunge,
			Parent = Tool
		})
		Tool.Enabled = true
	end

	function CheckIfAlive()
		return (((Player and Player.Parent and Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent) and true) or false)
	end

	function Equipped()
		Character = Tool.Parent
		Player = Players:GetPlayerFromCharacter(Character)
		Humanoid = Character:FindFirstChildOfClass("Humanoid")
		Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("HumanoidRootPart")
		if not CheckIfAlive() then
			return
		end
		ToolEquipped = true
		Sounds.Unsheath:Play()
	end

	function Unequipped()
		Tool.Grip = Grips.Up
		ToolEquipped = false
	end

	Tool.Activated:Connect(Activated)
	Tool.Equipped:Connect(Equipped)
	Tool.Unequipped:Connect(Unequipped)

	Connection = Handle.Touched:Connect(Blow)]]
	elseif v.Parent.Name == "WeaponSpawner" then
		source = [[-- See if I have a tool
local spawner = script.Parent
local tool = nil
local region = Region3.new(Vector3.new(spawner.Position.X - spawner.Size.X/2, spawner.Position.Y + spawner.Size.Y/2, spawner.Position.Z - spawner.Size.Z/2),
   Vector3.new(spawner.Position.X + spawner.Size.X/2, spawner.Position.Y + 4, spawner.Position.Z + spawner.Size.Z/2))
local parts = game.Workspace:FindPartsInRegion3(region)
for _, part in pairs(parts) do
	if part and part.Parent and part.Parent:IsA("Tool") then
		tool = part.Parent
		break
	end
end

local configTable = spawner.Configurations
local configs = {}
local function loadConfig(configName, defaultValue)
	if configTable:FindFirstChild(configName) then
		configs[configName] = configTable:FindFirstChild(configName).Value
	else
		configs[configName] = defaultValue
	end
end

loadConfig("SpawnCooldown", 5)

if tool then
	tool.Parent = game.ServerStorage
	
	while true do
		-- put tool on pad
		local toolCopy = tool:Clone()
		local handle = toolCopy:FindFirstChild("Handle")
		toolCopy.Parent = game.Workspace
		local toolOnPad = true
		local parentConnection
		parentConnection = toolCopy.AncestryChanged:connect(function()
			if handle then handle.Anchored = false end
			toolOnPad = false
			parentConnection:disconnect()
		end)
		if handle then
			handle.CFrame = (spawner.CFrame + Vector3.new(0,handle.Size.Z/2 + 1,0)) * CFrame.Angles(-math.pi/2,0,0)
			handle.Anchored = true
		end
		-- wait for tool to be removed
		while toolOnPad do 
			if handle then
				handle.CFrame = handle.CFrame * CFrame.Angles(0,0,math.pi/60)
			end
			wait() 
		end
		
		-- wait for cooldown
		wait(configs["SpawnCooldown"])		
	end
	
end



--if tool then
--	local handle = tool:FindFirstChild("Handle")
--	local toolCopy = tool:Clone()
--	toolCopy.Parent = game.ServerStorage
--	local toolOnPad = true	
--	
--	local parentConnection
--	parentConnection = tool.AncestryChanged:connect(function()
--		if handle then handle.Anchored = false end
--		toolOnPad = false
--		parentConnection:disconnect()
--	end)
--	
--	if handle then
--		handle.CFrame = (spawner.CFrame + Vector3.new(0,handle.Size.Z/2 + 1,0)) * CFrame.Angles(-math.pi/2,0,0)
--		handle.Anchored = true
--	end
--	
--	while true do
--		while toolOnPad do
--			if handle then
--				handle.CFrame = handle.CFrame * CFrame.Angles(0,0,math.pi/60)
--			end
--			wait()
--		end
--		wait(configs["SpawnCooldown"])
--		local newTool = toolCopy:Clone()
--		newTool.Parent = game.Workspace
--		handle = newTool:FindFirstChild("Handle")
--		toolOnPad = true
--	end
--end]]
	elseif v.Name == "ShootServer" then
		source = [[local DebrisService = game:GetService("Debris")
local IconURL = script.Parent.TextureId
local Tool = script.Parent

--------Main Events----------
local Events = Tool:WaitForChild("Events")
local ShootEvent = Events:WaitForChild("ShootRE")
local CreateBulletEvent = Events:WaitForChild("CreateBullet")

pcall(function()
	script.Parent:FindFirstChild("ThumbnailCamera"):Destroy()
	script.Parent:WaitForChild("READ ME"):Destroy()
	
	if not workspace:FindFirstChild("BulletFolder") then
	local BulletsFolder = Instance.new("Folder", workspace)
	BulletsFolder.Name = "BulletsFolder"
	end
end)
	
function TagHumanoid(humanoid, player)
	if humanoid.Health > 0 then
	while humanoid:FindFirstChild('creator') do
		humanoid:FindFirstChild('creator'):Destroy()
	end 
	
	local creatorTag = Instance.new("ObjectValue")
	creatorTag.Value = player
	creatorTag.Name = "creator"
	creatorTag.Parent = humanoid
	DebrisService:AddItem(creatorTag, 1.5)

	local weaponIconTag = Instance.new("StringValue")
	weaponIconTag.Value = IconURL
	weaponIconTag.Name = "icon"
		weaponIconTag.Parent = creatorTag
	end
end

function CreateBullet(bulletPos)
	if not workspace:FindFirstChild("BulletFolder") then
		local BulletFolder = Instance.new("Folder")
		BulletFolder.Name = "Bullets"
	end
	local bullet = Instance.new('Part', workspace.BulletsFolder)
	bullet.FormFactor = Enum.FormFactor.Custom
	bullet.Size = Vector3.new(0.1, 0.1, 0.1)
	bullet.BrickColor = BrickColor.new("Black")
	bullet.Shape = Enum.PartType.Block
	bullet.CanCollide = false
	bullet.CFrame = CFrame.new(bulletPos)
	bullet.Anchored = true
	bullet.TopSurface = Enum.SurfaceType.Smooth
	bullet.BottomSurface = Enum.SurfaceType.Smooth
	bullet.Name = 'Bullet'
	DebrisService:AddItem(bullet, 2.5)
	
	local shell = Instance.new("Part")
	shell.CFrame = Tool.Handle.CFrame * CFrame.fromEulerAnglesXYZ(1.5,0,0)
	shell.Size = Vector3.new(1,1,1)
	shell.BrickColor = BrickColor.new(226)
	shell.Parent = game.Workspace.BulletsFolder
	shell.CFrame = script.Parent.Handle.CFrame
	shell.CanCollide = false
	shell.Transparency = 0
	shell.BottomSurface = 0
	shell.TopSurface = 0
	shell.Name = "Shell"
	shell.Velocity = Tool.Handle.CFrame.lookVector * 35 + Vector3.new(math.random(-10,10),20,math.random(-10,20))
	shell.RotVelocity = Vector3.new(0,200,0)
	DebrisService:AddItem(shell, 1)
	
	local shellmesh = Instance.new("SpecialMesh")
	shellmesh.Scale = Vector3.new(.15,.4,.15)
	shellmesh.Parent = shell
end

ShootEvent.OnServerEvent:Connect(function(plr, hum ,damage)
	hum:TakeDamage(damage)
	TagHumanoid(hum, plr)
end)

CreateBulletEvent.OnServerEvent:Connect(function(plr, pos)
	CreateBullet(pos)
end)]]
	elseif v.Parent.Name == "Img" then
		source = [[local imgs = {103740493,103804266,103804383}
for _,v in pairs(imgs) do
	game:GetService("ContentProvider"):Preload("http://www.roblox.com/asset/?ID="..v)
end

script.Parent.Parent.Changed:connect(function ()
	if script.Parent.Parent.Enabled == true then
		wait(0.09)
		script.Parent.Parent.Enabled = false
	end
end)

while true do
	for i = 1,#imgs do
		script.Parent.Image = "http://www.roblox.com/asset/?ID="..imgs[i]
		wait(0.03)
	end
end
]]
	elseif v.Name == "Animate" and v.Parent:FindFirstChildOfClass("Humanoid") then
		source = [[function   waitForChild(parent, childName)
	local child = parent:findFirstChild(childName)
	if child then return child end
	while true do
		child = parent.ChildAdded:wait()
		if child.Name==childName then return child end
	end
end

local Figure = script.Parent
local Torso = waitForChild(Figure, "Torso")
local RightShoulder = waitForChild(Torso, "Right Shoulder")
local LeftShoulder = waitForChild(Torso, "Left Shoulder")
local RightHip = waitForChild(Torso, "Right Hip")
local LeftHip = waitForChild(Torso, "Left Hip")
local Neck = waitForChild(Torso, "Neck")
local Humanoid = waitForChild(Figure, "Humanoid")
local pose = "Standing"

local currentAnim = ""
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=125750544", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=125750618", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=125749145", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=125750759", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=125750800", weight = 10 } 
			}, 
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=125750867", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance = {
				{ id = "http://www.roblox.com/asset/?id=130018893", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=132546839", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=132546884", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=160934142", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=160934298", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=160934376", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=160934458", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=160934530", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=160934593", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

math.randomseed(tick())

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = script:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

script.ChildAdded:connect(scriptChildModified)
script.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)
		local repeatAnim = stopAllAnimations()
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid)
	local idleFromEmote = (animName == "idle" and emoteNames[currentAnim] ~= nil)
	if (animName ~= currentAnim and not idleFromEmote) then		 
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
	end
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)
		local repeatAnim = stopToolAnimations()
		playToolAnimation(repeatAnim, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid)
	if (animName ~= toolAnimName) then		 
		
		if (toolAnimTrack ~= nil) then
			toolAnimTrack:Stop()
			toolAnimTrack:Destroy()
			transitionTime = 0
		end

		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		-- load it to the humanoid; get AnimationTrack
		toolAnimTrack = humanoid:LoadAnimation(anim)
		 
		-- play the animation
		toolAnimTrack:Play(transitionTime)
		toolAnimName = animName

		currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
	end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	if speed>0.01 then
		playAnimation("walk", 0.1, Humanoid)
		pose = "Running"
	else
		playAnimation("idle", 0.1, Humanoid)
		pose = "Standing"
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed>0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		stopAllAnimations()
		moveSit()
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool then
	
		animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- main program

local runService = game:service("RunService");

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent~=nil do
	local _, time = wait(0.1)
	move(time)
end


]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("ModuleScripts") then
		source = [[local zombie = script.Parent

for _, script in pairs(zombie.ModuleScripts:GetChildren()) do
	if not game.ServerStorage:FindFirstChild(script.Name) then
		script:Clone().Parent = game.ServerStorage
	end
end

local AI = require(game.ServerStorage.ROBLOX_ZombieAI).new(zombie)
local DestroyService = require(game.ServerStorage.ROBLOX_DestroyService)


local function clearParts(parent)
	for _, part in pairs(parent:GetChildren()) do
		clearParts(part)
	end
	local delay
	if parent:IsA("Part") then
		delay = math.random(5,10)
	else
		delay = 11
	end
	DestroyService:AddItem(parent, delay)
end

zombie.Humanoid.Died:connect(function()
	AI.Stop()
	math.randomseed(tick())
	clearParts(zombie)
	script.Disabled = true
end)

local lastMoan = os.time()
math.randomseed(os.time())
while true do
	local animationTrack = zombie.Humanoid:LoadAnimation(zombie.Animations.Arms)
	animationTrack:Play()
--	local now = os.time()
--	if now - lastMoan > 5 then	
--		if math.random() > .3 then
--			zombie.Moan:Play()
----			print("playing moan")
--			lastMoan = now
--		end
--	end
	wait(2)
end

]]
	elseif v.Name == "Sprint on shift" then
		source = [[function onPlayerEntered(player)
	repeat wait () until player.Character ~= nil
	local s = script.SprintScript:clone()
	s.Parent = player.Character
	s.Disabled = false
	player.CharacterAdded:connect(function (char)
		local s = script.SprintScript:clone()
		s.Parent = char
		s.Disabled = false		
	end)
end

game.Players.PlayerAdded:connect(onPlayerEntered)

--Fozetts was here--]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("Decal") and v.Parent.Name == "Checkpoint" then
		source = [[local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")

local checkpoint = script.Parent

function onTouched(hit)
	if hit and hit.Parent and hit.Parent:FindFirstChildOfClass("Humanoid") then
		local player = Players:GetPlayerFromCharacter(hit.Parent)
		local checkpointData = ServerStorage:FindFirstChild("CheckpointData")
		if not checkpointData then
			checkpointData = Instance.new("Folder")
			checkpointData.Name = "CheckpointData"
			checkpointData.Parent = ServerStorage
		end
		
		local userIdString = tostring(player.UserId)
		local checkpointValue = checkpointData:FindFirstChild(userIdString)
		if not checkpointValue then
			checkpointValue = Instance.new("ObjectValue")
			checkpointValue.Name = userIdString
			checkpointValue.Parent = checkpointData
			
			player.CharacterAdded:connect(function(character)
				wait()
				local storedCheckpoint = ServerStorage.CheckpointData[userIdString].Value
				character:MoveTo(storedCheckpoint.Position + Vector3.new(math.random(-4, 4), 4, math.random(-4, 4)))
			end)
		end
		
		checkpointValue.Value = checkpoint
	end
end

checkpoint.Touched:Connect(onTouched)]]
	end
	if v.Name == "Script" and v.Parent:FindFirstChild("firing") then
		source = [[script.Parent.ChildAdded:connect(function(child)
	if child.Name=="SeatWeld" then
		local flyer=script.LocalScript:Clone()
		flyer.Disabled= false
		flyer.Parent=script.Parent.Parent
		script.Parent.Parent.Parent=child.Part1.Parent
		script.Parent.Parent.Rotor1.sound:Play()
		for i,v in ipairs(script.Parent.Parent:GetChildren()) do
			if v:IsA("Seat") then
				v.Disabled = false
			end
		end
	end
end)

script.Parent.ChildRemoved:connect(function(child)
	if child.Name=="SeatWeld" then
		script.Parent.Parent.Parent=workspace
		---script.Parent.Parent.Engine:ClearAllChildren()
--		if script.Parent.Parent.Engine:FindFirstChild("BodyGyro") then
--			script.Parent.Parent.Engine.BodyGyro:Destroy()
--		end
--		if script.Parent.Parent.Engine:FindFirstChild("BodyVelocity") then
--			script.Parent.Parent.Engine.BodyBodyVelocity:Destroy()
--		end
		if script.Parent.Parent:FindFirstChild("LocalScript") then
			script.Parent.Parent:FindFirstChild("LocalScript"):Destroy()
		end
		script.Parent.Parent.Rotor1.sound:Stop()
		for i,v in ipairs(script.Parent.Parent:GetChildren()) do
			if v:IsA("Seat") then
				v.Disabled = true
			end
		end
	end
end)]]
	elseif v.Parent.Name == "firing" then
		source = [[local firin = false

script.Parent.OnServerEvent:Connect(function(plr,value,mouseHit,mouseTarget)
	firin = value
	wait()
	while firin do 
	wait()
		if mouseTarget == nil then return end
		if mouseTarget.Parent ~= script.Parent.Parent.Parent and mouseTarget.Parent.Parent ~= script.Parent.Parent.Parent then
			for i = 1, math.random(4,5) do
				script.Parent.Parent.fire:Play()
				local theTar = mouseHit.p + Vector3.new(math.random(-5, 5), math.random(-5, 5), math.random(-5, 5))
				local bull = Instance.new("Part")
				bull.Parent = game.Workspace
				bull.CFrame = CFrame.new((theTar + script.Parent.Parent.Parent.Gun1.Position)/2,script.Parent.Parent.Parent.Gun1.Position) --- script.Parent.Parent is the vehicle seat
				bull.CanCollide = false
				bull.BrickColor = BrickColor.new(24)
				bull.Anchored = true
				bull.Size = Vector3.new(1,1.2,1)
				game.Debris:AddItem(bull,0.1)
				local mesher = Instance.new("BlockMesh")
				mesher.Parent = bull
				mesher.Scale = Vector3.new(0.2, 0.2, (mouseHit.p - script.Parent.Parent.Parent.Gun1.Position).magnitude)
				local ex = Instance.new("Explosion")
				ex.BlastRadius = 5
				ex.BlastPressure = 5000
				ex.Position = theTar
				ex.Parent = game.Workspace
				wait(0.06)
			end
		end
	end
end)]]
	elseif v.Name == "Weld Script" then
		source = [[script.Parent:MakeJoints()]]
	elseif v.Name == "regen" and v.Parent.Name == "Button1" then
		source = [[-- dark886's click regen script 
-- just place this script to the button
-- just place the button to the model
-- just place the model to anywhere lol

location = script.Parent.Parent.Parent
regen = script.Parent.Parent
save = regen:clone()

function onClicked()
	regen:remove()
	back = save:clone()
	back.Parent = location
	back:MakeJoints()
end 

script.Parent.ClickDetector.MouseClick:connect(onClicked)]]
	elseif v.Parent.Parent:GetChildren()[72] and v.Parent.Name == "Part" and v.Name == "Script" then
		source = [[local block = script.Parent
db = false

function onTouch()
	if db == false then
		db = true
		for i = 1, 20 do
			block.Transparency = i/20
			wait(0.05)
		end
		block.CanCollide = false
		wait(2)
		block.CanCollide = true
		block.Transparency = 0
		db = false
	end
end

block.Touched:connect(onTouch)
]]
	elseif v.Name == "Script" and v.Parent.Name == "SitPart" then
		source = [[script.Parent.Touched:connect(function(obj)
	if obj.Parent:FindFirstChild("Humanoid") then
		obj.Parent.Humanoid.Sit = true
	end
end)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("Hinge") and v.Parent.Name == "Obby" then
		source = [[local hinge = script.Parent.Hinge
local pole = script.Parent.Pole
local base = script.Parent.Base

pole.BodyGyro.cframe = pole.CFrame
base.BodyPosition.Position = base.Position

for i, v in pairs(script.Parent:GetChildren()) do
	if v:IsA("BasePart") and v ~= hinge then
		v.Anchored = false
	end
end]]
	elseif v.Name == "SeeSawScript" then
		source = [[local Swing = script.Parent:WaitForChild("Swing")

-- Seats
local Seat1 = Swing:WaitForChild("Seat1")
local Seat2 = Swing:WaitForChild("Seat2")

-- Motor(s)
local SeeSawMotor = script.Parent:WaitForChild("SeeSawMotor")

local function OnSeatsChange(ChangedSeat)
	local Seat1Occupant = Seat1.Occupant
	local Seat2Occupant = Seat2.Occupant
	local Seat1T = Seat1.Throttle
	local Seat2T = Seat2.Throttle
	
	if Seat1Occupant and Seat2Occupant == nil then
		SeeSawMotor.DesiredAngle = 0.3
	elseif Seat2Occupant and Seat1Occupant == nil then
		SeeSawMotor.DesiredAngle = -0.3
	end
	
	if Seat1Occupant and Seat2Occupant then

		-- When both inputs are equal or would seem equal, make it balanced
		if Seat2T == 0 and Seat1T == 0 or Seat1T == -1 and Seat2T == -1 or Seat1T == 1 and Seat2T == 1 or Seat1T == -1 and Seat2T == 0 or Seat1T == 0 and Seat2T == -1 then
			SeeSawMotor.DesiredAngle = 0
			return
		end

		-- Seat1 logic
		if Seat1T == 1 and Seat2T == 0 or Seat1T == 1 and Seat2T == -1 then
			SeeSawMotor.DesiredAngle = 0.3
		end
		
		-- Seat2 logic
		if Seat2T == 1 and Seat1T == 0 or Seat2T == 1 and Seat1T == -1 then
			SeeSawMotor.DesiredAngle = -0.3
		end
	end
end

-- Events to listen to any player inputs
Seat1.Changed:connect(OnSeatsChange)
Seat2.Changed:connect(OnSeatsChange)]]
	elseif v.Name == "SwingScript" and v.Parent:FindFirstChild("Hinge2") then
		source = [[local Home = script.Parent
local Supports = Home:WaitForChild("Supports")
local Swing1 = Home:WaitForChild("Swing1")
local Swing2 = Home:WaitForChild("Swing2")

-- Parts
local Frame = Home:WaitForChild("Frame")

local Hook1 = Swing1:WaitForChild("Hook1")
local Hook2 = Swing1:WaitForChild("Hook2")
local Hook3 = Swing2:WaitForChild("Hook3")
local Hook4 = Swing2:WaitForChild("Hook4")
local SwingSeat1 = Swing1:WaitForChild("SwingSeat1")
local SwingSeat2 = Swing2:WaitForChild("SwingSeat2")
local SwingMesh1 = Swing1:WaitForChild("SwingMesh1")
local SwingMesh2 = Swing2:WaitForChild("SwingMesh2")

local RopeSupport1 = Supports:WaitForChild("RopeSupport1")
local RopeSupport2 = Supports:WaitForChild("RopeSupport2")
local RopeSupport3 = Supports:WaitForChild("RopeSupport3")
local RopeSupport4 = Supports:WaitForChild("RopeSupport4")

-- Other
local CurrentOccupant = nil
local Vector3New,CFrameNew,CFrameAngles,MathRad,MathAbs = Vector3.new,CFrame.new,CFrame.Angles,math.rad,math.abs

-- Settings
local Configuration = Home:WaitForChild("Configuration")
local SwingPower = Configuration:WaitForChild("SwingPower")

local function SetPhysicalProperties(Part,Density)
	if Part then
		Part.CustomPhysicalProperties = PhysicalProperties.new(Density,Part.Friction,Part.Elasticity)
	end
end

GetAllDescendants = function(instance, func)
	func(instance)
	for _, child in next, instance:GetChildren() do
		GetAllDescendants(child, func)
	end
end

local function SetCharacterToWeight(ToDensity,Char)
	GetAllDescendants(Char,function(d)
		if d and d.Parent and d:IsA("BasePart") then
			SetPhysicalProperties(d,ToDensity)
		end
	end)
end

local function OnSeatChange(Seat)
	if Seat.Occupant then
		local CurrentThrottle = Seat.Throttle
		local BodyForce = Seat:WaitForChild("BodyForce")
		
		-- Adjust swing when interacted
		if CurrentThrottle == 1 then
			BodyForce.Force = Seat.CFrame.lookVector * SwingPower.Value * 100
		elseif CurrentThrottle == -1 then
			BodyForce.Force = Seat.CFrame.lookVector * SwingPower.Value * -100
		else
			BodyForce.Force = Vector3New()
		end
		
		delay(0.2,function()
			BodyForce.Force = Vector3New()
		end)
		
		-- Make the character weightless for the swing to behave correctly
		if CurrentOccupant == nil then
			CurrentOccupant = Seat.Occupant
			SetCharacterToWeight(0,CurrentOccupant.Parent)
		end
		
	elseif CurrentOccupant then
		-- Set the character's weight back
		SetCharacterToWeight(0.7,CurrentOccupant.Parent)
		CurrentOccupant = nil
	end
end

SwingSeat1.Changed:connect(function()
	OnSeatChange(SwingSeat1)
end)

SwingSeat2.Changed:connect(function()
	OnSeatChange(SwingSeat2)
end)]]
	elseif v.Name == "TireSwingScript" then
		source = [[local Home = script.Parent
local Tire = Home:WaitForChild("Tire")
local TopBar = Home:WaitForChild("TopBar")

-- Parts
local TopBarPart = Home:WaitForChild("TopBarPart")


local Hook1 = Tire:WaitForChild("Hook1")
local Hook2 = Tire:WaitForChild("Hook2")
local TireMesh = Tire:WaitForChild("TireMesh")
local TireSeat = Tire:WaitForChild("TireSeat")

local RopeSupport1 = TopBar:WaitForChild("RopeSupport1")
local RopeSupport2 = TopBar:WaitForChild("RopeSupport2")

-- Body objects
local BodyForce = TireMesh:WaitForChild("BodyForce")

-- Other
local CurrentOccupant = nil
local Vector3New,CFrameNew,CFrameAngles,MathRad,MathAbs = Vector3.new,CFrame.new,CFrame.Angles,math.rad,math.abs

-- Settings
local Configuration = Home:WaitForChild("Configuration")
local SwingPower = Configuration:WaitForChild("SwingPower")

local function SetPhysicalProperties(Part,Density)
	if Part then
		Part.CustomPhysicalProperties = PhysicalProperties.new(Density,Part.Friction,Part.Elasticity)
	end
end

GetAllDescendants = function(instance, func)
	func(instance)
	for _, child in next, instance:GetChildren() do
		GetAllDescendants(child, func)
	end
end

local function SetCharacterToWeight(ToDensity,Char)
	GetAllDescendants(Char,function(d)
		if d and d.Parent and d:IsA("BasePart") then
			SetPhysicalProperties(d,ToDensity)
		end
	end)
end

TireSeat.Changed:connect(function()
	if TireSeat.Occupant then
		local CurrentThrottle = TireSeat.Throttle
		
		-- Adjust swing when interacted
		if CurrentThrottle == 1 then
			BodyForce.Force = TireMesh.CFrame.lookVector * SwingPower.Value * 100
		elseif CurrentThrottle == -1 then
			BodyForce.Force = TireMesh.CFrame.lookVector * SwingPower.Value * -100
		else
			BodyForce.Force = Vector3New()
		end
		
		delay(0.2,function()
			BodyForce.Force = Vector3New()
		end)
		
		-- Make the character weightless for the swing to behave correctly
		if CurrentOccupant == nil then
			CurrentOccupant = TireSeat.Occupant
			SetCharacterToWeight(0,CurrentOccupant.Parent)
		end
		
	elseif CurrentOccupant then
		-- Set the character's weight back
		SetCharacterToWeight(0.7,CurrentOccupant.Parent)
		CurrentOccupant = nil
	end
end)]]
	elseif v.Name == "SlideScript" and v.Parent.Name == "Tube Slide" then
		source = [[local Slide = script.Parent:WaitForChild("Slide")

-- Parts
local Entry = Slide:WaitForChild("Entry")

local function MovePlayer(Part)
	if game.Players:GetPlayerFromCharacter(Part.Parent) then
		local Character = Part.Parent
		local Humanoid = Character:WaitForChild("Humanoid")
		local RootPart = Character:WaitForChild("HumanoidRootPart")
		
		if Humanoid.Sit == false then
			-- Make player sit
			Humanoid.Sit = true
			
			if Character.PrimaryPart then
				-- Move player
				Character:SetPrimaryPartCFrame(Entry.CFrame * CFrame.Angles(0,0,math.rad(90)) + Entry.CFrame.lookVector*2)
			else
				-- Extra precaution
				RootPart.CFrame = CFrame.new(Entry.CFrame * CFrame.Angles(0,0,math.rad(90)) + Entry.CFrame.lookVector*2)
			end
		end
	end
end

-- Listen for touches
Entry.Touched:connect(MovePlayer)]]
	elseif v.Name == "Ignore" and v.Parent.Name == "TeleportParts" then
		source = [[local TeleportPart1 = script.Parent.TeleportPart1
local TeleportPart2 = script.Parent.TeleportPart2

TeleportPart1.Touched:Connect(function(hit)
	local w = hit.Parent:FindFirstChild("HumanoidRootPart")
	if w then
		w.CFrame = TeleportPart2.CFrame + Vector3.new(0, 5, 0)
		TeleportPart2.CanTouch = false
		wait(1)
		TeleportPart2.CanTouch = true
	end
end)

TeleportPart2.Touched:Connect(function(hit)
	local w = hit.Parent:FindFirstChild("HumanoidRootPart")
	if w then
		w.CFrame = TeleportPart1.CFrame + Vector3.new(0, 5, 0)
		TeleportPart1.CanTouch = false
		wait(1)
		TeleportPart1.CanTouch = true
	end
end)]]
	elseif v.Name == "TurnOffScript" then
		source = [[local Click = script.Parent
local CellParts = script.Parent.Parent.Parent.Parent.CellPartsTotal.CellPartsImportant

print("Jail Cell by kwkxbxkdkdjjd loaded.")

Click.MouseClick:Connect(function()
	CellParts.CellPart1.Transparency = 0
	CellParts.CellPart1.CanCollide = true
	
	CellParts.CellPart2.Transparency = 0
	CellParts.CellPart2.CanCollide = true
	
	CellParts.CellPart3.Transparency = 0
	CellParts.CellPart3.CanCollide = true
	
	CellParts.CellPart4.Transparency = 0
	CellParts.CellPart4.CanCollide = true
	
	CellParts.CellPart5.Transparency = 0
	CellParts.CellPart5.CanCollide = true
	
	CellParts.CellPart6.Transparency = 0
	CellParts.CellPart6.CanCollide = true
	
	CellParts.CellPart7.Transparency = 0
	CellParts.CellPart7.CanCollide = true
	
	wait(.2)
	
end)]]
	elseif v.Name == "TurnOnScript" then
		source = [[local Click = script.Parent
local CellParts = script.Parent.Parent.Parent.Parent.CellPartsTotal.CellPartsImportant

Click.MouseClick:Connect(function()
	CellParts.CellPart1.Transparency = 1
	CellParts.CellPart1.CanCollide = false

	CellParts.CellPart2.Transparency = 1
	CellParts.CellPart2.CanCollide = false

	CellParts.CellPart3.Transparency = 1
	CellParts.CellPart3.CanCollide = false

	CellParts.CellPart4.Transparency = 1
	CellParts.CellPart4.CanCollide = false

	CellParts.CellPart5.Transparency = 1
	CellParts.CellPart5.CanCollide = false

	CellParts.CellPart6.Transparency = 1
	CellParts.CellPart6.CanCollide = false

	CellParts.CellPart7.Transparency = 1
	CellParts.CellPart7.CanCollide = false

	wait(.2)

end)]]
	elseif v.Name == "Day/Night Cycle" then
		source = [[-- dayLength defines how long, in minutes, a day in your game is. Feel free to alter it.
local dayLength = 12

local cycleTime = dayLength*60
local minutesInADay = 24*60

local lighting = game:GetService("Lighting")

local startTime = tick() - (lighting:getMinutesAfterMidnight() / minutesInADay)*cycleTime
local endTime = startTime + cycleTime

local timeRatio = minutesInADay / cycleTime

if dayLength == 0 then
	dayLength = 1
end

repeat
	local currentTime = tick()
	
	if currentTime > endTime then
		startTime = endTime
		endTime = startTime + cycleTime
	end
	
	lighting:setMinutesAfterMidnight((currentTime - startTime)*timeRatio)
	wait(1/15)
until false
]]
	elseif v.Name == "KillWall" or v.Name == "KillScript" then
		source = [[script.Parent.Touched:connect(function(hit)
	if hit and hit.Parent and hit.Parent:FindFirstChild("Humanoid") then
		hit.Parent.Humanoid.Health = 0
	end
end)]]
	elseif v.Name == "MasterScript" then
		source = [[Code = "2323" --change To any numbers You like
Input = ""


--This Is for my buddy siros

--created by
------------------------------------------
--Clear And Enter

function Clear()
print("Cleared")
Input = ""
end

script.Parent.Clear.ClickDetector.MouseClick:connect(Clear)




function Enter()
if Input == Code then
print("Entered")
Input = ""

local door = script.Parent.Parent.Door

door.CanCollide = false
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = 0.8
wait(3)--
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = 0
door.CanCollide = true



return end
Input = ""
print("Wrong Code")
end




script.Parent.Enter.ClickDetector.MouseClick:connect(Enter)

------------------------------------------
--Digets


function Click0()
Input = Input..0
print("0") 
script.Parent.B0.Decal.Texture = "http://www.roblox.com/asset/?id=2767674"
wait(0.1)
script.Parent.B0.Decal.Texture = "http://www.roblox.com/asset/?id=2761903"
end

script.Parent.B0.ClickDetector.MouseClick:connect(Click0)

function Click1()
Input = Input..1
print("1")
script.Parent.B1.Decal.Texture = "http://www.roblox.com/asset/?id=2767677"
wait(0.1)
script.Parent.B1.Decal.Texture = "http://www.roblox.com/asset/?id=2761913"
end

script.Parent.B1.ClickDetector.MouseClick:connect(Click1)

function Click2()
Input = Input..2
print("2")
script.Parent.B2.Decal.Texture = "http://www.roblox.com/asset/?id=2767680"
wait(0.1)
script.Parent.B2.Decal.Texture = "http://www.roblox.com/asset/?id=2761922"
end

script.Parent.B2.ClickDetector.MouseClick:connect(Click2)

function Click3()
Input = Input..3
print("3")
script.Parent.B3.Decal.Texture = "http://www.roblox.com/asset/?id=2767686"
wait(0.1)
script.Parent.B3.Decal.Texture = "http://www.roblox.com/asset/?id=2761927"
end

script.Parent.B3.ClickDetector.MouseClick:connect(Click3)

function Click4()
Input = Input..4
print("4")
script.Parent.B4.Decal.Texture = "http://www.roblox.com/asset/?id=2767693"
wait(0.1)
script.Parent.B4.Decal.Texture = "http://www.roblox.com/asset/?id=2761938"
end

script.Parent.B4.ClickDetector.MouseClick:connect(Click4)

function Click5()
Input = Input..5
print("5")
script.Parent.B5.Decal.Texture = "http://www.roblox.com/asset/?id=2767695"
wait(0.1)
script.Parent.B5.Decal.Texture = "http://www.roblox.com/asset/?id=2761943"
end

script.Parent.B5.ClickDetector.MouseClick:connect(Click5)

function Click6()
Input = Input..6
print("6")
script.Parent.B6.Decal.Texture = "http://www.roblox.com/asset/?id=2767699"
wait(0.1)
script.Parent.B6.Decal.Texture = "http://www.roblox.com/asset/?id=2761948"
end

script.Parent.B6.ClickDetector.MouseClick:connect(Click6)

function Click7()
Input = Input..7
print("7")
script.Parent.B7.Decal.Texture = "http://www.roblox.com/asset/?id=2767701"
wait(0.1)
script.Parent.B7.Decal.Texture = "http://www.roblox.com/asset/?id=2761956"
end

script.Parent.B7.ClickDetector.MouseClick:connect(Click7)

function Click8()
Input = Input..8
print("8")
script.Parent.B8.Decal.Texture = "http://www.roblox.com/asset/?id=2767707"
wait(0.1)
script.Parent.B8.Decal.Texture = "http://www.roblox.com/asset/?id=2761961"
end

script.Parent.B8.ClickDetector.MouseClick:connect(Click8)

function Click9()
Input = Input..9
print("9")
script.Parent.B9.Decal.Texture = "http://www.roblox.com/asset/?id=2767714"
wait(0.1)
script.Parent.B9.Decal.Texture = "http://www.roblox.com/asset/?id=2761971"
end

script.Parent.B9.ClickDetector.MouseClick:connect(Click9)















]]
	elseif v.Name == "Script" and v.Parent.Name == "Open" and v:FindFirstChild("Value") then
		source = [[door = script.Parent.Parent.Door

function clicked()
if script.Value.Value == 0 then
print("Opened")
script.Value.Value = 1
local door = script.Parent.Parent.Door

door.CanCollide = false
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = door.Transparency + 0.1
wait(0.1)
door.Transparency = 0.8
wait(3)--
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = door.Transparency - 0.1
wait(0.1)
door.Transparency = 0
door.CanCollide = true
script.Value.Value = 0
end
end


script.Parent.ClickDetector.MouseClick:connect(clicked)]]
	elseif v.Parent.Name == "Teleport" and v.Parent.Parent:FindFirstChild("Border") then
		source = [[local portal_name = "Portal2" --Portal Name here
local portal = script.Parent.Parent.Parent:FindFirstChild(portal_name)

script.Parent.Touched:Connect(function(hit)
	if game.Players:GetPlayerFromCharacter(hit.Parent) then
		local humanoidRootPart = hit.Parent:WaitForChild("HumanoidRootPart")
		
		humanoidRootPart.CFrame = CFrame.new(portal.Teleport.Position.X - 5,portal.Teleport.Position.Y,portal.Teleport.Position.Z)
	end
end)]]
	elseif v.Name == "Giver Script" and v.Parent:FindFirstChild("Local Gui") then
		source = [[local debounce = false

function getPlayer(humanoid) 
local players = game.Players:children() 
for i = 1, #players do 
if players[i].Character.Humanoid == humanoid then return players[i] end 
end 
return nil 
end 

function onTouch(part) 

local human = part.Parent:findFirstChild("Humanoid") 
if (human ~= nil) and debounce == false then

debounce = true

local player = getPlayer(human) 

if (player == nil) then return end 

script.Parent:clone().Parent = player.Backpack

wait(2)
debounce = false
end
end


script.Parent.Parent.Touched:connect(onTouch) 
]]
	elseif v.Name == "CleanUp" and v.Parent.Name == "Local Gui" then
		source = [[wait(5)  --Change this if you want the path to dissapear faster!
script.Parent:remove()]]
	elseif v.Parent.Name == "Fly" and v.Name == "Script" then
		source = [[Name = "Fly"
pi = 3.141592653589793238462643383279502884197163993751
a = 0
s = 0
ndist = 13
rs = 0.025
siz = Vector3.new(1, 1, 1)
form = 0
flow = {}
function CFC(P1,P2)
	local Place0 = CFrame.new(P1.CFrame.x,P1.CFrame.y,P1.CFrame.z) 
	local Place1 = P2.Position
	P1.Size = Vector3.new(P1.Size.x,P1.Size.y,(Place0.p - Place1).magnitude) 
	P1.CFrame = CFrame.new((Place0.p + Place1)/2,Place0.p)
end
function checktable(table, parentneeded)
	local i
	local t = {}
	for i = 1, #table do
		if table[i] ~= nil then
			if string.lower(type(table[i])) == "userdata" then
				if parentneeded == true then
					if table[i].Parent ~= nil then
						t[#t + 1] = table[i]
					end
				else
					t[#t + 1] = table[i]
				end
			end
		end
	end
	return t
end
if script.Parent.Name ~= Name then
User = game:service("Players").Nineza
HB = Instance.new("HopperBin")
HB.Name = Name
HB.Parent = User.StarterGear
script.Parent = HB
User.Character:BreakJoints()
end
speed = 50
script.Parent.Selected:connect(function(mar)
	s = 1
	torso = script.Parent.Parent.Parent.Character.Torso
	LeftShoulder = torso["Left Shoulder"]
	RightShoulder = torso["Right Shoulder"]
	LeftHip = torso["Left Hip"]
	RightHip = torso["Right Hip"]
	human = script.Parent.Parent.Parent.Character.Humanoid
	bv = Instance.new("BodyVelocity")
	bv.maxForce = Vector3.new(0,math.huge,0)
	bv.velocity = Vector3.new(0,0,0)
	bv.Parent = torso
	bg = Instance.new("BodyGyro")
	bg.maxTorque = Vector3.new(0,0,0)
	bg.Parent = torso 
	connection = mar.Button1Down:connect(function()
		a = 1
		bv.maxForce = Vector3.new(math.huge,math.huge,math.huge)
		bg.maxTorque = Vector3.new(900000,900000,900000)
		bg.cframe = CFrame.new(torso.Position,mar.hit.p) * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
		bv.velocity = CFrame.new(torso.Position,mar.hit.p).lookVector * speed
		moveconnect = mar.Move:connect(function()
			bg.maxTorque = Vector3.new(900000,900000,900000)
			bg.cframe = CFrame.new(torso.Position,mar.hit.p) * CFrame.fromEulerAnglesXYZ(math.rad(-90),0,0)
			bv.velocity = CFrame.new(torso.Position,mar.hit.p).lookVector * speed
		end)
		upconnect = mar.Button1Up:connect(function()
			a = 0
			moveconnect:disconnect()
			upconnect:disconnect()
			bv.velocity = Vector3.new(0,0,0)
			bv.maxForce = Vector3.new(0,math.huge,0)
			torso.Velocity = Vector3.new(0,0,0)
			bg.cframe = CFrame.new(torso.Position,torso.Position + Vector3.new(torso.CFrame.lookVector.x,0,torso.CFrame.lookVector.z))
			wait(1)
		end)
	end)
	while s == 1 do
		wait(0.02)
		flow = checktable(flow, true)
		local i
		for i = 1,#flow do
			flow[i].Transparency = flow[i].Transparency + rs
			if flow[i].Transparency >= 1 then flow[i]:remove() end
		end
		if a == 1 then
			flow[#flow + 1] = Instance.new("Part")
			local p = flow[#flow]
			p.formFactor = form
			p.Size = siz
			p.Anchored = true
			p.CanCollide = false
			p.TopSurface = 0
			p.BottomSurface = 0
			if #flow - 1 > 0 then
				local pr = flow[#flow - 1]
				p.Position = torso.Position - torso.Velocity/ndist
				CFC(p, pr)
			else
				p.CFrame = CFrame.new(torso.Position - torso.Velocity/ndist, torso.CFrame.lookVector)
			end
			p.BrickColor = BrickColor.new("Cyan")
			p.Transparency = 1
			p.Parent = torso
			local marm = Instance.new("BlockMesh")
			marm.Scale = Vector3.new(1.9, 0.9, 1.725)
			marm.Parent = p
			local amplitude
			local frequency
			amplitude = pi
			desiredAngle = amplitude
			RightShoulder.MaxVelocity = 0.4
			LeftShoulder.MaxVelocity = 0.4
			RightHip.MaxVelocity = pi/10
			LeftHip.MaxVelocity = pi/10
			RightShoulder.DesiredAngle = desiredAngle
			LeftShoulder.DesiredAngle = -desiredAngle
			RightHip.DesiredAngle = 0
			LeftHip.DesiredAngle = 0
		end
	end
end)
script.Parent.Deselected:connect(function()
a = 0
s = 0
bv:remove()
bg:remove()
if connection ~= nil then
connection:disconnect()
end
if moveconnect ~= nil then
moveconnect:disconnect()
end
if upconnect ~= nil then
upconnect:disconnect()
end
while s == 0 do
	wait()
	if #flow > 0 then
		flow = checktable(flow, true)
		local i
		for i = 1,#flow do
			flow[i].Transparency = flow[i].Transparency + rs
			if flow[i].Transparency >= 1 then flow[i]:remove() end
		end
	end
end
end)
while true do
	wait()
	if s == 1 then
		return
	end
end
script:remove()
]]
	elseif v.Name == "JumperJumpScript" then
		source = [[while true do
wait(0)
script.Parent:FindFirstChildOfClass("Humanoid").Jump = true
end
]]
	elseif v.Name == "JumperMoveScript" then
		source = [[--[[ By: Joe_1447. --
		local AdamScript=script;
		repeat Wait(0)until script and script.Parent and script.Parent:IsA("Model")and script.Parent:FindFirstChild("Head")and script.Parent:FindFirstChild("Torso");
		local Adam=AdamScript.Parent;
		local AdamHumanoid;
		for _,Child in pairs(Adam:GetChildren())do
			if Child and Child:IsA("Humanoid")and Child.Health>0.001 then
				AdamHumanoid=Child;
			end;
		end;
		local HasGear=false;
		function raycast(Spos,vec,currentdist)
			local Hit2,pos2=game.Workspace:FindPartOnRay(Ray.new(Spos+(vec*.05),vec*currentdist),Adam);
			if Hit2~=nil and pos2 then
				if Hit2.Name=="Handle"and not Hit2.CanCollide or string.sub(Hit2.Name,1,6)=="Effect"and not Hit2.CanCollide then
					local currentdist=currentdist-(pos2-Spos).magnitude;
					return raycast(pos2,vec,currentdist);
				end;
			end;
			return Hit2,pos2;
		end;
		for _,Child in pairs(Adam:GetChildren())do
			if Child and Child:IsA("Tool")then
			end;
		end;
		function RayCast(Position,Direction,MaxDistance,IgnoreList)
			return Game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(Position,Direction.unit*(MaxDistance or 999.999)),IgnoreList);
		end;
		local AttackDebounce=false;
		while Wait(0)do
			if AdamScript and Adam and Adam:FindFirstChild("Head")and AdamHumanoid and AdamHumanoid.Health==0 then
				break
			end;
			if AdamScript and Adam and Adam:FindFirstChild("Torso")and AdamHumanoid and AdamHumanoid.Health>0.001 then
				local TargetPoint=AdamHumanoid.TargetPoint;
				local Blockage,BlockagePos=RayCast((Adam:FindFirstChild("Torso").CFrame+CFrame.new(Adam:FindFirstChild("Torso").Position,Vector3.new(TargetPoint.X,Adam:FindFirstChild("Torso").Position.Y,TargetPoint.Z)).lookVector*(Adam:FindFirstChild("Torso").Size.Z/2)).p,Adam:FindFirstChild("Torso").CFrame.lookVector,(Adam:FindFirstChild("Torso").Size.Z*2.5),{Adam,Adam})
				if Blockage then
					if Blockage and Blockage.Parent and Blockage.Parent.ClassName~="Workspace"then
						local BlockageHumanoid;
						for _,Child in pairs(Blockage.Parent:GetChildren())do
							if Child and Child:IsA("Humanoid")and Child.Health>0.001 then
								BlockageHumanoid=Child;
							end;
						end;
						if Blockage and Blockage:IsA("Terrain")then
							local CellPos=Blockage:WorldToCellPreferSolid((BlockagePos-Vector3.new(0,2,0)));
							local CellMaterial,CellShape,CellOrientation=Blockage:GetCell(CellPos.X,CellPos.Y,CellPos.Z);
							if CellMaterial==Enum.CellMaterial.Water then
							end
						elseif BlockageHumanoid or Blockage.ClassName=="TrussPart"or Blockage.ClassName=="WedgePart"or Blockage.Name=="Handle"and Blockage.Parent:IsA("Hat")or Blockage.Name=="Handle"and Blockage.Parent:IsA("Tool")then
						end;
					end;
					if AdamScript and Adam and AdamHumanoid and AdamHumanoid.Health>0.001 and not AdamHumanoid.Sit and Jumpable then
					end;
				end;
				if AdamScript and Adam and AdamHumanoid and AdamHumanoid.Health>0.001 and not AdamHumanoid.AutoJumpEnabled then
				end;
				if AdamScript and Adam and AdamHumanoid and AdamHumanoid.Health>0.001 and not AdamHumanoid.AutoRotate then
				end;
				if AdamScript and Adam and AdamHumanoid and AdamHumanoid.Health>0.001 and AdamHumanoid.PlatformStand then
				end;
				if AdamScript and Adam and AdamHumanoid and AdamHumanoid.Health>0.001 and AdamHumanoid.Sit then
				end;
				if AdamScript and Adam and AdamHumanoid and AdamHumanoid.Health>0.001 then
				end;
				local NoticeDistance=0;
				for _,TargetModel in pairs(Game:GetService("Workspace"):GetChildren())do
					if TargetModel and TargetModel:IsA("Model")and TargetModel~=Adam and TargetModel.Name~=Adam.Name and TargetModel:FindFirstChild("Head")and TargetModel:FindFirstChild("Torso")and not HasGear then
						local TargetPart=TargetModel:FindFirstChild("Torso");
						local FoundHumanoid;
						local FoundGear;
						for _,Child in pairs(TargetModel:GetChildren())do
							if Child and Child:IsA("Humanoid")and Child.Health>0.001 then
								FoundHumanoid=Child;
							end;
						end;
						for _,Child in pairs(TargetModel:GetChildren())do
							if Child and Child:IsA("Tool")then
								FoundGear=Child
							end;
						end;
						if AdamScript and Adam and Adam:FindFirstChild("HumanoidRootPart")and AdamHumanoid and AdamHumanoid.Health>0.001 and TargetPart and FoundHumanoid and FoundHumanoid.Health>0.001 and TargetModel and TargetPart and(TargetPart.Position-Adam:FindFirstChild("HumanoidRootPart").Position).magnitude<NoticeDistance and FoundGear then
							NoticeDistance=(TargetPart.Position-Adam:FindFirstChild("HumanoidRootPart").Position).magnitude;
							if AdamScript and Adam and Adam:FindFirstChild("HumanoidRootPart")and AdamHumanoid and AdamHumanoid.Health>0.001 and TargetPart and FoundHumanoid and FoundHumanoid.Health>0.001 and FoundHumanoid.Jump then
							end;
							if AdamScript and Adam and Adam:FindFirstChild("HumanoidRootPart")and AdamHumanoid and AdamHumanoid.Health>0.001 and TargetPart and FoundHumanoid and FoundHumanoid.Health>0.001 and TargetModel and TargetPart and(TargetPart.Position-Adam:FindFirstChild("HumanoidRootPart").Position).magnitude<5 and FoundGear and not AttackDebounce then
								local Hit,pos=raycast(Adam:FindFirstChild("Torso").Position,(TargetPart.Position-Adam:FindFirstChild("Torso").Position).unit,500)
								if Hit and Hit.Parent and Hit.Parent:IsA("Model")and Hit.Parent:FindFirstChild("Torso")and Hit.Parent:FindFirstChild("Head")then
									Delay(0.5+math.random()*1,function()
										AttackDebounce=false;
									end);
									AttackDebounce=true;
									local SwingAnimation=AdamHumanoid:LoadAnimation(Adam:FindFirstChild("SwingAnimation"));
									SwingAnimation:Play();
									SwingAnimation:AdjustSpeed(1);
									Spawn(function()
										Wait(0.4);
										if AdamScript and Adam and Adam:FindFirstChild("HumanoidRootPart")and AdamHumanoid and AdamHumanoid.Health>0.001 and TargetPart and FoundHumanoid and FoundHumanoid.Health>0.001 then
											if AdamScript and Adam and Adam:FindFirstChild("HumanoidRootPart")and AdamHumanoid and AdamHumanoid.Health>0.001 and TargetPart and FoundHumanoid and FoundHumanoid.Health>0.001 and TargetModel and TargetPart and(TargetPart.Position-Adam:FindFirstChild("HumanoidRootPart").Position).magnitude<5 and FoundGear and FoundGear.Parent.ClassName~="Backpack"then
												if AdamScript and Adam and Adam:FindFirstChild("Right Arm")and Adam:FindFirstChild("Right Arm"):FindFirstChild("AdamSlap")then
													Adam:FindFirstChild("Right Arm"):FindFirstChild("AdamSlap"):Play();
												end;
											else
											end;
										end;
									end);
								end;
							end;
							AdamHumanoid:MoveTo(TargetPart.Position);
						end;
					else
						if AdamScript and Adam and AdamHumanoid and AdamHumanoid.Health>0.001 and HasGear then
							local GearReleaseChance=math.random(1,5000);
							local Tools=0;
							for _,Child in pairs(Adam:GetChildren())do
								if Child and Child:IsA("Tool")then
								end;
							end;
							if AdamScript and Adam and AdamHumanoid and AdamHumanoid.Health>0.001 and Tools==0 or AdamScript and Adam and AdamHumanoid and AdamHumanoid.Health>0.001 and Tools<0 then
							end;
							if GearReleaseChance==1 then
								Wait(0);
								for _,Child in pairs(Adam:GetChildren())do
									if Child and Child:IsA("Tool")then
									end;
								end;
							end;
						end;
						local RandomWalk=math.random(1,300);
						local RandomJump=math.random(1,700);
						if RandomWalk==1 then
							AdamHumanoid:MoveTo(Game:GetService("Workspace"):FindFirstChild("Terrain").Position+Vector3.new(math.random(-2048,2048),0,math.random(-2048,2048)),Game:GetService("Workspace"):FindFirstChild("Terrain"));
						end;
						if RandomJump==0 then
						end;
					end;
				end;
			end;
		end;
		--[[ By: Joe_1447.]]
	elseif v.Name == "JumperRespawnScript" then
		source = [[--[[ By: Joe_1447. --
		local AdvancedRespawnScript=script;
		repeat Wait(0)until script and script.Parent and script.Parent.ClassName=="Model";
		local Adam=AdvancedRespawnScript.Parent;
		local GameDerbis=Game:GetService("Debris");
		local AdamHumanoid;
		for _,Child in pairs(Adam:GetChildren())do
			if Child and Child.ClassName=="Humanoid"and Child.Health>0.001 then
				AdamHumanoid=Child;
			end;
		end;
		local Respawndant=Adam:Clone();
		coroutine.resume(coroutine.create(function()
			if Adam and AdamHumanoid and AdamHumanoid:FindFirstChild("Status")and not AdamHumanoid:FindFirstChild("Status"):FindFirstChild("AvalibleSpawns")then
				SpawnModel=Instance.new("Model");
				SpawnModel.Parent=AdamHumanoid.Status;
				SpawnModel.Name="AvalibleSpawns";
			else
				SpawnModel=AdamHumanoid:FindFirstChild("Status"):FindFirstChild("AvalibleSpawns");
			end;
			function FindSpawn(SearchValue)
				local PartsArchivable=SearchValue:GetChildren();
				for AreaSearch=1,#PartsArchivable do
					if PartsArchivable[AreaSearch].className=="SpawnLocation"then
						local PositionValue=Instance.new("Vector3Value",SpawnModel);
						PositionValue.Value=PartsArchivable[AreaSearch].Position;
						PositionValue.Name=PartsArchivable[AreaSearch].Duration;
					end;
					FindSpawn(PartsArchivable[AreaSearch]);
				end;
			end;
			FindSpawn(Game.Workspace);
			local SpawnChilden=SpawnModel:GetChildren();
			if#SpawnChilden>0 then
				local SpawnItself=SpawnChilden[math.random(1,#SpawnChilden)];
				local RespawningForceField=Instance.new("ForceField");
				RespawningForceField.Parent=Adam;
				RespawningForceField.Name="SpawnForceField";
				GameDerbis:AddItem(RespawningForceField,SpawnItself.Name);
				Adam:MoveTo(SpawnItself.Value+Vector3.new(0,3.5,0));
			else
				if Adam:FindFirstChild("SpawnForceField")then
					Adam:FindFirstChild("SpawnForceField"):Destroy();
				end;
				Adam:MoveTo(Vector3.new(0,115,0));
			end;
		end));
		function Respawn()
			Wait(5);
			Respawndant.Parent=Adam.Parent;
			Respawndant:makeJoints();
			Respawndant:FindFirstChild("Head"):MakeJoints();
			Respawndant:FindFirstChild("Torso"):MakeJoints();
			Adam:remove();
		end;
		AdamHumanoid.Died:connect(Respawn);
		--[[ By: Joe_1447 ]]
	elseif v.Name == "Sound" and v.Parent:FindFirstChild("JumperAnimateScript") then
		source = [[-- util

function waitForChild(parent, childName)
	local child = parent:findFirstChild(childName)
	if child then return child end
	while true do
		child = parent.ChildAdded:wait()
		if child.Name==childName then return child end
	end
end

function newSound(id)
	local sound = Instance.new("Sound")
	sound.SoundId = id
	sound.archivable = false
	sound.Parent = script.Parent.Head
	return sound
end

-- declarations

local sDied = newSound("rbxasset://sounds/uuhhh.wav")
sDied.Pitch = 0.75
local sFallingDown = newSound("rbxasset://sounds/splat.wav")
local sFreeFalling = newSound("rbxasset://sounds/swoosh.wav")
local sGettingUp = newSound("rbxasset://sounds/hit.wav")
local sJumping = newSound("rbxasset://sounds/button.wav")
local sRunning = newSound("rbxasset://sounds/bfsl-minifigfoots1.mp3")
sRunning.Looped = true

local Figure = script.Parent
local Head = waitForChild(Figure, "Head")
local Humanoid = waitForChild(Figure, "Humanoid")

-- functions

function onDied()
	sDied:Play()
	wait(2.5)
	script.Parent:Destroy()
end

function onState(state, sound)
	if state then
		sound:Play()
	else
		sound:Pause()
	end
end

function onRunning(speed)
	if speed>0 then
		sRunning:Play()
	else
		sRunning:Pause()
	end
end

-- connect up

Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(function(state) onState(state, sJumping) end)
Humanoid.GettingUp:connect(function(state) onState(state, sGettingUp) end)
Humanoid.FreeFalling:connect(function(state) onState(state, sFreeFalling) end)
Humanoid.FallingDown:connect(function(state) onState(state, sFallingDown) end)
]]
	elseif v.Name == "ZombieScript" then
		source = [[--Made by Stickmasterluke

--Zombie artificial stupidity script


sp=script.Parent
lastattack=0
nextrandom=0
nextsound=0
nextjump=0
chasing=false

variance=4

damage=50
attackrange=4.5
sightrange=999--60
runspeed=40
wonderspeed=8
healthregen=false
colors={"Sand red","Dusty Rose","Medium blue","Sand blue","Lavender","Earth green","Brown","Medium stone grey","Brick yellow"}

function raycast(spos,vec,currentdist)
	local hit2,pos2=game.Workspace:FindPartOnRay(Ray.new(spos+(vec*.01),vec*currentdist),script.Parent)
	if hit2~=nil and pos2 then
		if hit2.Parent==script.Parent and hit2.Transparency>=.8 or hit2.Name=="Handle" or string.sub(hit2.Name,1,6)=="Effect" or hit2.Parent:IsA("Hat") or hit2.Parent:IsA("Tool") or (hit2.Parent:FindFirstChild("Humanoid") and hit2.Parent:FindFirstChild("TEAM") and hit2.Parent:FindFirstChild("TEAM").Value == script.Parent.TEAM.Value) or (not hit2.Parent:FindFirstChild("Humanoid") and hit2.CanCollide==false) then
			local currentdist=currentdist-(pos2-spos).magnitude
			return raycast(pos2,vec,currentdist)
		end
	end
	return hit2,pos2
end

function waitForChild(parent,childName)
	local child=parent:findFirstChild(childName)
	if child then return child end
	while true do
		child=parent.ChildAdded:wait()
		if child.Name==childName then return child end
	end
end

-- ANIMATION

-- declarations

local Torso=waitForChild(sp,"Torso")
local Head=waitForChild(sp,"Head")
local RightShoulder=waitForChild(Torso,"Right Shoulder")
local LeftShoulder=waitForChild(Torso,"Left Shoulder")
local RightHip=waitForChild(Torso,"Right Hip")
local LeftHip=waitForChild(Torso,"Left Hip")
local Neck=waitForChild(Torso,"Tail")
local Humanoid=waitForChild(sp,"Humanoid")
local BodyColors=waitForChild(sp,"Body Colors")
local pose="Standing"
local hitsound=waitForChild(Head,"Bite Bark")
local BARKING=waitForChild(Head,"Seal Barking")


--[[local sounds={
	waitForChild(Torso,"GroanSound"),
	waitForChild(Torso,"RawrSound")
}]

		if healthregen then
			local regenscript=waitForChild(sp,"HealthRegenerationScript")
			regenscript.Disabled=false
		end
		Humanoid.WalkSpeed=wonderspeed

		local toolAnim="None"
		local toolAnimTime=0

--[[BodyColors.HeadColor=BrickColor.new("Grime")
local randomcolor1=colors[math.random(1,#colors)]
BodyColors.TorsoColor=BrickColor.new(randomcolor1)
BodyColors.LeftArmColor=BrickColor.new(randomcolor1)
BodyColors.RightArmColor=BrickColor.new(randomcolor1)
local randomcolor2=colors[math.random(1,#colors)]
BodyColors.LeftLegColor=BrickColor.new(randomcolor2)
BodyColors.RightLegColor=BrickColor.new(randomcolor2)]


		function onRunning(speed)
			if speed>0 then
				pose="Running"
			else
				pose="Standing"
			end
		end
		function onDied()
			pose="Dead"
		end
		function onJumping()
			pose="Jumping"
		end
		function onClimbing()
			pose="Climbing"
		end
		function onGettingUp()
			pose = "GettingUp"
		end
		function onFreeFall()
			pose = "FreeFall"
		end
		function onFallingDown()
			pose = "FallingDown"
		end
		function onSeated()
			pose = "Seated"
		end
		function onPlatformStanding()
			pose = "PlatformStanding"
		end

		function moveJump()
			RightShoulder.MaxVelocity = 0.5
			LeftShoulder.MaxVelocity = 0.5
			RightShoulder.DesiredAngle=3.14
			LeftShoulder.DesiredAngle=-3.14
			RightHip.DesiredAngle=0
			LeftHip.DesiredAngle=0
		end

		function moveFreeFall()
			RightShoulder.MaxVelocity = 0.5
			LeftShoulder.MaxVelocity =0.5
			RightShoulder.DesiredAngle=3.14
			LeftShoulder.DesiredAngle=-3.14
			RightHip.DesiredAngle=0
			LeftHip.DesiredAngle=0
		end

		function moveSit()
			RightShoulder.MaxVelocity = 0.15
			LeftShoulder.MaxVelocity = 0.15
			RightShoulder.DesiredAngle=3.14 /2
			LeftShoulder.DesiredAngle=-3.14 /2
			RightHip.DesiredAngle=3.14 /2
			LeftHip.DesiredAngle=-3.14 /2
		end

		function animate(time)
			local amplitude
			local frequency
			if (pose == "Jumping") then
				moveJump()
				return
			end
			if (pose == "FreeFall") then
				moveFreeFall()
				return
			end
			if (pose == "Seated") then
				moveSit()
				return
			end
			local climbFudge = 0
			if (pose == "Running") then
				RightShoulder.MaxVelocity = 0.15
				LeftShoulder.MaxVelocity = 0.15
				amplitude = 1
				frequency = 9
			elseif (pose == "Climbing") then
				RightShoulder.MaxVelocity = 0.5 
				LeftShoulder.MaxVelocity = 0.5
				amplitude = 1
				frequency = 9
				climbFudge = 3.14
			else
				amplitude = 0.1
				frequency = 1
			end
			desiredAngle = amplitude * math.sin(time*frequency)
			if not chasing and frequency==9 then
				frequency=4
			end
			if chasing then
		--[[RightShoulder.DesiredAngle=math.pi/2
		LeftShoulder.DesiredAngle=-math.pi/2
		RightHip.DesiredAngle=-desiredAngle*2
		LeftHip.DesiredAngle=-desiredAngle*2]
			else
				RightShoulder.DesiredAngle=desiredAngle + climbFudge
				LeftShoulder.DesiredAngle=desiredAngle - climbFudge
				RightHip.DesiredAngle=-desiredAngle
				LeftHip.DesiredAngle=-desiredAngle
			end
		end


		function attack(time,attackpos)
			if time-lastattack>=0.25 then
				local hit,pos=raycast(Torso.Position,(attackpos-Torso.Position).unit,attackrange)
				if hit and hit.Parent~=nil then
					local h=hit.Parent:FindFirstChild("Humanoid")
					local TEAM=hit.Parent:FindFirstChild("TEAM")
					if h and TEAM and TEAM.Value~=sp.TEAM.Value then
						local creator=sp:FindFirstChild("creator")
						if creator then
							if creator.Value~=nil then
								if creator.Value~=game.Players:GetPlayerFromCharacter(h.Parent) then
									for i,oldtag in ipairs(h:GetChildren()) do
										if oldtag.Name=="creator" then
											oldtag:remove()
										end
									end
									creator:clone().Parent=h
								else
									return
								end
							end
						end
						hitsound.Volume=1
						hitsound.Pitch=.75+(math.random()*.5)
						hitsound:Play()
						wait(0.15)
						h:TakeDamage(damage)
				--[[if RightShoulder and LeftShoulder then
					RightShoulder.CurrentAngle=0
					LeftShoulder.CurrentAngle=0
				end]
					end
				end
				lastattack=time
			end
		end


		Humanoid.Died:connect(onDied)
		Humanoid.Running:connect(onRunning)
		Humanoid.Jumping:connect(onJumping)
		Humanoid.Climbing:connect(onClimbing)
		Humanoid.GettingUp:connect(onGettingUp)
		Humanoid.FreeFalling:connect(onFreeFall)
		Humanoid.FallingDown:connect(onFallingDown)
		Humanoid.Seated:connect(onSeated)
		Humanoid.PlatformStanding:connect(onPlatformStanding)


		function populatehumanoids(mdl)
			if mdl.ClassName=="Humanoid" then
				if mdl.Parent:FindFirstChild("TEAM") and mdl.Parent:FindFirstChild("TEAM").Value~=sp.TEAM.Value then
					table.insert(humanoids,mdl)
				end
			end
			for i2,mdl2 in ipairs(mdl:GetChildren()) do
				populatehumanoids(mdl2)
			end
		end

--[[function playsound(time)
	nextsound=time+5+(math.random()*5)
	local randomsound=sounds[math.random(1,#sounds)]
	randomsound.Volume=.5+(.5*math.random())
	randomsound.Pitch=.5+(.5*math.random())
	randomsound:Play()
end]

		while sp.Parent~=nil and Humanoid and Humanoid.Parent~=nil and Humanoid.Health>0 and Torso and Head and Torso~=nil and Torso.Parent~=nil do
			local _,time=wait(0.25)--wait(1/3)
			humanoids={}
			populatehumanoids(game.Workspace)
			closesttarget=nil
			closestdist=sightrange
			local creator=sp:FindFirstChild("creator")
			for i,h in ipairs(humanoids) do
				if h and h.Parent~=nil then
					if h.Health>0 and h.Parent~=sp then
						local plr=game.Players:GetPlayerFromCharacter(h.Parent)
						if creator==nil or plr==nil or creator.Value~=plr then
							local t=h.Parent:FindFirstChild("Torso")
							if t~=nil then
								local dist=(t.Position-Torso.Position).magnitude
								if dist<closestdist then
									closestdist=dist
									closesttarget=t
								end
							end
						end
					end
				end
			end
			if closesttarget~=nil then
				if not chasing then
					--playsound(time)
					chasing=true
					Humanoid.WalkSpeed=runspeed
					BARKING:Play()
				end
				Humanoid:MoveTo(closesttarget.Position+(Vector3.new(1,1,1)*(variance*((math.random()*2)-1))),closesttarget)
				if math.random()<.5 then
					attack(time,closesttarget.Position)
				end
			else
				if chasing then
					chasing=false
					Humanoid.WalkSpeed=wonderspeed
					BARKING:Stop()
				end
				if time>nextrandom then
					nextrandom=time+3+(math.random()*5)
					local randompos=Torso.Position+((Vector3.new(1,1,1)*math.random()-Vector3.new(.5,.5,.5))*40)
					Humanoid:MoveTo(randompos,game.Workspace.Terrain)
				end
			end
			if time>nextsound then
				--playsound(time)
			end
			if time>nextjump then
				nextjump=time+7+(math.random()*5)
				Humanoid.Jump=true
			end
			animate(time)
		end

		wait(4)
		sp:remove() --Rest In Pizza
		]]
	elseif v.Name == "Script" and v.Parent.Name == "Trampoline" then
		source = [[local defaultJumpPower = game:GetService("StarterPlayer").CharacterJumpPower

script.Parent.Touched:connect(function(obj)
	local humanoid = obj.Parent:FindFirstChildWhichIsA("Humanoid")
	if humanoid then
	    humanoid.JumpPower = script.Parent.Parent.Configurations.JumpForce.Value
	    humanoid.Jump = true
	    wait(1)
	    humanoid.JumpPower = defaultJumpPower
	end
end)]]
	elseif v.Name == "WalkSpeed Changer" then
		source = [[debounce = true

function onTouched(hit)
	local h = hit.Parent:findFirstChild("Humanoid")
	if (h ~= nil and debounce == true) then
		debounce = false
		h.WalkSpeed = 1
		wait(1)
		debounce = true
	end
end

script.Parent.Touched:connect(onTouched)]]
	elseif v.Name == "Script" and v.Parent.Name == "SuperJump V2.0" then
		source = [[local e = Instance.new("BodyPosition")

local flying = false

function onButton1Down(mouse)
flying = true
	while flying do
	e.Parent = script.Parent.Parent.Parent.Character.Torso
	e.position = Vector3.new(0,script.Parent.Parent.Parent.Character.Torso.Position.Y + 2.00000004,0)
	e.maxForce = Vector3.new(0,9000,0)
	wait(0.00000000000000000000000000000000000000000001)
	end
end

function onButton1Up(mouse)
flying = false
e:Remove()
end

function onSelected(mouse)
	mouse.Icon = "rbxasset://textures\\GunCursor.png"
	mouse.Button1Up:connect(function() onButton1Up(mouse) end)
	mouse.Button1Down:connect(function() onButton1Down(mouse) end)
end

script.Parent.Selected:connect(onSelected)]]
	elseif v.Name == "Script" and v.Parent.Parent:FindFirstChild("Blueseel Bathelm") and v.Parent.Name == "Brick" then
		source = [[bin = script.Parent

function onTouched(part)
	part.BrickColor = BrickColor.new(23)
	wait(0.01)
	part.Transparency.Reflectance = 0.1
	wait(0.1)
	part.Transparency.Reflectance  = 0.2
	wait(0.1)
	part.Transparency.Reflectance  = 0.3
	wait(0.1)
	part.Transparency.Reflectance  = 0.4
	wait(0.1)
	part.Transparency.Reflectance  = 0.5
	wait(0.1)
	part.Transparency.Reflectance  = 0.6
	wait(0.1)
	part.Transparency.Reflectance  = 0.7
	wait(0.1)
	part.Transparency.Reflectance  = 0.8
	wait(0.1)
        part.Transparency.Reflectance  = 0.9
	wait(0.1)
	part.Parent = nil
end

connection = bin.Touched:connect(onTouched)]]
	elseif v.Name == "CarScript" and v:FindFirstChild("LocalCarScript") then
		source = [[--Scripted by DermonDarble

local car = script.Parent
local stats = car.Configurations
local Raycast = require(script.RaycastModule)

local mass = 0

for i, v in pairs(car:GetChildren()) do
	if v:IsA("BasePart") then
		mass = mass + (v:GetMass() * 196.2)
	end
end

local bodyPosition = car.Chassis.BodyPosition
local bodyGyro = car.Chassis.BodyGyro

--local bodyPosition = Instance.new("BodyPosition", car.Chassis)
--bodyPosition.MaxForce = Vector3.new()
--local bodyGyro = Instance.new("BodyGyro", car.Chassis)
--bodyGyro.MaxTorque = Vector3.new()

local function UpdateThruster(thruster)
	-- Raycasting
	local hit, position = Raycast.new(thruster.Position, thruster.CFrame:vectorToWorldSpace(Vector3.new(0, -1, 0)) * stats.Height.Value) --game.Workspace:FindPartOnRay(ray, car)
	local thrusterHeight = (position - thruster.Position).magnitude
	
	-- Wheel
	local wheelWeld = thruster:FindFirstChild("WheelWeld")
	wheelWeld.C0 = CFrame.new(0, -math.min(thrusterHeight, stats.Height.Value * 0.8) + (wheelWeld.Part1.Size.Y / 2), 0)
	-- Wheel turning
	local offset = car.Chassis.CFrame:inverse() * thruster.CFrame
	local speed = car.Chassis.CFrame:vectorToObjectSpace(car.Chassis.Velocity)
	if offset.Z < 0 then
		local direction = 1
		if speed.Z > 0 then
			direction = -1
		end
		wheelWeld.C0 = wheelWeld.C0 * CFrame.Angles(0, (car.Chassis.RotVelocity.Y / 2) * direction, 0)
	end
	
	-- Particles
	if hit and thruster.Velocity.magnitude >= 5 then
		wheelWeld.Part1.ParticleEmitter.Enabled = true
	else
		wheelWeld.Part1.ParticleEmitter.Enabled = false
	end
end

car.DriveSeat.Changed:connect(function(property)
	if property == "Occupant" then
		if car.DriveSeat.Occupant then
			car.EngineBlock.Running.Pitch = 1
			car.EngineBlock.Running:Play()
			local player = game.Players:GetPlayerFromCharacter(car.DriveSeat.Occupant.Parent)
			if player then
				car.DriveSeat:SetNetworkOwner(player)
				local localCarScript = script.LocalCarScript:Clone()
				localCarScript.Parent = player.PlayerGui
				localCarScript.Car.Value = car
				localCarScript.Disabled = false
			end
		else
			car.EngineBlock.Running:Stop()
		end
	end
end)

--spawn(function()
	while true do
		game:GetService("RunService").Stepped:wait()
		for i, part in pairs(car:GetChildren()) do
			if part.Name == "Thruster" then
				UpdateThruster(part)
			end
		end
		if car.DriveSeat.Occupant then
			local ratio = car.DriveSeat.Velocity.magnitude / stats.Speed.Value
			car.EngineBlock.Running.Pitch = 1 + ratio / 4
			bodyPosition.MaxForce = Vector3.new()
			bodyGyro.MaxTorque = Vector3.new()
		else
			local hit, position, normal = Raycast.new(car.Chassis.Position, car.Chassis.CFrame:vectorToWorldSpace(Vector3.new(0, -1, 0)) * stats.Height.Value)
			if hit and hit.CanCollide then
				bodyPosition.MaxForce = Vector3.new(mass / 5, math.huge, mass / 5)
				bodyPosition.Position = (CFrame.new(position, position + normal) * CFrame.new(0, 0, -stats.Height.Value + 0.5)).p
				bodyGyro.MaxTorque = Vector3.new(math.huge, 0, math.huge)
				bodyGyro.CFrame = CFrame.new(position, position + normal) * CFrame.Angles(-math.pi/2, 0, 0)
			else
				bodyPosition.MaxForce = Vector3.new()
				bodyGyro.MaxTorque = Vector3.new()
			end
		end
	end
--end)]]
	elseif v.Name == "PUT THIS IN THE WEAPON" then
		source = [[local debounce = false

function getPlayer(humanoid) 
local players = game.Players:children() 
for i = 1, #players do 
if players[i].Character.Humanoid == humanoid then return players[i] end 
end 
return nil 
end 

function onTouch(part) 

local human = part.Parent:findFirstChild("Humanoid") 
if (human ~= nil) and debounce == false then

debounce = true

local player = getPlayer(human) 

if (player == nil) then return end 

script.Parent:clone().Parent = player.Backpack

wait(2)
debounce = false
end
end


script.Parent.Parent.Touched:connect(onTouch) 
]]
	elseif v.Name == "BloxyColaScript" then
		source = [[local Tool = script.Parent;

enabled = true


function onActivated()
	if not enabled  then
		return
	end

	enabled = false
	Player.Torso["Right Shoulder"].C0 = CFrame.new(0.9,0.5,-0.05) * CFrame.Angles(0.2,2,0)
	wait(0.05)
	Player.Torso["Right Shoulder"].C0 = CFrame.new(0.8,0.5,-0.1) * CFrame.Angles(0.4,2.4,0)

	Tool.Handle.DrinkSound:Play()

	for i = 1,30 do
	wait(0.1)
	Player.Humanoid.Health = Player.Humanoid.Health + 1
	end
	Player.Torso["Right Shoulder"].C0 = CFrame.new(0.9,0.5,-0.05) * CFrame.Angles(0.2,2,0)
	wait(0.05)
	Player.Torso["Right Shoulder"].C0 = CFrame.new(1,0.5,-0) * CFrame.Angles(0,1.57,0)
	wait(0.5)
	enabled = true
end

function onEquipped()
	Player = script.Parent.Parent
	Tool.Handle.OpenSound:play()
end

function onEnequipped()
	Player.Torso["Right Shoulder"].C0 = CFrame.new(1,0.5,-0) * CFrame.Angles(0,1.57,0)
end

script.Parent.Activated:connect(onActivated)
script.Parent.Equipped:connect(onEquipped)
script.Parent.Unequipped:connect(onEnequipped)
]]
	elseif v.Name == "Force Script" then
		source = [[--SoundStudioRoblox--

while true do
script.Parent.Velocity = script.Parent.CFrame.lookVector *60
wait(0.1)
end
]]
	elseif v.Name == "ClassicBuildTools" then
		source = [[-------------------------------------------------------------------------------------------------------------------------
-- @CloneTrooper1019, 2017-2018 <3
-- ClassicBuildTools.lua
-- A FilteringEnabled port of Roblox's classic build tools.
-------------------------------------------------------------------------------------------------------------------------
-- Initial Declarations
-------------------------------------------------------------------------------------------------------------------------

local CollectionService = game:GetService("CollectionService")
local Debris = game:GetService("Debris")
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local PhysicsService = game:GetService("PhysicsService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local DraggerService = Instance.new("Folder")
DraggerService.Name = "DraggerService"
DraggerService.Parent = ReplicatedStorage

local DraggerGateway = Instance.new("RemoteFunction")
DraggerGateway.Name = "DraggerGateway"
DraggerGateway.Parent = DraggerService

local SubmitUpdate = Instance.new("RemoteEvent")
SubmitUpdate.Name = "SubmitUpdate"
SubmitUpdate.Parent = DraggerService

local DECLARED_BUILD_TOOLS = {
	_KGameTool = true,
	_KClone = true,
	_KHammer = true,
}

-------------------------------------------------------------------------------------------------------------------------
-- Server Gateway Logic
-------------------------------------------------------------------------------------------------------------------------
--[[

~ HOW THIS WORKS ~

	* In order to drag a part, a player must request permission from the server to drag the part.
	* If any of the following conditions are true, the request will be rejected:
		* The part is Locked.
		* The player is dragging another part, and hasn't released it.
		* The part is being dragged by another player.
		* The player does not have a character.
		* The player does not have the tool corresponding to the action equipped.
	* If the player is granted permission...
		* A key is generated representing the current drag action, and this key is passed back to the player.
		* This key marks both the part being dragged, and the player.
		* The player can submit the key and a CFrame to the SubmitUpdate event to move the part.
		* The player MUST release the key in order to drag another part, or their request is rejected.
		* Key is automatically released if the part is destroyed, or the player leaves the game.
--]

		local activeKeys = {}
		local deleteDebounce = {}

		local partToKey = {}
		local playerToKey = {}

		local function assertClass(obj, class)
			assert(obj)
			assert(typeof(obj) == "Instance")
			assert(obj:IsA(class))
		end

		local function canGiveKey(player, part)
			if part.Locked then
				return false
			end

			if playerToKey[player] then
				return false
			end

			if partToKey[part] then
				return false
			end

			return true
		end

		local function claimAssembly(player, part)
			if part:CanSetNetworkOwnership() then
				part:SetNetworkOwner(player)
			end
		end

		local function removePartKey(key)
			local data = activeKeys[key]

			if data then
				local player = data.Player
				local part = data.Part

				if player then
					playerToKey[player] = nil
				end

				if part then
					-- Connect this part to a nearby surface
					workspace:JoinToOutsiders({ part }, "Surface")

					part.Anchored = data.Anchored
					claimAssembly(player, part)

					partToKey[part] = nil
				end

				activeKeys[key] = nil
			end
		end

		local function playerIsUsingTool(player, toolName)
			local char = player.Character

			if char then
				local tool = char:FindFirstChildWhichIsA("Tool")
				if tool and CollectionService:HasTag(tool, toolName) then
					return true, tool
				end
			end

			return false
		end

		local function swingBuildTool(player)
			local char = player.Character
			if char then
				local tool = char:FindFirstChildWhichIsA("Tool")
				if tool and tool.RequiresHandle and CollectionService:HasTag(tool, "_KBuildTool") then
					local toolAnim = Instance.new("StringValue")
					toolAnim.Name = "toolanim"
					toolAnim.Value = "Slash"
					toolAnim.Parent = tool
				end
			end
		end

		function DraggerGateway.OnServerInvoke(player, request, ...)
			if request == "GetKey" then
				local part, asClone = ...
				assertClass(part, "BasePart")

				if asClone then
					if playerIsUsingTool(player, "_KClone") then
						local newPart = part:Clone()
						newPart:BreakJoints()
						newPart.Parent = workspace

						local copySound = Instance.new("Sound")
						copySound.SoundId = "rbxasset://sounds/electronicpingshort.wav"
						copySound.Parent = newPart
						copySound.Archivable = false
						copySound:Play()

						part = newPart
					else
						return false
					end
				elseif not playerIsUsingTool(player, "_KGameTool") then
					return false
				end

				if canGiveKey(player, part) then
					local char = player.Character
					if char then
						local key = HttpService:GenerateGUID(false)
						playerToKey[player] = key
						partToKey[part] = key

						claimAssembly(player, part)
						swingBuildTool(player)

						local anchored = part.Anchored
						part:BreakJoints()
						part.Anchored = true

						activeKeys[key] = {
							Player = player,
							Part = part,
							Anchored = anchored,
						}

						return true, key, part
					end
				end

				return false
			elseif request == "ClearKey" then
				local key = ...

				if not key then
					key = playerToKey[player]
				end

				if key then
					local data = activeKeys[key]
					if data then
						local owner = data.Player
						if player == owner then
							removePartKey(key)
						end
					end
				end
			elseif request == "RequestDelete" then
				if not deleteDebounce[player] and playerIsUsingTool(player, "_KHammer") then
					local part = ...
					assertClass(part, "BasePart")

					if canGiveKey(player, part) then
						local e = Instance.new("Explosion")
						e.BlastPressure = 0
						e.Position = part.Position
						e.Parent = workspace

						local s = Instance.new("Sound")
						s.PlayOnRemove = true
						s.SoundId = "rbxasset://sounds/collide.wav"
						s.Volume = 1
						s.Parent = part

						swingBuildTool(player)
						claimAssembly(player, part)

						part:Destroy()
					end

					wait(0.1)
					deleteDebounce[player] = false
				end
			end
		end

		local function onSubmitUpdate(player, key, cframe)
			local keyData = activeKeys[key]
			if keyData then
				local owner = keyData.Player
				if owner == player then
					local part = keyData.Part
					if part and part:IsDescendantOf(workspace) then
						part.CFrame = cframe
					end
				end
			end
		end

		SubmitUpdate.OnServerEvent:Connect(onSubmitUpdate)

		----------------------------------------------------------------------------------------------------------------------------
		-- Tool Initialization
		----------------------------------------------------------------------------------------------------------------------------

		local draggerScript = script:WaitForChild("DraggerScript")

		for toolName in pairs(DECLARED_BUILD_TOOLS) do
			local BuildToolAdded = CollectionService:GetInstanceAddedSignal(toolName)
			local BuildToolRemoved = CollectionService:GetInstanceRemovedSignal(toolName)

			local function onBuildToolAdded(tool)
				if tool:IsA("Tool") and not CollectionService:HasTag(tool, "_KBuildTool") then
					tool.Name = toolName
					tool.CanBeDropped = false

					local dragger = draggerScript:Clone()
					dragger.Parent = tool
					dragger.Disabled = false

					CollectionService:AddTag(tool, "_KBuildTool")
				end
			end

			local function onBuildToolRemoved(tool)
				if tool:IsA("Tool") and CollectionService:HasTag(tool, "_KBuildTool") then
					CollectionService:RemoveTag(tool, toolName)
					CollectionService:RemoveTag(tool, "_KBuildTool")

					local char = tool.Parent
					if char and char:IsA("Model") then
						local humanoid = char:FindFirstChildOfClass("Humanoid")
						if humanoid then
							humanoid:UnequipTools()
						end
					end

					if tool:FindFirstChild("DraggerScript") then
						tool.DraggerScript:Destroy()
					end
				end
			end

			for _, buildTool in pairs(CollectionService:GetTagged(toolName)) do
				onBuildToolAdded(buildTool)
			end

			BuildToolAdded:Connect(onBuildToolAdded)
			BuildToolRemoved:Connect(onBuildToolRemoved)
		end

		----------------------------------------------------------------------------------------------------------------------------
		-- Player/HopperBin tracking
		----------------------------------------------------------------------------------------------------------------------------

		local function onDescendantAdded(desc)
			if desc:IsA("HopperBin") then
				local toolName = desc.BinType.Name
				if DECLARED_BUILD_TOOLS[toolName] then
					local tool = Instance.new("Tool")
					tool.RequiresHandle = false
					tool.Parent = desc.Parent

					CollectionService:AddTag(tool, toolName)
					desc:Destroy()
				end
			end
		end

		local function onPlayerAdded(player)
			for _, desc in pairs(player:GetDescendants()) do
				onDescendantAdded(desc)
			end
			player.DescendantAdded:Connect(onDescendantAdded)
		end

		local function onPlayerRemoved(player)
			local key = playerToKey[player]
			if key then
				removePartKey(key)
			end
		end

		for _, player in pairs(Players:GetPlayers()) do
			onPlayerAdded(player)
		end

		Players.PlayerAdded:Connect(onPlayerAdded)
		Players.PlayerRemoving:Connect(onPlayerRemoved)

		----------------------------------------------------------------------------------------------------------------------------
		-- Garbage Collection
		----------------------------------------------------------------------------------------------------------------------------

		while wait(1) do
			for part, key in pairs(partToKey) do
				if not part:IsDescendantOf(workspace) then
					removePartKey(key)
				end
			end
		end

		----------------------------------------------------------------------------------------------------------------------------
		]]
	elseif v.Name == "Script" and v.Parent.Name == "Sword" and v.Parent:FindFirstChild("GLib") then
		source = [[--[[
	Rewritten by ArceusInator
	- Completely rewrote the sword
	- Added a Configurations folder so damage settings can be easily modified
	- The sword runs on the client in non-FE to reduce the impression of input delay
	- Fixed the floaty lunge issue
	
	This script will run the sword code on the server if filtering is enabled
--]
		local Tool = script.Parent
		local GLib = require(script.Parent:WaitForChild('GLib'))
		local GLibScript = GLib.Script
		GLibScript.Name = 'GLib'
		GLibScript.Parent = Tool
		local Sword = require(Tool:WaitForChild'Sword')

		if workspace.FilteringEnabled then
			-- Run the sword code on the server and accept input from the client

			Sword:Initialize()

			Tool:WaitForChild'RemoteClick'.OnServerEvent:connect(function(client, action)
				if client.Character == Tool.Parent then
					Sword:Attack()
				end
			end)
		end
		Tool.Unequipped:connect(function()
			Sword:Unequip()
		end)]]
	elseif v.Name == "Server" and v:FindFirstChild("Rocket") then
		source = [[-----------------
--| Constants |--
-----------------

local GRAVITY_ACCELERATION = workspace.Gravity

local RELOAD_TIME = 3 -- Seconds until tool can be used again
local ROCKET_SPEED = 60 -- Speed of the projectile

local MISSILE_MESH_ID = 'http://www.roblox.com/asset/?id=2251534'
local MISSILE_MESH_SCALE = Vector3.new(0.35, 0.35, 0.25)
local ROCKET_PART_SIZE = Vector3.new(1.2, 1.2, 3.27)

-----------------
--| Variables |--
-----------------

local DebrisService = game:GetService('Debris')
local PlayersService = game:GetService('Players')

local MyPlayer

local Tool = script.Parent
local ToolHandle = Tool:WaitForChild("Handle")

local MouseLoc = Tool:WaitForChild("MouseLoc",10)

local RocketScript = script:WaitForChild('Rocket')
local SwooshSound = script:WaitForChild('Swoosh')
local BoomSound = script:WaitForChild('Boom')

--NOTE: We create the rocket once and then clone it when the player fires
local Rocket = Instance.new('Part') do
	-- Set up the rocket part
	Rocket.Name = 'Rocket'
	Rocket.FormFactor = Enum.FormFactor.Custom --NOTE: This must be done before changing Size
	Rocket.Size = ROCKET_PART_SIZE
	Rocket.CanCollide = false

	-- Add the mesh
	local mesh = Instance.new('SpecialMesh', Rocket)
	mesh.MeshId = MISSILE_MESH_ID
	mesh.Scale = MISSILE_MESH_SCALE

	-- Add fire
	local fire = Instance.new('Fire', Rocket)
	fire.Heat = 5
	fire.Size = 2

	-- Add a force to counteract gravity
	local bodyForce = Instance.new('BodyForce', Rocket)
	bodyForce.Name = 'Antigravity'
	bodyForce.Force = Vector3.new(0, Rocket:GetMass() * GRAVITY_ACCELERATION, 0)

	-- Clone the sounds and set Boom to PlayOnRemove
	local swooshSoundClone = SwooshSound:Clone()
	swooshSoundClone.Parent = Rocket
	local boomSoundClone = BoomSound:Clone()
	boomSoundClone.PlayOnRemove = true
	boomSoundClone.Parent = Rocket

	-- Attach creator tags to the rocket early on
	local creatorTag = Instance.new('ObjectValue', Rocket)
	creatorTag.Value = MyPlayer
	creatorTag.Name = 'creator' --NOTE: Must be called 'creator' for website stats
	local iconTag = Instance.new('StringValue', creatorTag)
	iconTag.Value = Tool.TextureId
	iconTag.Name = 'icon'

	-- Finally, clone the rocket script and enable it
	local rocketScriptClone = RocketScript:Clone()
	rocketScriptClone.Parent = Rocket
	rocketScriptClone.Disabled = false
end

-----------------
--| Functions |--
-----------------

local function OnActivated()
	local myModel = MyPlayer.Character
	if Tool.Enabled and myModel and myModel:FindFirstChildOfClass("Humanoid") and myModel.Humanoid.Health > 0 then
		Tool.Enabled = false
		local Pos = MouseLoc:InvokeClient(MyPlayer)
		-- Create a clone of Rocket and set its color
		local rocketClone = Rocket:Clone()
		DebrisService:AddItem(rocketClone, 30)
		rocketClone.BrickColor = MyPlayer.TeamColor

		-- Position the rocket clone and launch!
		local spawnPosition = (ToolHandle.CFrame * CFrame.new(5, 0, 0)).p
		rocketClone.CFrame = CFrame.new(spawnPosition, Pos) --NOTE: This must be done before assigning Parent
		rocketClone.Velocity = rocketClone.CFrame.lookVector * ROCKET_SPEED --NOTE: This should be done before assigning Parent
		rocketClone.Parent = workspace
		rocketClone:SetNetworkOwner(nil)

		wait(RELOAD_TIME)

		Tool.Enabled = true
	end
end

function OnEquipped()
	MyPlayer = PlayersService:GetPlayerFromCharacter(Tool.Parent)
end

--------------------
--| Script Logic |--
--------------------

Tool.Equipped:Connect(OnEquipped)
Tool.Activated:Connect(OnActivated)
]]
	elseif v.Name == "Rocket" and v.Parent.Name == "Server" then
		source = [[-----------------
--| Constants |--
-----------------

local BLAST_RADIUS = 8 -- Blast radius of the explosion
local BLAST_DAMAGE = 60 -- Amount of damage done to players
local BLAST_FORCE = 1000 -- Amount of force applied to parts

local IGNORE_LIST = {rocket = 1, handle = 1, effect = 1, water = 1} -- Rocket will fly through things named these
--NOTE: Keys must be lowercase, values must evaluate to true

-----------------
--| Variables |--
-----------------

local DebrisService = game:GetService('Debris')
local PlayersService = game:GetService('Players')

local Rocket = script.Parent

local CreatorTag = Rocket:WaitForChild('creator')
local SwooshSound = Rocket:WaitForChild('Swoosh')

-----------------
--| Functions |--
-----------------

-- Removes any old creator tags and applies a new one to the target
local function ApplyTags(target)
	while target:FindFirstChild('creator') do
		target.creator:Destroy()
	end

	local creatorTagClone = CreatorTag:Clone()
	DebrisService:AddItem(creatorTagClone, 1.5)
	creatorTagClone.Parent = target
end

-- Returns the ancestor that contains a Humanoid, if it exists
local function FindCharacterAncestor(subject)
	if subject and subject ~= workspace then
		local humanoid = subject:FindFirstChildOfClass('Humanoid')
		if humanoid then
			return subject, humanoid
		else
			return FindCharacterAncestor(subject.Parent)
		end
	end
	return nil
end

local function IsInTable(Table,Value)
	for _,v in pairs(Table) do
		if v == Value then
			return true
		end
	end
	return false
end

-- Customized explosive effect that doesn't affect teammates and only breaks joints on dead parts
local TaggedHumanoids = {}
local function OnExplosionHit(hitPart, hitDistance, blastCenter)
	if hitPart and hitDistance then
		local character, humanoid = FindCharacterAncestor(hitPart.Parent)

		if character then
			local myPlayer = CreatorTag.Value
			if myPlayer and not myPlayer.Neutral then -- Ignore friendlies caught in the blast
				local player = PlayersService:GetPlayerFromCharacter(character)
				if player and player ~= myPlayer and player.TeamColor == Rocket.BrickColor then
					return
				end
			end
		end

		if humanoid and humanoid.Health > 0 then -- Humanoids are tagged and damaged
			if not IsInTable(TaggedHumanoids,humanoid) then
				print("Tagged")
				table.insert(TaggedHumanoids,humanoid)
				ApplyTags(humanoid)
				humanoid:TakeDamage(BLAST_DAMAGE)
			end
		else -- Loose parts and dead parts are blasted
			if hitPart.Name ~= 'Handle' then
				hitPart:BreakJoints()
				local blastForce = Instance.new('BodyForce', hitPart) --NOTE: We will multiply by mass so bigger parts get blasted more
				blastForce.Force = (hitPart.Position - blastCenter).unit * BLAST_FORCE * hitPart:GetMass()
				DebrisService:AddItem(blastForce, 0.1)
			end
		end
	end
end

local function OnTouched(otherPart)
	if Rocket and otherPart then
		-- Fly through anything in the ignore list
		if IGNORE_LIST[string.lower(otherPart.Name)] then
			return
		end

		local myPlayer = CreatorTag.Value
		if myPlayer then
			-- Fly through the creator
			if myPlayer.Character and myPlayer.Character:IsAncestorOf(otherPart) then
				return
			end

			 -- Fly through friendlies
			if not myPlayer.Neutral then
				local character = FindCharacterAncestor(otherPart.Parent)
				local player = PlayersService:GetPlayerFromCharacter(character)
				if player and player ~= myPlayer and player.TeamColor == Rocket.BrickColor then
					return
				end
			end
		end

		-- Fly through terrain water
		if otherPart == workspace.Terrain then
			--NOTE: If the rocket is large, then the simplifications made here will cause it to fly through terrain in some cases
			local frontOfRocket = Rocket.Position + (Rocket.CFrame.lookVector * (Rocket.Size.Z / 2))
			local cellLocation = workspace.Terrain:WorldToCellPreferSolid(frontOfRocket)
			local cellMaterial = workspace.Terrain:GetCell(cellLocation.X, cellLocation.Y, cellLocation.Z)
			if cellMaterial == Enum.CellMaterial.Water or cellMaterial == Enum.CellMaterial.Empty then
				return
			end
		end

		-- Create the explosion
		local explosion = Instance.new('Explosion')
		explosion.BlastPressure = 0 -- Completely safe explosion
		explosion.BlastRadius = BLAST_RADIUS
		explosion.ExplosionType = Enum.ExplosionType.NoCraters
		explosion.Position = Rocket.Position
		explosion.Parent = workspace

		-- Connect custom logic for the explosion
		explosion.Hit:Connect(function(hitPart, hitDistance) OnExplosionHit(hitPart, hitDistance, explosion.Position) end)

		-- Move this script and the creator tag (so our custom logic can execute), then destroy the rocket
		script.Parent = explosion
		CreatorTag.Parent = script
		Rocket:Destroy()
	end
end

--------------------
--| Script Logic |--
--------------------

SwooshSound:Play()

Rocket.Touched:Connect(OnTouched)
]]
	elseif v.Name == "PlantBomb" then
		source = [[local bombScript = script.Parent.Bomb
local Tool = script.Parent
local Bomb = Tool.Handle

function plant()
	local bomb2 = Instance.new("Part")
   
	local vCharacter = Tool.Parent
	local vPlayer = game.Players:playerFromCharacter(vCharacter)

	local spawnPos = Bomb.Position

	bomb2.Position = Vector3.new(spawnPos.x, spawnPos.y+3, spawnPos.z)
	bomb2.Size = Vector3.new(2,2,2)
	
	bomb2.BrickColor = BrickColor.new(21)
	bomb2.Shape = 0
	bomb2.BottomSurface = 0
	bomb2.TopSurface = 0
	bomb2.Reflectance = 1
	bomb2.Name = "TimeBomb"
	bomb2.Locked = true

	local creator_tag = Instance.new("ObjectValue")
	creator_tag.Value = vPlayer
	creator_tag.Name = "creator"
	creator_tag.Parent = bomb2

	bomb2.Parent = game.Workspace
	local new_script = bombScript:clone()
	new_script.Disabled = false
	new_script.Parent = bomb2
end


Tool.Enabled = true
function onActivated()

	if not Tool.Enabled then
		return
	end

	Tool.Enabled = false

	local character = Tool.Parent;
	local humanoid = character.Humanoid
	if humanoid == nil then
		print("Humanoid not found")
		return 
	end

	local targetPos = humanoid.TargetPoint
	Bomb.Transparency = 1.0

	plant()

	wait(6)
	Bomb.Transparency = 0.0

	Tool.Enabled = true
end

function onUnequipped()
end


Tool.Activated:connect(onActivated)
Tool.Unequipped:connect(onUnequipped)]]
	elseif v.Name == "Bomb" then
		source = [[local updateInterval = .4

local currentColor = 1
local colors = {26, 21} 

local ticksound = Instance.new("Sound")
ticksound.SoundId = "rbxasset://sounds\\clickfast.wav"
ticksound.Parent = script.Parent

function update()
	updateInterval = updateInterval * .9
	script.Parent.BrickColor = BrickColor.new(colors[currentColor])
	currentColor = currentColor + 1
	if (currentColor > 2) then currentColor = 1 end
end


function blowUp()
	local sound = Instance.new("Sound")
		sound.SoundId = "rbxasset://sounds\\Rocket shot.wav"
		sound.Parent = script.Parent
		sound.Volume = 1
		sound:play()
	explosion = Instance.new("Explosion")
	explosion.BlastRadius = 12
	explosion.BlastPressure = 1000000 -- these are really wussy units

	-- find instigator tag
	local creator = script.Parent:findFirstChild("creator")
	if creator ~= nil then
		explosion.Hit:connect(function(part, distance)  onPlayerBlownUp(part, distance, creator) end)
	end

	explosion.Position = script.Parent.Position
	explosion.Parent = game.Workspace
	script.Parent.Transparency = 1
end

function onPlayerBlownUp(part, distance, creator)
	if part.Name == "Head" then
		local humanoid = part.Parent.Humanoid
		tagHumanoid(humanoid, creator)
	end
end

function tagHumanoid(humanoid, creator)
	-- tag does not need to expire iff all explosions lethal	
	if creator ~= nil then
		local new_tag = creator:clone()
		new_tag.Parent = humanoid
	end
end

function untagHumanoid(humanoid)
	if humanoid ~= nil then
		local tag = humanoid:findFirstChild("creator")
		if tag ~= nil then
			tag.Parent = nil
		end
	end
end

while updateInterval > .1 do
	wait(updateInterval)
	update()	
	ticksound:play()	
end

blowUp()
wait(2)
script.Parent:remove()
]]
	elseif v.Parent.Name == "Image Ad Unit 2" then
		source = [[local package = script.Parent
local adGui = package:WaitForChild('ADpart'):WaitForChild('AdGui')

local function updateFallbackImage()
	local fallbackImage = package:GetAttribute('FallbackImage')

	-- prepend "rbxassetid://" if the value is a base 10 number
	if tostring(tonumber(fallbackImage)) == fallbackImage then
		fallbackImage = "rbxassetid://" .. fallbackImage
	end

	adGui.FallbackImage = fallbackImage
end

package:GetAttributeChangedSignal('FallbackImage'):Connect(updateFallbackImage)

-- run for the first time
if package:GetAttribute('FallbackImage') then 
	updateFallbackImage() 
end]]
	elseif v.Name == "Slingshot" then
		source = [[Tool = script.Parent

local MouseLoc = Tool:WaitForChild("MouseLoc")

VELOCITY = 85 -- constant

local Pellet = Instance.new("Part")
Pellet.Locked = true
Pellet.BackSurface = 0
Pellet.BottomSurface = 0
Pellet.FrontSurface = 0
Pellet.LeftSurface = 0
Pellet.RightSurface = 0
Pellet.TopSurface = 0
Pellet.Shape = 0
Pellet.Size = Vector3.new(1,1,1)
Pellet.BrickColor = BrickColor.new(21)
script.Parent.PelletScript:Clone().Parent = Pellet

function fire(mouse_pos)


	Tool.Handle.SlingshotSound:Play()

-- find player's head pos

	local vCharacter = Tool.Parent
	local vPlayer = game.Players:GetPlayerFromCharacter(vCharacter)

	local head = vCharacter:FindFirstChild("Head")
	if not head then return end

	local dir = mouse_pos - head.Position
	dir = computeDirection(dir)

	local launch = head.Position + 5 * dir

	local delta = mouse_pos - launch
	
	local dy = delta.y
	
	local new_delta = Vector3.new(delta.x, 0, delta.z)
	delta = new_delta

	local dx = delta.magnitude
	local unit_delta = delta.unit
	
	-- acceleration due to gravity in RBX units
	local g = (-9.81 * 20)

	local theta = computeLaunchAngle( dx, dy, g)

	local vy = math.sin(theta)
	local xz = math.cos(theta)
	local vx = unit_delta.x * xz
	local vz = unit_delta.z * xz
	

	local missile = Pellet:Clone()
        

		

	missile.Position = launch
	missile.Velocity = Vector3.new(vx,vy,vz) * VELOCITY

	missile.PelletScript.Disabled = false

	local creator_tag = Instance.new("ObjectValue")
	creator_tag.Value = vPlayer
	creator_tag.Name = "creator"
	creator_tag.Parent = missile
	
	missile.Parent = workspace

end


function computeLaunchAngle(dx,dy,grav)
	-- arcane
	-- http://en.wikipedia.org/wiki/Trajectory_of_a_projectile
	
	local g = math.abs(grav)
	local inRoot = (VELOCITY*VELOCITY*VELOCITY*VELOCITY) - (g * ((g*dx*dx) + (2*dy*VELOCITY*VELOCITY)))
	if inRoot <= 0 then
		return .25 * math.pi
	end
	local root = math.sqrt(inRoot)
	local inATan1 = ((VELOCITY*VELOCITY) + root) / (g*dx)

	local inATan2 = ((VELOCITY*VELOCITY) - root) / (g*dx)
	local answer1 = math.atan(inATan1)
	local answer2 = math.atan(inATan2)
	if answer1 < answer2 then return answer1 end
	return answer2
end

function computeDirection(vec)
	local lenSquared = vec.magnitude * vec.magnitude
	local invSqrt = 1 / math.sqrt(lenSquared)
	return Vector3.new(vec.x * invSqrt, vec.y * invSqrt, vec.z * invSqrt)
end




Tool.Enabled = true
function onActivated()

	if not Tool.Enabled then
		return
	end

	Tool.Enabled = false

	local character = Tool.Parent;
	local humanoid = character.Humanoid
	if not humanoid  then
		print("Humanoid not found")
		return 
	end

	local targetPos = MouseLoc:InvokeClient(game:GetService("Players"):GetPlayerFromCharacter(character))

	fire(targetPos)

	wait(.2)

	Tool.Enabled = true
end

script.Parent.Activated:Connect(onActivated)
]]
	elseif v.Name == "PelletScript" then
		source = [[local debris = game:service("Debris")
pellet = script.Parent
damage = 8

function onTouched(hit)
	if not hit or not hit.Parent then return end
	local humanoid = hit.Parent:FindFirstChildOfClass("Humanoid")
	if humanoid then
		tagHumanoid(humanoid)
		humanoid:TakeDamage(damage)
	else
		damage = damage / 2
		if damage < 1 then
			connection:Disconnect()
			pellet.Parent = nil
		end
	end
end

function tagHumanoid(humanoid)
	-- todo: make tag expire
	local tag = pellet:FindFirstChild("creator")
	if tag then
		-- kill all other tags
		while(humanoid:FindFirstChild("creator")) do
			humanoid:findFirstChild("creator").Parent = nil
		end

		local new_tag = tag:Clone()
		new_tag.Parent = humanoid
		debris:AddItem(new_tag, 1)
	end
end

connection = pellet.Touched:Connect(onTouched)

r = game:service("RunService")
t, s = r.Stepped:Wait()
d = t + 2.0 - s
while t < d do
	t = r.Stepped:Wait()
end

pellet:Destroy()
]]
	elseif v.Name == "ServerWeaponsScript" then
		source = [[local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

local curWeaponsSystemFolder = script.Parent
local weaponsSystemFolder = ReplicatedStorage:FindFirstChild("WeaponsSystem")
local weaponsSystemInitialized = false

local function initializeWeaponsSystemAssets()
	if not weaponsSystemInitialized then
		-- Enable/make visible all necessary assets
		local effectsFolder = weaponsSystemFolder.Assets.Effects
		local partNonZeroTransparencyValues = {
			["BulletHole"] = 1, ["Explosion"] = 1, ["Pellet"] = 1, ["Scorch"] = 1,
			["Bullet"] = 1, ["Plasma"] = 1, ["Railgun"] = 1,
		}
		local decalNonZeroTransparencyValues = { ["ScorchMark"] = 0.25 }
		local particleEmittersToDisable = { ["Smoke"] = true }
		local imageLabelNonZeroTransparencyValues = { ["Impact"] = 0.25 }
		for _, descendant in pairs(effectsFolder:GetDescendants()) do
			if descendant:IsA("BasePart") then
				if partNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = partNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("Decal") then
				descendant.Transparency = 0
				if decalNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.Transparency = decalNonZeroTransparencyValues[descendant.Name]
				else
					descendant.Transparency = 0
				end
			elseif descendant:IsA("ParticleEmitter") then
				descendant.Enabled = true
				if particleEmittersToDisable[descendant.Name] ~= nil then
					descendant.Enabled = false
				else
					descendant.Enabled = true
				end
			elseif descendant:IsA("ImageLabel") then
				if imageLabelNonZeroTransparencyValues[descendant.Name] ~= nil then
					descendant.ImageTransparency = imageLabelNonZeroTransparencyValues[descendant.Name]
				else
					descendant.ImageTransparency = 0
				end
			end
		end
		
		weaponsSystemInitialized = true
	end
end

if weaponsSystemFolder == nil then
	weaponsSystemFolder = curWeaponsSystemFolder:Clone()
	initializeWeaponsSystemAssets()
	weaponsSystemFolder.Parent = ReplicatedStorage
end

if ServerScriptService:FindFirstChild("ServerWeaponsScript") == nil then
	script.Parent = ServerScriptService
	initializeWeaponsSystemAssets()

	local WeaponsSystem = require(weaponsSystemFolder.WeaponsSystem)
	if not WeaponsSystem.doingSetup and not WeaponsSystem.didSetup then
		WeaponsSystem.setup()
	end
	
	local function setupClientWeaponsScript(player)
		local clientWeaponsScript = player.PlayerGui:FindFirstChild("ClientWeaponsScript")
		if clientWeaponsScript == nil then
			clientWeaponsScript = weaponsSystemFolder.ClientWeaponsScript:Clone()
			clientWeaponsScript.Parent = player.PlayerGui
		end
	end
	
	Players.PlayerAdded:Connect(function(player)
		setupClientWeaponsScript(player)
	end)
	
	for _, player in ipairs(Players:GetPlayers()) do
		setupClientWeaponsScript(player)
	end
end

if curWeaponsSystemFolder.Name == "WeaponsSystem" then
	curWeaponsSystemFolder:Destroy()
end]]
	elseif v.Name == "BrickCleanup" and v.Parent:FindFirstChild("WallMaker") then
		source = [[-- this script removes its parent from the workspace after 24 seconds
local Debris = game:GetService("Debris")
Debris:AddItem(script.Parent,24)

]]
	elseif v.Name == "WallMaker" then
		source = [[local wallHeight = 4
local brickSpeed = 0.04
local wallWidth = 12

local Tool = script.Parent

local MouseLoc = Tool:WaitForChild("MouseLoc",10)

-- places a brick at pos and returns the position of the brick's opposite corner
function placeBrick(cf, pos, color)
	local brick = Instance.new("Part")
	brick.BrickColor = color
	brick.CFrame = cf * CFrame.new(pos + brick.Size / 2)
	script.Parent.BrickCleanup:Clone().Parent = brick -- attach cleanup script to this brick
	brick.BrickCleanup.Disabled = false
	brick.Parent = game.Workspace
	brick:MakeJoints()
	return  brick, pos +  brick.Size
end

function buildWall(cf)

	local color = BrickColor.Random()
	local bricks = {}

	assert(wallWidth>0)
	local y = 0
	while y < wallHeight do
		local p
		local x = -wallWidth/2
		while x < wallWidth/2 do
			local brick
			brick, p = placeBrick(cf, Vector3.new(x, y, 0), color)
			x = p.x
			table.insert(bricks, brick)
			wait(brickSpeed)
		end
		y = p.y
	end

	return bricks

end


function snap(v)
	if math.abs(v.x)>math.abs(v.z) then
		if v.x>0 then
			return Vector3.new(1,0,0)
		else
			return Vector3.new(-1,0,0)
		end
	else
		if v.z>0 then
			return Vector3.new(0,0,1)
		else
			return Vector3.new(0,0,-1)
		end
	end
end


Tool.Enabled = true
function onActivated()

	if not Tool.Enabled then
		return
	end

	Tool.Enabled = false

	local character = Tool.Parent;
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		return 
	end

	local targetPos = MouseLoc:InvokeClient(game:GetService("Players"):GetPlayerFromCharacter(character))
	local lookAt = snap( (targetPos - character.Head.Position).unit )
	local cf = CFrame.new(targetPos, targetPos + lookAt)

	Tool.Handle.BuildSound:Play()

	buildWall(cf)

	wait(5)

	Tool.Enabled = true
end

Tool.Activated:Connect(onActivated)

]]
	elseif v.Name == "BrickCleanup" and v.Parent:FindFirstChild("PaintballShooter") then
		source = [[-- this script removes its parent from the workspace after 120 seconds

		wait(120)
		script.Parent.Parent = nil
		]]
	elseif v.Name == "Paintball" then
		source = [[ball = script.Parent
damage = 2

function onTouched(hit)
	local humanoid = hit.Parent:findFirstChild("Humanoid")
	
		
	if hit:getMass() < 1.2 * 200 then
		hit.BrickColor = ball.BrickColor
	end
	-- make a splat
	for i=1,3 do
		local s = Instance.new("Part")
		s.Shape = 1 -- block
		s.formFactor = 2 -- plate
		s.Size = Vector3.new(1,.4,1)
		s.BrickColor = ball.BrickColor
		local v = Vector3.new(math.random(-1,1), math.random(0,1), math.random(-1,1))
		s.Velocity = 15 * v
		s.CFrame = CFrame.new(ball.Position + v, v)
		ball.BrickCleanup:clone().Parent = s
		s.BrickCleanup.Disabled = false
		s.Parent = game.Workspace
		
	end
	

	if humanoid ~= nil then
		tagHumanoid(humanoid)
		humanoid:TakeDamage(damage)
		wait(2)
		untagHumanoid(humanoid)
	end

	connection:disconnect()
	ball.Parent = nil
end

function tagHumanoid(humanoid)
	-- todo: make tag expire
	local tag = ball:findFirstChild("creator")
	if tag ~= nil then
		local new_tag = tag:clone()
		new_tag.Parent = humanoid
	end
end


function untagHumanoid(humanoid)
	if humanoid ~= nil then
		local tag = humanoid:findFirstChild("creator")
		if tag ~= nil then
			tag.Parent = nil
		end
	end
end

connection = ball.Touched:connect(onTouched)

wait(8)
ball.Parent = nil
]]
	elseif v.Name == "PaintballShooter" then
		source = [[Tool = script.Parent

colors = {45, 119, 21, 24, 23, 105, 104}

function fire(v)

	Tool.Handle.Fire:play()
	

	local vCharacter = Tool.Parent
	local vPlayer = game.Players:playerFromCharacter(vCharacter)

	local missile = Instance.new("Part")

        

	local spawnPos = vCharacter.PrimaryPart.Position
	


	spawnPos  = spawnPos + (v * 8)

	missile.Position = spawnPos
	missile.Size = Vector3.new(1,1,1)
	missile.Velocity = v * 100
	missile.BrickColor = BrickColor.new(colors[math.random(1, #colors)])
	missile.Shape = 0
	missile.BottomSurface = 0
	missile.TopSurface = 0
	missile.Name = "Paintball"
	missile.Elasticity = 0
	missile.Reflectance = 0
	missile.Friction = .9

	local force = Instance.new("BodyForce")
	force.force = Vector3.new(0,90 * missile:GetMass(),0)
	force.Parent = missile
	
	Tool.BrickCleanup:clone().Parent = missile

	local new_script = script.Parent.Paintball:clone()
	new_script.Disabled = false
	new_script.Parent = missile

	local creator_tag = Instance.new("ObjectValue")
	creator_tag.Value = vPlayer
	creator_tag.Name = "creator"
	creator_tag.Parent = missile
	


	missile.Parent = game.Workspace

end



Tool.Enabled = true
function onActivated()

	if not Tool.Enabled then
		return
	end

	Tool.Enabled = false

	local character = Tool.Parent;
	local humanoid = character.Humanoid
	if humanoid == nil then
		print("Humanoid not found")
		return 
	end

	local targetPos = humanoid.TargetPoint
	local lookAt = (targetPos - character.Head.Position).unit

	fire(lookAt)

	wait(.5)

	Tool.Enabled = true
end


script.Parent.Activated:connect(onActivated)
]]
	elseif v.Name == "PizzaScript" then
		source = [[--[[ alexnewtron 2014 ]--
		local Tool = script.Parent;
		enabled = true;
		function onActivated()
			if not enabled  then
				return;
			end
			enabled = false;
			Tool.GripForward = Vector3.new(.995, -.0995, -8);
			Tool.GripPos = Vector3.new(-1.5, -0.9, 0.5);
			Tool.GripRight = Vector3.new(-1, 0, 0);
			Tool.GripUp = Vector3.new(0, 1, 0);
			Tool.Handle.DrinkSound:Play();
			wait(.8);
			local h = Tool.Parent:FindFirstChild("Humanoid");
			if (h ~= nil) then
				if (h.MaxHealth > h.Health + 1.6) then
					h.Health = h.Health + 1.6
				else	
					h.Health = h.MaxHealth
				end
			end
			Tool.GripForward = Vector3.new(0, 0, -1);
			Tool.GripPos = Vector3.new(0, 0, 0.5);
			Tool.GripRight = Vector3.new(1, 0, 0);
			Tool.GripUp = Vector3.new(0,1,0);
			enabled = true;
		end
		function onEquipped()
			Tool.Handle.OpenSound:play();
		end
		script.Parent.Activated:connect(onActivated);
		script.Parent.Equipped:connect(onEquipped);]]
	elseif v.Name == "PianoScript" then
		source = [[local seat = script.Parent.Bench.Seat
local sheetMusic = script.Parent.Piano.SheetMusic
local occupant = nil
local tune = nil
local oldTune = nil
local animation = nil
local r6Anim = script.PlayingR6
local r15Anim = script.PlayingR15

tunes = {
	"rbxassetid://1835519330",
}

seat.ChildAdded:Connect(function(obj)
	if obj.Name == "SeatWeld" then
		local player = game.Players:GetPlayerFromCharacter(obj.Part1.Parent)
		if player then
			local hum = player.Character:FindFirstChild("Humanoid")
			occupant = obj.Part1.Parent
			if hum.RigType == Enum.HumanoidRigType.R6 then
				animation = hum:LoadAnimation(r6Anim)
			else
				animation = hum:LoadAnimation(r15Anim)
			end
			animation:Play()
		end
	end
end)

seat.ChildRemoved:Connect(function(obj)
	if obj.Name == "SeatWeld" then
		local player = game.Players:GetPlayerFromCharacter(obj.Part1.Parent)
		if player then
			animation:Stop()
			occupant = nil
			sheetMusic.Sound:Stop()
		end
	end
end)

while wait(0.1) do
	if occupant ~= nil then
		repeat
			tune = tunes[math.random(1, #tunes)]
		until tune ~= oldTune
		oldTune = tune
		sheetMusic.Sound.SoundId = tune	
		sheetMusic.Sound:Play()
		repeat
			wait()
		until not sheetMusic.Sound.Playing
	end
end]]
	elseif v.Name == "AttributesController" then
		source = [[local portalTemplate = script.Parent.Parent
local basePortal = portalTemplate:WaitForChild('BasePortal')

local function updateFallbackImage()
	local fallbackImage = portalTemplate:GetAttribute('FallbackImage')
	basePortal:setAttribute('FallbackImage', fallbackImage)
end

portalTemplate:GetAttributeChangedSignal('FallbackImage'):Connect(updateFallbackImage)

-- run for the first time
if portalTemplate:GetAttribute('FallbackImage') then 
	updateFallbackImage() 
end]]
	elseif v.Name == "CannonScript" then
		source = [[local Tool = script.Parent
local Ball = Tool.Handle
local MouseLoc = Tool:WaitForChild("MouseLoc",10)

function fire(direction)

	Tool.Handle.Boing:Play()

	local vCharacter = Tool.Parent
	local vPlayer = game.Players:GetPlayerFromCharacter(vCharacter)

	local missile = Instance.new("Part")       

	local spawnPos = vCharacter.PrimaryPart.Position

	spawnPos  = spawnPos + (direction * 5)

	missile.Position = spawnPos
	missile.Size = Vector3.new(2,2,2)
	missile.Velocity = direction * 200
	missile.BrickColor = BrickColor.Random()
	missile.Shape = 0
	missile.Locked = true
	missile.BottomSurface = 0
	missile.TopSurface = 0
	missile.Name = "Cannon Shot"
	missile.Elasticity = 1
	missile.Reflectance = .2
	missile.Friction = 0

	Tool.Handle.Boing:Clone().Parent = missile
	
	local new_script = script.Parent.CannonBall:Clone()
	new_script.Disabled = false
	new_script.Parent = missile

	local creator_tag = Instance.new("ObjectValue")
	creator_tag.Value = vPlayer
	creator_tag.Name = "creator"
	creator_tag.Parent = missile

	missile.Parent = workspace
end



Tool.Enabled = true
function onActivated()
	if not Tool.Enabled then
		return
	end
	Tool.Enabled = false
	local character = Tool.Parent;
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then
		print("Humanoid not found")
		return 
	end
	local targetPos = MouseLoc:InvokeClient(game:GetService("Players"):GetPlayerFromCharacter(character))
	local lookAt = (targetPos - character.Head.Position).unit
	fire(lookAt)
	wait(2)
	Tool.Enabled = true
end


Tool.Activated:Connect(onActivated)

]]
	elseif v.Name == "CannonBall" then
		source = [[local Ball = script.Parent
local damage = 25

local r = game:GetService("RunService")
local debris = game:GetService("Debris")

local last_sound_time = r.Stepped:Wait()

function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end

function onTouched(hit)
	if not hit or not hit.Parent then return end 
	local now = r.Stepped:Wait()
	if (now - last_sound_time > .1) then
		Ball.Boing:Play()
		last_sound_time = now
	else
		return
	end

	local humanoid = hit.Parent:FindFirstChildOfClass("Humanoid")
	local tag = Ball:FindFirstChild("creator")
	if tag and humanoid then
		if not IsTeamMate(tag.Value,game.Players:GetPlayerFromCharacter(humanoid.Parent)) then
			tagHumanoid(humanoid)		
			humanoid:TakeDamage(damage)	
		if connection then connection:Disconnect() end
		end
	else
		damage = damage / 2
		if damage < 2 then
			if connection then connection:Disconnect() end
		end
	end
end

function tagHumanoid(humanoid)
	-- todo: make tag expire
	local tag = Ball:FindFirstChild("creator")
	if tag then
		-- kill all other tags
		while(humanoid:FindFirstChild("creator")) do
			humanoid:FindFirstChild("creator").Parent:Destroy()
		end

		local new_tag = tag:Clone()
		new_tag.Parent = humanoid
		debris:AddItem(new_tag, 1)
	end
end


connection = Ball.Touched:Connect(onTouched)

t, s = r.Stepped:Wait()
d = t + 5.0 - s
while t < d do
	t = r.Stepped:Wait()
end

Ball:Destroy()]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("Memorial Day 2010") then
		source = [[local soldier = script.Parent
soldier.GunStorage.Gun.Parent = soldier

for _, script in pairs(soldier.ModuleScripts:GetChildren()) do
	if not game.ServerStorage:FindFirstChild(script.Name) then
		script:Clone().Parent = game.ServerStorage
	end
end

wait(1)


local AI = require(game.ServerStorage.ROBLOX_SoldierAI).new(soldier)


local DestroyService = require(game.ServerStorage.ROBLOX_DestroyService)

local function clearParts(parent)
	for _, part in pairs(parent:GetChildren()) do
		clearParts(part)
	end
	local delay
	if parent:IsA("Part") then
		delay = math.random(5,10)
	else
		delay = 11
	end
	DestroyService:AddItem(parent, delay)
end

soldier.Humanoid.Died:connect(function()
	AI.Stop()
	math.randomseed(tick())
	clearParts(soldier)
	script.Disabled = true
end)]]
	elseif v.Name == "HealthRegenerationScript" then
		source = [[-- Renegeration Script for the bot
-- Renegerates about 1% of max hp per second until it reaches max health
bot = script.Parent
Humanoid = bot:FindFirstChild("Humanoid")

local regen = false

function regenerate() 
	if regen then return end
	-- Lock this function until the regeneration to max health is complete by using a boolean toggle
	regen = true
	while Humanoid.Health < Humanoid.MaxHealth do
		local delta = wait(1)
		local health = Humanoid.Health
		if health > 0 and health < Humanoid.MaxHealth then 
			-- This delta is for regenerating 1% of max hp per second instead of 1 hp per second
			delta = 0.01 * delta * Humanoid.MaxHealth
			health = health + delta
			Humanoid.Health = math.min(health, Humanoid.MaxHealth)			
		end
	end	
	-- release the lock, since the health is at max now, and if the character loses health again
	-- it needs to start regenerating 
	regen = false
end	

if Humanoid then 
	-- Better than a while true do loop since it only fires when the health actually changes
	Humanoid.HealthChanged:connect(regenerate)	
end
]]
	elseif v.Name == "GhostScript" then
		source = [[--Made by Stickmasterluke

--Ghost Script


sp=script.Parent
lastattack=0
nextrandom=0
nextsound=0
nextjump=0
chasing=false

variance=3

damage=15
attackrange=6
sightrange=40
runspeed=24
wonderspeed=8
healthregen=false

function raycast(spos,vec,currentdist)
	local hit2,pos2=game.Workspace:FindPartOnRay(Ray.new(spos+(vec*.01),vec*currentdist),sp)
	if hit2~=nil and pos2 then
		if hit2.Transparency>=.8 or hit2.Name=="Handle" or string.sub(hit2.Name,1,6)=="Effect" then
			local currentdist=currentdist-(pos2-spos).magnitude
			return raycast(pos2,vec,currentdist)
		end
	end
	return hit2,pos2
end

function waitForChild(parent,childName)
	local child=parent:findFirstChild(childName)
	if child then return child end
	while true do
		child=parent.ChildAdded:wait()
		if child.Name==childName then return child end
	end
end

-- ANIMATION

-- declarations

local Torso=waitForChild(sp,"Torso")
local Head=waitForChild(sp,"Head")
local RightShoulder=waitForChild(Torso,"Right Shoulder")
local LeftShoulder=waitForChild(Torso,"Left Shoulder")
local RightHip=waitForChild(Torso,"Right Hip")
local LeftHip=waitForChild(Torso,"Left Hip")
local Neck=waitForChild(Torso,"Neck")
local Humanoid=waitForChild(sp,"Humanoid")
local pose="Standing"
local hitsound=waitForChild(Torso,"HitSound")

local sounds={
	waitForChild(Torso,"Ghost1Sound"),
	waitForChild(Torso,"Ghost2Sound"),
	waitForChild(Torso,"DiieieSound"),
	waitForChild(Torso,"ScreamSound"),
}

--[[creepy ghost sounds
Ghost1 94247611
Ghost2 94247729
Diieie 94247798
Scream 94247848
Rustle 94247873
]

		if healthregen then
			local regenscript=waitForChild(sp,"HealthRegenerationScript")
			regenscript.Disabled=false
		end
		Humanoid.WalkSpeed=wonderspeed

		local toolAnim="None"
		local toolAnimTime=0


		function onRunning(speed)
			if speed>0 then
				pose="Running"
			else
				pose="Standing"
			end
		end
		function onDied()
			pose="Dead"
		end
		function onJumping()
			pose="Jumping"
		end
		function onClimbing()
			pose="Climbing"
		end
		function onGettingUp()
			pose = "GettingUp"
		end
		function onFreeFall()
			pose = "FreeFall"
		end
		function onFallingDown()
			pose = "FallingDown"
		end
		function onSeated()
			pose = "Seated"
		end
		function onPlatformStanding()
			pose = "PlatformStanding"
		end

		function moveJump()
			RightShoulder.MaxVelocity = 0.5
			LeftShoulder.MaxVelocity = 0.5
			RightShoulder.DesiredAngle=3.14
			LeftShoulder.DesiredAngle=-3.14
			RightHip.DesiredAngle=0
			LeftHip.DesiredAngle=0
		end

		function moveFreeFall()
			RightShoulder.MaxVelocity = 0.5
			LeftShoulder.MaxVelocity =0.5
			RightShoulder.DesiredAngle=3.14
			LeftShoulder.DesiredAngle=-3.14
			RightHip.DesiredAngle=0
			LeftHip.DesiredAngle=0
		end

		function moveSit()
			RightShoulder.MaxVelocity = 0.15
			LeftShoulder.MaxVelocity = 0.15
			RightShoulder.DesiredAngle=3.14 /2
			LeftShoulder.DesiredAngle=-3.14 /2
			RightHip.DesiredAngle=3.14 /2
			LeftHip.DesiredAngle=-3.14 /2
		end

		function animate(time)
			local amplitude
			local frequency
			if (pose == "Jumping") then
				moveJump()
				return
			end
			if (pose == "FreeFall") then
				moveFreeFall()
				return
			end
			if (pose == "Seated") then
				moveSit()
				return
			end
			local climbFudge = 0
			if (pose == "Running") then
				RightShoulder.MaxVelocity = 0.15
				LeftShoulder.MaxVelocity = 0.15
				amplitude = 1
				frequency = 9
			elseif (pose == "Climbing") then
				RightShoulder.MaxVelocity = 0.5 
				LeftShoulder.MaxVelocity = 0.5
				amplitude = 1
				frequency = 9
				climbFudge = 3.14
			else
				amplitude = 0.1
				frequency = 1
			end
			desiredAngle = amplitude * math.sin(time*frequency)
			if not chasing and frequency==9 then
				frequency=4
			end
			if chasing then
				RightShoulder.DesiredAngle=math.pi/2
				LeftShoulder.DesiredAngle=-math.pi/2
				RightHip.DesiredAngle=-desiredAngle*2
				LeftHip.DesiredAngle=-desiredAngle*2
			else
				RightShoulder.DesiredAngle=desiredAngle + climbFudge
				LeftShoulder.DesiredAngle=desiredAngle - climbFudge
				RightHip.DesiredAngle=-desiredAngle
				LeftHip.DesiredAngle=-desiredAngle
			end
		end


		function attack(time,attackpos)
			if time-lastattack>=1 then
				local hit,pos=raycast(Torso.Position,(attackpos-Torso.Position).unit,attackrange)
				if hit and hit.Parent~=nil and hit.Parent.Name~=sp.Name then
					local h=hit.Parent:FindFirstChild("Humanoid")
					if h then
						local creator=sp:FindFirstChild("creator")
						if creator then
							if creator.Value~=nil then
								if creator.Value~=game.Players:GetPlayerFromCharacter(h.Parent) then
									for i,oldtag in ipairs(h:GetChildren()) do
										if oldtag.Name=="creator" then
											oldtag:remove()
										end
									end
									creator:clone().Parent=h
								else
									return
								end
							end
						end
						h:TakeDamage(damage)
						hitsound.Volume=.5+(.5*math.random())
						hitsound.Pitch=.5+math.random()
						hitsound:Play()
						if RightShoulder and LeftShoulder then
							RightShoulder.CurrentAngle=0
							LeftShoulder.CurrentAngle=0
						end
					end
				end
				lastattack=time
			end
		end


		Humanoid.Died:connect(onDied)
		Humanoid.Running:connect(onRunning)
		Humanoid.Jumping:connect(onJumping)
		Humanoid.Climbing:connect(onClimbing)
		Humanoid.GettingUp:connect(onGettingUp)
		Humanoid.FreeFalling:connect(onFreeFall)
		Humanoid.FallingDown:connect(onFallingDown)
		Humanoid.Seated:connect(onSeated)
		Humanoid.PlatformStanding:connect(onPlatformStanding)


		function populatehumanoids(mdl)
			if mdl.ClassName=="Humanoid" then
				table.insert(humanoids,mdl)
			end
			for i2,mdl2 in ipairs(mdl:GetChildren()) do
				populatehumanoids(mdl2)
			end
		end

		function playsound(time)
			nextsound=time+5+(math.random()*5)
			local randomsound=sounds[math.random(1,#sounds)]
			randomsound.Volume=.5+(.5*math.random())
			randomsound.Pitch=.5+(.5*math.random())
			randomsound:Play()
		end

		while sp.Parent~=nil and Humanoid and Humanoid.Parent~=nil and Humanoid.Health>0 and Torso and Head and Torso~=nil and Torso.Parent~=nil do
			local _,time=wait(1/3)
			humanoids={}
			populatehumanoids(game.Workspace)
			closesttarget=nil
			closestdist=sightrange
			local creator=sp:FindFirstChild("creator")
			for i,h in ipairs(humanoids) do
				if h and h.Parent~=nil then
					if h.Health>0 and h.Parent.Name~=sp.Name and h.Parent~=sp then
						local plr=game.Players:GetPlayerFromCharacter(h.Parent)
						if creator==nil or plr==nil or creator.Value~=plr then
							local t=h.Parent:FindFirstChild("Torso")
							if t~=nil then
								local dist=(t.Position-Torso.Position).magnitude
								if dist<closestdist then
									closestdist=dist
									closesttarget=t
								end
							end
						end
					end
				end
			end
			if closesttarget~=nil then
				if not chasing then
					playsound(time)
					chasing=true
					Humanoid.WalkSpeed=runspeed
				end
				Humanoid:MoveTo(closesttarget.Position+(Vector3.new(1,1,1)*(variance*((math.random()*2)-1))),closesttarget)
				if math.random()<.5 then
					attack(time,closesttarget.Position)
				end
			else
				if chasing then
					chasing=false
					Humanoid.WalkSpeed=wonderspeed
				end
				if time>nextrandom then
					nextrandom=time+3+(math.random()*5)
					local randompos=Torso.Position+((Vector3.new(1,1,1)*math.random()-Vector3.new(.5,.5,.5))*40)
					Humanoid:MoveTo(randompos,game.Workspace.Terrain)
				end
			end
			if time>nextsound then
				playsound(time)
			end
			if time>nextjump then
				nextjump=time+7+(math.random()*5)
				Humanoid.Jump=true
			end
			animate(time)
		end
		if sp~=nil then
			for i,v in ipairs(sp:GetChildren()) do
				if v.className=="Part" then
					v.CanCollide=false
				end
			end
		end
		wait(4)
		sp:remove() --Rest In Pizza
		]]
	elseif v.Name == "Script" and v.Parent.Name == "BloxyColaVendingMachine" then
		source = [[-- asset Id of the bloxy cola gear: http://www.roblox.com/Bloxy-Cola-item?id=10472779
local bloxyColaId = 10472779

-- when a player clicks on the vending machine, ask if they want to buy bloxy cola
script.Parent.ClickDetector.MouseClick:connect(function(player)
	Game:GetService("MarketplaceService"):PromptPurchase(player, bloxyColaId)
end)]]
	elseif v.Name == "StamperFloorRemover" then
		source = [[function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local model = script.Parent
waitForChild(model, "StamperFloor")

model.StamperFloor:Remove()

script:Remove()]]
	elseif v.Name == "VehicleScript" then
		source = [[function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local model = script.Parent
waitForChild(model, "Brakelight_Left")
waitForChild(model, "Brakelight_Right")
waitForChild(model, "Headlight_Left")
waitForChild(model, "Headlight_Right")
waitForChild(model, "Wheel_FrontLeft")
waitForChild(model, "Wheel_FrontRight")
waitForChild(model, "Wheel_BackLeft")
waitForChild(model, "Wheel_BackRight")
waitForChild(model, "ExhaustPipe")
waitForChild(model.ExhaustPipe, "Smoke")
waitForChild(model.ExhaustPipe, "Fire")
waitForChild(model, "VehicleSeat")
waitForChild(model, "VehicleSeatBack")
waitForChild(model.VehicleSeatBack, "BodyGyro")
waitForChild(model, "Bumper_Front")
waitForChild(model, "Bumper_Back")

local seat = model.VehicleSeat
local driverInSeat = false
local smoke = model.ExhaustPipe.Smoke
local fire = model.ExhaustPipe.Fire
local brake_L = model.Brakelight_Left
local brake_R = model.Brakelight_Right
local light_L = model.Headlight_Left
local light_R = model.Headlight_Right
local vehicleSeatBack = model.VehicleSeatBack
local gyro = vehicleSeatBack.BodyGyro
local backBumperForce = model.Bumper_Back.BodyForce
local frontBumperForce = model.Bumper_Front.BodyForce


-- SETTINGS
local brakeColor_on = BrickColor.new("Really red")
local brakeColor_off = BrickColor.new("Reddish brown")
local lightColor_on = BrickColor.new("Institutional white")
local lightColor_off = light_L.BrickColor
print("headlight off color will be " .. lightColor_off.Name)
local smokeOpacity_throttleOn = 0.5
local smokeOpacity_throttleOff = 0.1
local fireSize_big = 7
local fireSize_small = 3

function seatChildAddedHandler(child)
	if child.Name=="SeatWeld" then
		print("Turn car ON")
		driverInSeat = true
		smoke.Enabled = true
		smoke.Opacity = smokeOpacity_throttleOff
		light_L.BrickColor = lightColor_on
		light_R.BrickColor = lightColor_on
		fire.Size = fireSize_big
		fire.Enabled = true
		wait(0.3)
		fire.Size = fireSize_small
		if seat.Throttle==0 then
			fire.Enabled = false
		end
	end
end

function seatChildRemovedHandler(child)
	if child.Name=="SeatWeld" then
		print("Turn car OFF")
		driverInSeat = false
		smoke.Enabled = false
		light_L.BrickColor = lightColor_off
		light_R.BrickColor = lightColor_off
	end
end

function showBigFire()
	fire.Size = fireSize_big
	fire.Enabled = true
	wait(0.3)
	if seat.Throttle==1 then
		fire.Size = fireSize_small
	end
	wait(1)
	if seat.Throttle==1 then
		fire.Enabled = false
	end
end

local tiltForce = 84000
local tiltTime = 1
function tiltJeepBack()
	print("tiltJeepBack()")
	wait(tiltTime)
end

function tiltJeepForward()
	print("tiltJeepForward()")
	wait(tiltTime)
end

function seatChangedHandler(prop)
	if prop=="Throttle" then
		if seat.Throttle==1 then
			-- Throttle Forward
			brake_L.BrickColor = brakeColor_off
			brake_R.BrickColor = brakeColor_off
			smoke.Opacity = smokeOpacity_throttleOn
			local co = coroutine.create(showBigFire)
			coroutine.resume(co)
			local co2 = coroutine.create(tiltJeepBack)
			coroutine.resume(co2)
		elseif seat.Throttle==0 then
			-- Throttle Off
			brake_L.BrickColor = brakeColor_on
			brake_R.BrickColor = brakeColor_on
			smoke.Opacity = smokeOpacity_throttleOff
			fire.Enabled = false
			wait(0.9)
			if brake_L.BrickColor==brakeColor_on then
				brake_L.BrickColor = brakeColor_off
			end
			if brake_R.BrickColor==brakeColor_on then
				brake_R.BrickColor = brakeColor_off
			end
		elseif seat.Throttle==-1 then
			-- Throttle Reverse
			brake_L.BrickColor = lightColor_on
			brake_R.BrickColor = lightColor_on
			smoke.Opacity = smokeOpacity_throttleOff
			fire.Enabled = false
			local co = coroutine.create(tiltJeepForward)
			coroutine.resume(co)
		end
	end
end

-- Set initial colors
light_L.BrickColor = lightColor_off
light_R.BrickColor = lightColor_off
brake_L.BrickColor = brakeColor_off
brake_R.BrickColor = brakeColor_off
smoke.Enabled = false
fire.Enabled = false

print("JeepScript: connecting events...")
seat.ChildAdded:connect(seatChildAddedHandler)
seat.ChildRemoved:connect(seatChildRemovedHandler)
seat.Changed:connect(seatChangedHandler)
print("JeepScript: events connected.")

while true do
	-- Every 15 seconds, poll if jeep has turned upside down.  If true, then flip back upright.
	if(vehicleSeatBack.CFrame.lookVector.y <= 0.707) then
		print("Jeep is flipped.  Flipping right side up...")
		gyro.cframe = CFrame.new( Vector3.new(0,0,0), Vector3.new(0,1,0) )
		gyro.maxTorque = Vector3.new(1000, 1000, 1000)
		wait(2)
		gyro.maxTorque = Vector3.new(0,0,0)
	end
	wait(8)
end
]]
	elseif v.Name == "VehicleSmashScript" then
		source = [[function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local model = script.Parent
waitForChild(model, "Brakelight_Left")
waitForChild(model, "Brakelight_Right")
waitForChild(model, "Headlight_Left")
waitForChild(model, "Headlight_Right")
waitForChild(model, "Wheel_FrontLeft")
waitForChild(model, "Wheel_FrontRight")
waitForChild(model, "Wheel_BackLeft")
waitForChild(model, "Wheel_BackRight")
waitForChild(model, "ExhaustPipe")
waitForChild(model.ExhaustPipe, "Smoke")
waitForChild(model.ExhaustPipe, "Fire")
waitForChild(model, "VehicleSeat")
waitForChild(model, "VehicleSeatBack")
waitForChild(model.VehicleSeatBack, "BodyGyro")
waitForChild(model, "Bumper_Front")
waitForChild(model, "Bumper_Back")

local seat = model.VehicleSeat
local driverInSeat = false
local smoke = model.ExhaustPipe.Smoke
local fire = model.ExhaustPipe.Fire
local brake_L = model.Brakelight_Left
local brake_R = model.Brakelight_Right
local light_L = model.Headlight_Left
local light_R = model.Headlight_Right
local vehicleSeatBack = model.VehicleSeatBack
local gyro = vehicleSeatBack.BodyGyro
local backBumperForce = model.Bumper_Back.BodyForce
local frontBumperForce = model.Bumper_Front.BodyForce


-- SETTINGS
local brakeColor_on = BrickColor.new("Really red")
local brakeColor_off = BrickColor.new("Reddish brown")
local lightColor_on = BrickColor.new("Institutional white")
local lightColor_off = light_L.BrickColor
print("headlight off color will be " .. lightColor_off.Name)
local smokeOpacity_throttleOn = 0.5
local smokeOpacity_throttleOff = 0.1
local fireSize_big = 7
local fireSize_small = 3

function seatChildAddedHandler(child)
	if child.Name=="SeatWeld" then
		print("Turn car ON")
		driverInSeat = true
		smoke.Enabled = true
		smoke.Opacity = smokeOpacity_throttleOff
		light_L.BrickColor = lightColor_on
		light_R.BrickColor = lightColor_on
		fire.Size = fireSize_big
		fire.Enabled = true
		wait(0.3)
		fire.Size = fireSize_small
		if seat.Throttle==0 then
			fire.Enabled = false
		end
	end
end

function seatChildRemovedHandler(child)
	if child.Name=="SeatWeld" then
		print("Turn car OFF")
		driverInSeat = false
		smoke.Enabled = false
		light_L.BrickColor = lightColor_off
		light_R.BrickColor = lightColor_off
	end
end

function showBigFire()
	fire.Size = fireSize_big
	fire.Enabled = true
	wait(0.3)
	if seat.Throttle==1 then
		fire.Size = fireSize_small
	end
	wait(1)
	if seat.Throttle==1 then
		fire.Enabled = false
	end
end

local tiltForce = 84000
local tiltTime = 1
function tiltJeepBack()
	print("tiltJeepBack()")
	wait(tiltTime)
end

function tiltJeepForward()
	print("tiltJeepForward()")
	wait(tiltTime)
end

function seatChangedHandler(prop)
	if prop=="Throttle" then
		if seat.Throttle==1 then
			-- Throttle Forward
			brake_L.BrickColor = brakeColor_off
			brake_R.BrickColor = brakeColor_off
			smoke.Opacity = smokeOpacity_throttleOn
			local co = coroutine.create(showBigFire)
			coroutine.resume(co)
			local co2 = coroutine.create(tiltJeepBack)
			coroutine.resume(co2)
		elseif seat.Throttle==0 then
			-- Throttle Off
			brake_L.BrickColor = brakeColor_on
			brake_R.BrickColor = brakeColor_on
			smoke.Opacity = smokeOpacity_throttleOff
			fire.Enabled = false
			wait(0.9)
			if brake_L.BrickColor==brakeColor_on then
				brake_L.BrickColor = brakeColor_off
			end
			if brake_R.BrickColor==brakeColor_on then
				brake_R.BrickColor = brakeColor_off
			end
		elseif seat.Throttle==-1 then
			-- Throttle Reverse
			brake_L.BrickColor = lightColor_on
			brake_R.BrickColor = lightColor_on
			smoke.Opacity = smokeOpacity_throttleOff
			fire.Enabled = false
			local co = coroutine.create(tiltJeepForward)
			coroutine.resume(co)
		end
	end
end

-- Set initial colors
light_L.BrickColor = lightColor_off
light_R.BrickColor = lightColor_off
brake_L.BrickColor = brakeColor_off
brake_R.BrickColor = brakeColor_off
smoke.Enabled = false
fire.Enabled = false

print("JeepScript: connecting events...")
seat.ChildAdded:connect(seatChildAddedHandler)
seat.ChildRemoved:connect(seatChildRemovedHandler)
seat.Changed:connect(seatChangedHandler)
print("JeepScript: events connected.")

while true do
	-- Every 15 seconds, poll if jeep has turned upside down.  If true, then flip back upright.
	if(vehicleSeatBack.CFrame.lookVector.y <= 0.707) then
		print("Jeep is flipped.  Flipping right side up...")
		gyro.cframe = CFrame.new( Vector3.new(0,0,0), Vector3.new(0,1,0) )
		gyro.maxTorque = Vector3.new(1000, 1000, 1000)
		wait(2)
		gyro.maxTorque = Vector3.new(0,0,0)
	end
	wait(8)
end
]]
	elseif v.Name == "SpikeScript" then
		source = [[-- useless comment

function onTouched(hit)
	if not hit or not hit.Parent then return end
	local human = hit.Parent:findFirstChild("Humanoid")
	if human and human:IsA("Humanoid") then		human:TakeDamage(100)
	end
end
script.Parent.Touched:connect(onTouched)]]
	elseif v:FindFirstChild("RemoteConnection") then
		source = [[--Made by Luckymaxer

Seat = script.Parent
Model = Seat.Parent

Engine = Model:WaitForChild("Engine")
BeamPart = Model:WaitForChild("BeamPart")
Lights = Model:WaitForChild("Lights")
Seats = Model:WaitForChild("Seats")

Sounds = {
	Flying = Engine:WaitForChild("UFO_Flying"),
	Beam = Engine:WaitForChild("UFO_Beam"),
	Idle = Engine:WaitForChild("UFO_Idle"),
	TakingOff = Engine:WaitForChild("UFO_Taking_Off")
}

Players = game:GetService("Players")
Debris = game:GetService("Debris")

BeamSize = 50
CurrentBeamSize = 0

MaxVelocity = 40
MinVelocity = -40

MaxSideVelocity = 40
MinSideVelocity = -40

Acceleration = 2
Deceleration = 2
AutoDeceleration = 2

SideAcceleration = 2
SideDeceleration = 2
AutoSideDeceleration = 2

LiftOffSpeed = 5
LiftSpeed = 10
LowerSpeed = -10

Velocity = Vector3.new(0, 0, 0)
SideVelocity = 0

FlipForce = 1000000

InUse = false
PlayerUsing = nil
PlayerControlScript = nil
PlayerConnection = nil
BeamActive = false
TakingOff = false

LightsEnabled = false

Enabled = false

Controls = {
	Forward = {Key = "W", Byte = 17, Mode = false},
	Backward = {Key = "S", Byte = 18, Mode = false},
	Left = {Key = "A", Byte = 20, Mode = false},
	Right = {Key = "D", Byte = 19, Mode = false},
	Up = {Key = "Q", Byte = 113, Mode = false},
	Down = {Key = "E", Byte = 101, Mode = false},
}

ControlScript = script:WaitForChild("ControlScript")

Beam = Instance.new("Part")
Beam.Name = "Beam"
Beam.Transparency = 0.3
Beam.BrickColor = BrickColor.new("Pastel Blue")
Beam.Material = Enum.Material.Plastic
Beam.Shape = Enum.PartType.Block
Beam.TopSurface = Enum.SurfaceType.Smooth
Beam.BottomSurface = Enum.SurfaceType.Smooth
Beam.FormFactor = Enum.FormFactor.Custom
Beam.Size = Vector3.new(BeamPart.Size.X, 0.2, BeamPart.Size.Z)
Beam.Anchored = false
Beam.CanCollide = false
BeamMesh = Instance.new("CylinderMesh")
BeamMesh.Parent = Beam

for i, v in pairs(Sounds) do
	v:Stop()
end

RemoteConnection = script:FindFirstChild("RemoteConnection")
if not RemoteConnection then
	RemoteConnection = Instance.new("RemoteFunction")
	RemoteConnection.Name = "RemoteConnection"
	RemoteConnection.Parent = script
end

BodyGyro = Engine:FindFirstChild("BodyGyro")
if not BodyGyro then
	BodyGyro = Instance.new("BodyGyro")
	BodyGyro.Parent = Engine
end
BodyGyro.maxTorque = Vector3.new(0, 0, 0)
BodyGyro.D = 7500
BodyGyro.P = 10000

BodyPosition = Engine:FindFirstChild("BodyPosition")
if not BodyPosition then
	BodyPosition = Instance.new("BodyPosition")
	BodyPosition.Parent = Engine
end
BodyPosition.maxForce = Vector3.new(0, 0, 0)
BodyPosition.D = 10000
BodyPosition.P = 50000

BodyVelocity = Engine:FindFirstChild("BodyVelocity")
if not BodyVelocity then
	BodyVelocity = Instance.new("BodyVelocity")
	BodyVelocity.Parent = Engine
end
BodyVelocity.velocity = Vector3.new(0, 0, 0)
BodyVelocity.maxForce = Vector3.new(0, 0, 0)
BodyVelocity.P = 10000

FlipGyro = BeamPart:FindFirstChild("FlipGyro")
if not FlipGyro then
	FlipGyro = Instance.new("BodyGyro")
	FlipGyro.Name = "FlipGyro"
	FlipGyro.Parent = BeamPart
end
FlipGyro.maxTorque = Vector3.new(0, 0, 0)
FlipGyro.D = 500
FlipGyro.P = 3000

RiseVelocity = BeamPart:FindFirstChild("RiseVelocity")
if not RiseVelocity then
	RiseVelocity = Instance.new("BodyVelocity")
	RiseVelocity.Name = "RiseVelocity"
	RiseVelocity.Parent = BeamPart
end
RiseVelocity.velocity = Vector3.new(0, 0, 0)
RiseVelocity.maxForce = Vector3.new(0, 0, 0)
RiseVelocity.P = 10000

function RayCast(Position, Direction, MaxDistance, IgnoreList)
	return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(Position, Direction.unit * (MaxDistance or 999.999)), IgnoreList) 
end

function ToggleLights()
	for i, v in pairs(Lights:GetChildren()) do
		if v:IsA("BasePart") then
			for ii, vv in pairs(v:GetChildren()) do
				if vv:IsA("Light") then
					vv.Enabled = LightsEnabled
				end
			end
		end
	end
end

ToggleLights()

function CheckTable(Table, Instance)
	for i, v in pairs(Table) do
		if v == Instance then
			return true
		end
	end
	return false
end

function RandomizeTable(Table)
	local TableCopy = {}
	for i = 1, #Table do
		local Index = math.random(1, #Table)
		table.insert(TableCopy, Table[Index])
		table.remove(Table, Index)
	end
	return TableCopy
end

for i, v in pairs(Model:GetChildren()) do
	if v:IsA("BasePart") and v.Name == "Beam" then
		v:Destroy()
	end
end

function GetPartsInBeam(beam)
	local IgnoreObjects = {(((PlayerUsing and PlayerUsing.Character) and PlayerUsing.Character) or nil), Model}
	local NegativePartRadius = Vector3.new((beam.Size.X / 2), ((CurrentBeamSize / 5) / 2), (beam.Size.Z / 2))
	local PositivePartRadius = Vector3.new((beam.Size.X / 2), ((CurrentBeamSize / 5) / 2), (beam.Size.Z / 2))
	local Parts = game:GetService("Workspace"):FindPartsInRegion3WithIgnoreList(Region3.new(beam.Position - NegativePartRadius, beam.Position + PositivePartRadius), IgnoreObjects, 100)
	local Humanoids = {}
	local Torsos = {}
	for i, v in pairs(Parts) do
		if v and v.Parent then
			local humanoid = v.Parent:FindFirstChild("Humanoid")
			local torso = v.Parent:FindFirstChild("Torso")
			local player = Players:GetPlayerFromCharacter(v.Parent)
			if player and humanoid and humanoid.Health > 0 and torso and not CheckTable(Humanoids, humanoid) then
				table.insert(Humanoids, humanoid)
				table.insert(Torsos, {Humanoid = humanoid, Torso = torso})
			end
		end
	end
	return Torsos
end

RemoteConnection.OnServerInvoke = (function(Player, Script, Action, Value)
	if Script and Script ~= PlayerControlScript then
		Script.Disabled = true
		Script:Destroy()
	else
		if Action == "KeyDown" then
			if Value == "l" then
				LightsEnabled = not LightsEnabled
				ToggleLights()
			elseif Value == "t" then
				if TemporaryBeam and TemporaryBeam.Parent then
					local Torsos = GetPartsInBeam(TemporaryBeam)
					local TorsosUsed = {}
					Torsos = RandomizeTable(Torsos)
					for i, v in pairs(Seats:GetChildren()) do
						if v:IsA("Seat") and not v:FindFirstChild("SeatWeld") then
							for ii, vv in pairs(Torsos) do
								if vv.Humanoid and vv.Humanoid.Parent and vv.Humanoid.Health > 0 and not vv.Humanoid.Sit and vv.Torso and vv.Torso.Parent and not CheckTable(TorsosUsed, vv.Torso) then
									table.insert(TorsosUsed, vv.Torso)
									vv.Torso.CFrame = v.CFrame
									break
								end
							end
						end
					end
				end
			end
			if not TakingOff then
				for i, v in pairs(Controls) do
					if string.lower(v.Key) == string.lower(Value) or v.Byte == string.byte(Value) then
						v.Mode = true
					end
				end
				if Controls.Up.Mode or Controls.Down.Mode then
					RiseVelocity.maxForce = Vector3.new(0, 1000000, 0)
				end
				if Controls.Forward.Mode or Controls.Backward.Mode or Controls.Left.Mode or Controls.Right.Mode or Controls.Up.Mode or Controls.Down.Mode then
					Sounds.Idle:Stop()
					Sounds.Flying:Play()
				end
			end
		elseif Action == "KeyUp" then
			if not TakingOff then
				for i, v in pairs(Controls) do
					if string.lower(v.Key) == string.lower(Value) or v.Byte == string.byte(Value) then
						v.Mode = false
					end
				end
				if not Controls.Up.Mode and not Controls.Down.Mode then
					BodyPosition.position = Engine.Position
					BodyPosition.maxForce = Vector3.new(0, 100000000, 0)
					RiseVelocity.maxForce = Vector3.new(0, 0, 0)
					RiseVelocity.velocity = Vector3.new(0, 0, 0)
				end
				if not Controls.Forward.Mode and not Controls.Backward.Mode and not Controls.Left.Mode and not Controls.Right.Mode and not Controls.Up.Mode and not Controls.Down.Mode then
					Sounds.Flying:Stop()
					Sounds.Idle:Play()
				end
			end
		elseif Action == "Button1Down" then
			if not BeamActive and not TakingOff then
				BeamActive = true
				if TemporaryBeam and TemporaryBeam.Parent then
					TemporaryBeam:Destroy()
				end
				TemporaryBeam = Beam:Clone()
				TemporaryBeam.Parent = Model
				Spawn(function()
					while TemporaryBeam and TemporaryBeam.Parent do
						local Torsos = GetPartsInBeam(TemporaryBeam)
						for i, v in pairs(Torsos) do
							if v.Humanoid and v.Humanoid.Parent and v.Humanoid.Health > 0 and v.Torso and v.Torso.Parent and not v.Torso:FindFirstChild("UFOPullForce") and not v.Torso:FindFirstChild("UFOBalanceForce") then
								local UFOPullForce = Instance.new("BodyVelocity")
								UFOPullForce.Name = "UFOPullForce"
								UFOPullForce.maxForce = Vector3.new(0, 1000000, 0)
								UFOPullForce.velocity = CFrame.new(v.Torso.Position, BeamPart.Position).lookVector * 25
								Debris:AddItem(UFOPullForce, 0.25)
								UFOPullForce.Parent = v.Torso
								local UFOBalanceForce = Instance.new("BodyGyro")
								UFOBalanceForce.Name = "UFOBalanceForce"
								UFOBalanceForce.maxTorque = Vector3.new(1000000, 0, 1000000)
								Debris:AddItem(UFOBalanceForce, 0.25)
								UFOBalanceForce.Parent = v.Torso
							end
						end
						wait()
					end
				end)
				local BeamWeld = Instance.new("Weld")
				BeamWeld.Part0 = BeamPart
				BeamWeld.Part1 = TemporaryBeam
				Spawn(function()
					Sounds.Beam:Play()
					while Enabled and BeamActive and TemporaryBeam and TemporaryBeam.Parent do
						local IgnoreTable = {Model}
						for i, v in pairs(Players:GetChildren()) do
							if v:IsA("Player") and v.Character then
								table.insert(IgnoreTable, v.Character)
							end
						end
						local BeamPartClone = BeamPart:Clone()
						local BeamPartCloneY = BeamPartClone:Clone()
						BeamPartCloneY.CFrame = BeamPartCloneY.CFrame * CFrame.Angles(-math.rad(90), 0, 0)		
						BeamPartCloneY.CFrame = BeamPartCloneY.CFrame - BeamPartCloneY.CFrame.lookVector * ((BeamPart.Size.Y / 2))
						local Hit, Position = RayCast(BeamPart.Position, BeamPartCloneY.CFrame.lookVector, BeamSize, IgnoreTable)
						CurrentBeamSize = ((BeamPart.Position - Position).magnitude * 5)
						TemporaryBeam.Mesh.Scale = Vector3.new(1, CurrentBeamSize, 1)
						BeamWeld.Parent = TemporaryBeam
						BeamWeld.C0 = CFrame.new(0, 0, 0) - Vector3.new(0, ((CurrentBeamSize / 2) + (BeamPart.Size.Y / 2)) / 5 , 0)
						wait()
					end
					BeamActive = false
					Sounds.Beam:Stop()
					if TemporaryBeam and TemporaryBeam.Parent then
						TemporaryBeam:Destroy()
					end
				end)
			end
		elseif Action == "Button1Up" then
			BeamActive = false
		end
	end
end)

function ManageMotionStep(ForceLift, CoordinateFrame)
	
	local CameraForwards = -CoordinateFrame:vectorToWorldSpace(Vector3.new(0, 0, 1))
	local CameraSideways = -CoordinateFrame:vectorToWorldSpace(Vector3.new(1, 0, 0))
	local CameraRotation = -CoordinateFrame:vectorToWorldSpace(Vector3.new(0, 1, 0))

	CameraForwards = CameraForwards * Vector3.new(1, 0, 1)
	CameraSideways = CameraSideways * Vector3.new(1, 0, 1)

	if CameraForwards:Dot(CameraForwards) < 0.1 or CameraSideways:Dot(CameraSideways) < 0.1 then
		return
	end
	
	CameraForwards = CameraForwards.unit
	CameraSideways = CameraSideways.unit

	if math.abs(Velocity.X) < 2 and math.abs(Velocity.Z) < 2 then
		BodyVelocity.velocity = Vector3.new(0, 0, 0)
	else
		BodyVelocity.velocity = Velocity
	end
	BodyGyro.cframe = CFrame.new(0, 0, 0) * CFrame.Angles(Velocity:Dot(Vector3.new(0, 0, 1)) * (math.pi / 320), 0, math.pi - Velocity:Dot(Vector3.new(1, 0, 0)) * (math.pi / 320))
	if Controls.Forward.Mode and (not Controls.Backward.Mode) and Velocity:Dot(CameraForwards) < MaxVelocity then
		Velocity = Velocity + Acceleration * CameraForwards
	elseif Controls.Backward.Mode and (not Controls.Forward.Mode) and Velocity:Dot(CameraForwards) > MinVelocity then
		Velocity = Velocity - Deceleration * CameraForwards
	elseif (not Controls.Backward.Mode) and (not Controls.Forward.Mode) and Velocity:Dot(CameraForwards) > 0 then
		Velocity = Velocity - AutoDeceleration * CameraForwards
	elseif (not Controls.Backward.Mode) and (not Controls.Forward.Mode) and Velocity:Dot(CameraForwards) < 0 then
		Velocity = Velocity + AutoDeceleration * CameraForwards
	end

	if Controls.Left.Mode and (not Controls.Right.Mode) and Velocity:Dot(CameraSideways) < MaxSideVelocity then
		Velocity = Velocity + SideAcceleration * CameraSideways
	elseif Controls.Right.Mode and (not Controls.Left.Mode) and Velocity:Dot(CameraSideways) > MinSideVelocity then
		Velocity = Velocity - SideDeceleration * CameraSideways
	elseif (not Controls.Right.Mode) and (not Controls.Left.Mode) and Velocity:Dot(CameraSideways) > 0 then
		Velocity = Velocity - AutoSideDeceleration * CameraSideways
	elseif (not Controls.Right.Mode) and (not Controls.Left.Mode) and Velocity:Dot(CameraSideways) < 0 then
		Velocity = Velocity + AutoSideDeceleration * CameraSideways
	end

	if ForceLift then
		RiseVelocity.velocity = Vector3.new(0, LiftOffSpeed, 0)
	else
		if Controls.Up.Mode and (not Controls.Down.Mode) then
			RiseVelocity.velocity = Vector3.new(0, LiftSpeed, 0)
			BodyPosition.maxForce = Vector3.new(0, 0, 0)
		elseif Controls.Down.Mode and (not Controls.Up.Mode) then
			RiseVelocity.velocity = Vector3.new(0, LowerSpeed, 0)
			BodyPosition.maxForce = Vector3.new(0, 0, 0)
		end
	end
	
end

function MotionManager()
	Spawn(function()
		TakingOff = true
		RiseVelocity.maxForce = Vector3.new(0, 1000000, 0)
		local StartTime = tick()
		Sounds.TakingOff:Play()
		while Enabled and PlayerConnection and (tick() - StartTime) < 3 do
			local CoordinateFrame = PlayerConnection:InvokeClient(PlayerUsing, "CoordinateFrame")
			ManageMotionStep(true, CoordinateFrame)
			wait()
		end
		TakingOff = false
		Sounds.TakingOff:Stop()
		while PlayerConnection and (Enabled or Velocity:Dot(Velocity) > 0.5) do
			local CoordinateFrame = PlayerConnection:InvokeClient(PlayerUsing, "CoordinateFrame")
			ManageMotionStep(false, CoordinateFrame)
			wait()
		end
	end)
end

function LiftOff()
	
	BodyGyro.maxTorque = Vector3.new(1000000, 1000000, 1000000)
	BodyVelocity.maxForce = Vector3.new(1000000, 0, 1000000)
	
	Velocity = Vector3.new(0, 0, 0)

	Enabled = true
	
	MotionManager()

end

function Equipped(Player)
	local Backpack = Player:FindFirstChild("Backpack")
	if Backpack then
		InUse = true
		PlayerUsing = Player
		PlayerControlScript = ControlScript:Clone()
		local RemoteController = Instance.new("ObjectValue")
		RemoteController.Name = "RemoteController"
		RemoteController.Value = RemoteConnection
		RemoteController.Parent = PlayerControlScript
		local VehicleSeat = Instance.new("ObjectValue")
		VehicleSeat.Name = "VehicleSeat"
		VehicleSeat.Value = Seat
		VehicleSeat.Parent = PlayerControlScript
		PlayerConnection = Instance.new("RemoteFunction")
		PlayerConnection.Name = "PlayerConnection"
		PlayerConnection.Parent = PlayerControlScript
		PlayerControlScript.Disabled = false
		PlayerControlScript.Parent = Backpack
		LiftOff()
	end
end

function Unequipped()
	if PlayerControlScript and PlayerControlScript.Parent then
		PlayerControlScript:Destroy()
	end
	Enabled = false
	PlayerControlScript = nil
	PlayerUsing = nil
	PlayerConnection = nil
	BeamActive = false
	TakingOff = false
	InUse = false
	BodyGyro.maxTorque = Vector3.new(0, 0, 0)
	BodyPosition.maxForce = Vector3.new(0, 0, 0)
	BodyVelocity.maxForce = Vector3.new(0, 0, 0)
	BodyVelocity.velocity = Vector3.new(0, 0, 0)
	RiseVelocity.maxForce = Vector3.new(0, 0, 0)
	RiseVelocity.velocity = Vector3.new(0, 0, 0)
	for i, v in pairs(Controls) do
		v.Mode = false
	end
end

function Flip()
	local EngineCloneY = Engine:Clone()
	EngineCloneY.CFrame = EngineCloneY.CFrame * CFrame.Angles(-math.rad(90), 0, 0)
	if EngineCloneY.CFrame.lookVector.Y < 0.707 then
		FlipGyro.cframe = CFrame.new(Vector3.new(0, 0, 0), Vector3.new(0, 1, 0)) * CFrame.Angles((-math.pi / 2), 0, 0)
		FlipGyro.maxTorque = Vector3.new(FlipForce, FlipForce, FlipForce)
		wait(2)
		FlipGyro.maxTorque = Vector3.new(0,0,0)
	end
end

Seat.ChildAdded:connect(function(Child)
	if Child:IsA("Weld") and Child.Name == "SeatWeld" then
		if Child.Part0 and Child.Part0 == Seat and Child.Part1 and Child.Part1.Parent then
			local Player = Players:GetPlayerFromCharacter(Child.Part1.Parent)
			if Player then
				Equipped(Player)
			end
		end
	end
end)

Seat.ChildRemoved:connect(function(Child)
	if Child:IsA("Weld") and Child.Name == "SeatWeld" then
		if Child.Part0 and Child.Part0 == Seat and Child.Part1 and Child.Part1.Parent then
			local Player = Players:GetPlayerFromCharacter(Child.Part1.Parent)
			if Player and Player == PlayerUsing then
				Unequipped(Player)
			end
		end
	end
end)

Spawn(function()
	while true do
		Flip()
		wait(5)
	end
end)]]
	elseif v.Parent:FindFirstChild("AnchoredParts") then
		source = [[script.Parent.Base.BodyGyro.cframe = script.Parent.Base.CFrame
		script.Parent.Base.Anchored = false]]
	elseif v.Name == "RegenerateHealth" then
		source = [[--Made by Luckymaxer

Figure = script.Parent

Humanoid = Figure:WaitForChild("Humanoid")

Regenerating = false

function RegenerateHealth()
	if Regenerating then
		return
	end
	Regenerating = true
	while Humanoid.Health < Humanoid.MaxHealth do
		local Second = wait(1)
		local Health = Humanoid.Health
		if Health > 0 and Health < Humanoid.MaxHealth then
			local NewHealthDelta = (0.01 * Second * Humanoid.MaxHealth)
			Health = (Health + NewHealthDelta)
			Humanoid.Health = math.min(Health, Humanoid.MaxHealth)
		end
	end
	if Humanoid.Health > Humanoid.MaxHealth then
		Humanoid.Health = Humanoid.MaxHealth
	end
	Regenerating = false
end

Humanoid.HealthChanged:connect(RegenerateHealth)  ]]
	elseif v.Name == "AlienAIScript" then
		source = [[local zombie = script.Parent 

while zombie:FindFirstChild("ParentTag") == nil do 
	wait()
end

while zombie:FindFirstChild("Humanoid") == nil or zombie:FindFirstChild("Torso") == nil do 
	wait()
end

local zombieHumanoid = zombie.Humanoid
local zombieTorso = zombie.Torso

local parentTag = zombie.ParentTag
local summoner = parentTag.Value 

local summonerTorso = summoner:FindFirstChild("Torso")
local summonerHumanoid = summoner:FindFirstChild("Humanoid")

function bite(hit)
	if hit and hit.Parent and hit.Parent.Name ~= "Zombie" then 		
		local humanoid = hit.Parent:FindFirstChild("Humanoid") 
		if humanoid and humanoid ~= zombieHumanoid and zombieHumanoid ~= nil and humanoid.Health > 0 and humanoid ~= summonerHumanoid then 			
			humanoid:TakeDamage(15)			
		end
	end
end

zombieTorso.Touched:connect(bite)

while zombieHumanoid.Health < 250 do 
	zombieHumanoid.Health = 250 
	wait()
end 

local targetEnemyTorso = nil

local checkAOE = Vector3.new(15, 15, 15)

while true do 
	if summoner == nil or summonerTorso == nil then zombie:Remove() end 
	local ray = game.Workspace:FindPartOnRay(Ray.new(zombieTorso.Position + Vector3.new(0, -2, 0),  zombieTorso.CFrame.lookVector * 5.0), nil)
	if ray and zombieHumanoid then 
		zombieHumanoid.Jump = true 
	end
	if targetEnemyTorso == nil then				
		local parts = game.Workspace:FindPartsInRegion3(Region3.new(zombieTorso.Position - checkAOE, zombieTorso.Position + checkAOE), summoner, 100)
		for i = 1, #parts do 
			if parts[i] and parts[i].Parent then 
				local character = parts[i].Parent 
				if character ~= zombie and character.Name ~= "Zombie" and character:FindFirstChild("Torso") and character:FindFirstChild("Humanoid") then 
					targetEnemyTorso = character.Torso					
				end
			end
		end
	end
	if targetEnemyTorso then 		
		local distance = (targetEnemyTorso.Position - zombieTorso.Position).magnitude
		local targetEnemy = targetEnemyTorso.Parent 
		local targetEnemyHumanoid = targetEnemy:FindFirstChild("Humanoid")
		if distance < 20 and targetEnemyHumanoid and targetEnemyHumanoid.Health > 0 then
			zombie.Humanoid:MoveTo(targetEnemyTorso.Position, targetEnemyTorso) 		
		else 
			targetEnemyTorso = nil
			if summoner and summonerTorso then 
				zombie.Humanoid:MoveTo(summonerTorso.Position + (CFrame.Angles(0, math.random(1, 4) * math.pi/4, 0) * summonerTorso.CFrame.lookVector * 4.0), summonerTorso) 
			else 
				if zombie then zombie:Remove()  end
			end
		end
	else 
		targetEnemyTorso = nil
		if summoner and summonerTorso then 	
			tick()
			zombie.Humanoid:MoveTo(summonerTorso.Position + (CFrame.Angles(0, math.random(1, 4) * math.pi/4, 0) * summonerTorso.CFrame.lookVector * math.random(2.0, 6.0)), summonerTorso) 
		else 
			if zombie then zombie:Remove()  end
		end	
	end
	wait(0.1) 
end

]]
	elseif v.Name == "UFOScript" then
		source = [[local seat = script.Parent
local vChar = nil
local vPlayer = nil
local driveTool = nil

local rayBeam = seat.Parent.RayBeam

function waitForChild(parent, child)
	while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
end

-- fix rayBeam to be right size and transparent
waitForChild(seat.Parent, "btm")
waitForChild(seat.Parent.btm, "rayWeld")

local rayWeld = seat.Parent.btm.rayWeld
rayWeld.Parent = nil
rayBeam.Size = Vector3.new(2, 53.2, 2)
rayWeld.Parent = seat.Parent.btm
rayWeld.C0 = rayWeld.C0 - rayWeld.C0.p + Vector3.new(-4, 0.5, 4)

rayBeam.Transparency = 1

function bindToNewPlayer()
 vPlayer = game.Players:GetPlayerFromCharacter(vChar)

 if vPlayer then
  -- remove motion damper script
  local motionDamper = seat.Parent.btm:FindFirstChild("MotionDamper")
  if motionDamper then motionDamper:Remove() end

  -- copy over UFO drive tool
  --driveTool = script.UFODriveTool:Clone()
  driveToolClone = script.UFODriveTool:Clone()
  driveTool = script.UFODriveTool

  local newHandle = Instance.new("Part")
  newHandle.Size = Vector3.new(.1, .1, .1)
  newHandle.Transparency = 1
  newHandle.Name = "Handle"
  newHandle.Parent = driveTool
  driveTool.UFOPointer.Value = seat.Parent

  -- remove existing tools
  local vChildren = vChar:GetChildren()
  for i = 1, #vChildren do
   if vChildren[i]:IsA("Tool") then
    vChildren[i].Parent = vPlayer.Backpack
   end
  end

  -- give 'em the saucer tool!
  driveToolClone.Parent = script
  driveTool.Parent = vChar
 end
end

function checkAddChild(newChild)
	if newChild.Name == "SeatWeld" then
		if newChild.Part0 == seat then vChar = newChild.Part1.Parent
		else vChar = newChild.Part0.Parent end

		bindToNewPlayer()
	end
end

function checkRemoveChild(oldChild)
	if oldChild.Name == "SeatWeld" then
		vChar = nil
		vPlayer = nil
		driveTool:Remove()
		driveTool = nil

		local newMotionDamper = script.Parent.Parent.btm:FindFirstChild("MotionDamper")
		if newMotionDamper == nil then
			newMotionDamper = script.UFODriveTool.UFODriveScript.MotionDamper:Clone()
			newMotionDamper.Parent = script.Parent.Parent.btm
			newMotionDamper.Disabled = false
		end

		script.Parent.Parent.btm.UFOPosition.maxForce = Vector3.new(0, 0, 0)
		script.Parent.Parent.btm.UFOGyro.maxTorque = Vector3.new(0, 0, 0)

		rayBeam.Transparency = 1
	end
end


seat.ChildAdded:connect(checkAddChild)
seat.ChildRemoved:connect(checkRemoveChild)]]
	elseif v.Name == "MotionDamper" then
		source = [[local engine = script.Parent
local engineForce = engine.UFOVelocity

local autoDeceleration = .25

while engineForce.velocity:Dot(engineForce.velocity) > .05 do
	engineForce.velocity = engineForce.velocity - engineForce.velocity.unit * autoDeceleration
	wait()
end
]]
	elseif v.Name == "FlipUpright" then
		source = [[function waitForChild(instance, name)
	while not instance:FindFirstChild(name) do
		instance.ChildAdded:wait()
	end
end

local model = script.Parent
waitForChild(model, "VehicleSeatback")
local vehicleSeatback = model.VehicleSeatback
waitForChild(model, "VehicleSeat")
local vehicleSeat = model.VehicleSeat
waitForChild(vehicleSeat, "BodyGyro")
local gyro = vehicleSeat.BodyGyro

--------------------
local flipForce = 500
--------------------

while true do
	-- Every 15 seconds, poll if jeep has turned upside down.  If true, then flip back upright.
	if(vehicleSeatback.CFrame.lookVector.y <= 0.707) then
		print("UFO is flipped.  Flipping right side up...")
		gyro.cframe = CFrame.new( Vector3.new(0,0,0), Vector3.new(0,1,0) )
		gyro.maxTorque = Vector3.new(flipForce, flipForce, flipForce)
		wait(2)
		gyro.maxTorque = Vector3.new(0,0,0)
	end
	wait(8)
end
]]
	elseif v.Name == "Fountain 1" then
		source = [[local lifetime = 0.6

while true do
	wait(.1)
	local pos = script.Parent
	local b = Instance.new("Part")	

	b.Position = pos.Position + pos.CFrame.lookVector
	b.Size = Vector3.new(1, 1, 1)
	b.Shape = 0
        b.BrickColor=BrickColor.new("Bright blue")
	b.Transparency = 0.3
	b.TopSurface = "Smooth"
	b.BottomSurface = "Smooth"
	b.CanCollide = true
	b.Parent = game.Workspace
	b.Velocity = Vector3.new(1, 75, 1)
	game:GetService("Debris"):AddItem(b, lifetime)
end
]]
	elseif v.Name == "Fountain 2" then
		source = [[bin = script.Parent

function onTouched(part)
	part.BrickColor = BrickColor.new(26)
	wait(.3)
	part.Transparency = .2
	wait(.1)
	part.Transparency = .4
	wait(.1)
	part.Transparency = .6
	wait(.1)
	part.Transparency = .8
	wait(.1)
	part.Parent = nil
end

connection = bin.Touched:connect(onTouched)
]]
	elseif v.Name == "Flipper" and v.Parent.Name == "SkateboardPlatform" then
		source = [[local parts = script.Parent.Parent:GetChildren()
print("count" .. #parts)
local uprightCF = script.Parent.CFrame

local con = nil

function boardIsFlipped()
	local v1 = script.Parent.CFrame:vectorToWorldSpace(Vector3.FromNormalId(Enum.NormalId.Top))
	local v2 = Vector3.new(0,1,0)

	local ang = math.acos(v1:Dot(v2))

	return ang > 2
end

function onTouched(hit)

	if (hit.Parent ~= nil and hit.Parent:FindFirstChild("Humanoid") ~= nil) then
		if (script.Parent.Controller == nil) then
			if (boardIsFlipped()) then
				con:disconnect()
				con = nil

				print("FLIP IT")
				-- no one is riding this thing

				script.Parent.StickyWheels = false

				-- pin
				local bp = Instance.new("BodyPosition")
				bp.maxForce = Vector3.new(5e7,5e7,5e7)
				bp.position = script.Parent.Position + Vector3.new(0,4,0)
				bp.Parent = script.Parent

				-- flip
				local fg = Instance.new("BodyGyro")
				fg.maxTorque = Vector3.new(5e7,5e7,5e7)
				fg.cframe = uprightCF
				fg.Parent = script.Parent
				wait(1)
				fg:Remove()
				wait(1)
				bp:Remove()

				script.Parent.StickyWheels = true
			end
		end
	end
	wait(1)
	
	if (con == nil) then con = script.Parent.Touched:connect(onTouched) end
end

con = script.Parent.Touched:connect(onTouched)

while true do
	for i=1,#parts do
		if parts[i].className == "Part" and (script.Parent.Position - parts[i].Position).magnitude > 5 then
			script.Parent.Parent:Remove()
		end
	end
	wait(1)
end
]]
	elseif v.Name == "IdleDelete" then
		source = [[local Board = script.Parent

-- DISGUSTING. NEVER DO THIS.
function nearPlayer()
	local p = game.Players:GetPlayers()

	for i=1,#p do

		if (p[i].Character) then
			local t = p[i].Character:FindFirstChild("Torso")
			if t then
				if (Board.Position - t.Position).magnitude < 20 then
					return true
				end
			end
		end
	
	end
	return false

end

function sepuku()
	if not nearPlayer() then
		Board:Remove()
	end
end

while true do
	wait(30)
	sepuku()
end

]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("Weld") and v.Parent.Name == "Smooth Block Model" then
		source = [[while true do 
script.Parent.Color = Color3.new(math.random(), math.random(), math.random()) 
wait(2.0) 
end 
]]
	elseif v.Name == "WalkAndTalk" then
		source = [[function getRandomPhrase()
	local playerName = script.Parent.Target.Value.Parent.Name
	local phrases = {
		playerName:upper() .. " IS IN THIS SERVER!!1",
		"I MET " .. playerName:upper(),
		"give " .. playerName:lower() .. " some space!",
		"how did you get famous?",
		"omg " .. playerName .. " plz don8",
		"OMG LEAVE " .. playerName:upper() .. "ALONE",
		playerName:upper() .. "!!1",
		playerName .. " is just a normal person guys",
		"will u don8",
		"i am your biggest fan",
		"how much robux u got?",
		"plz join my group",
		"HOLY TELAMON ITS " .. playerName:upper(),
		"my brother loves ur game",
		"im putting this in my blurb",
		"second famous person i met 2day",
		"GIVE " .. playerName:upper() .. " SPACE!!",
		playerName:upper(),
		playerName:lower(),
		"no wonder famous people never talk",
		"do you talk?",
		"will you donate 100k R$ to me?",
		"come to my place i need to show u a glitch",
		"how much will u donate?",
		"i can't believe it's " .. playerName,
		"can u make me famous?",
		"are you afk?",
		"why wont you talk to me?",
		"famous ppl never donate",
		"famous people are greedy",
		playerName .. " do you donate?",
		"whats it like being a famous person?",
		"how much tix u got man?",
		"make me famous and ill give u 23 tix",
		"can i copy ur game?",
		"there are hackers at your game, plz ban them",
		"buy gear from my place",
		"can i take a screenshot?",
		"i am recording this lol"
	}
 	return phrases[math.random(#phrases)]
end

local function plusOrMinus(number)
	return math.random(number - 4, number + 4)	
end

local function randomize(v)
	return Vector3.new(plusOrMinus(v.X), plusOrMinus(v.Y), plusOrMinus(v.Z))
end

wait(math.random())
local walkspeed = script.Parent.Humanoid.WalkSpeed
local hum = script.Parent.Humanoid
local head = script.Parent.Head
local torso = script.Parent.Torso
local target = script.Parent.Target.Value
while true do
	if (torso.Position - target.Position).magnitude < 2 then
		hum.WalkSpeed = 0
	else
		hum.WalkSpeed = walkspeed
		hum:MoveTo(randomize(target.Position), target)
	end
	game:GetService("Chat"):Chat(head, getRandomPhrase())
	wait(1)
end]]
	elseif string.match(v.Name,"DispenserScript") then
		source = [[local dispenser = script.Parent
local asset = dispenser:FindFirstChild("Asset")
local gear 
local item 

local base = dispenser:FindFirstChild("FirePart")
local firePart = dispenser:FindFirstChild("FirePart")

local fake = dispenser:FindFirstChild("SwordThumbnailClone")
if fake then fake:Remove() end
local fire

local children = dispenser:GetChildren()
for i = 1, #children do 
	if children[i]:IsA("Tool") then 
		children[i]:Destroy() 
	end 
end 

local assetId 

function spawnGear()	
	gear = dispenser:FindFirstChild("Gear")
	if gear.Value == false then		
		item = game:GetService("InsertService"):LoadAsset(assetId)
		if item then 
			gear.Value = true
			item = item:GetChildren()[1] -- The first child is our tool
			if item then
				item.Parent = dispenser 
				item.AncestryChanged:connect(function() 
						if item.Parent and item.Handle then 
							item.Handle.CanCollide = true
							local float = item.Handle:FindFirstChild("FLOAT")
							local bav = item.Handle:FindFirstChild("BAV")
							local bp = item.Handle:FindFirstChild("BP")
							if float then float:Remove() end 
							if bav then bav:Remove() end
							if bp then bp:Remove() end
							if fire then fire:Remove() end
							wait(1.5) 
							gear.Value = false 
						end 
				end)
				if base then 
					item.Handle.CFrame = (base.CFrame + Vector3.new(0, 3, 0)) * CFrame.Angles(math.pi/2, 0, 0)
					local floatForce = Instance.new("BodyForce")
					floatForce.Name = "FLOAT"
					floatForce.force = Vector3.new(0, item.Handle:GetMass() * 196.1, 0) 
					floatForce.Parent = item.Handle

					local bp = Instance.new("BodyPosition")
					bp.Name = "BP"
					bp.maxForce = Vector3.new(500000, 500000, 500000)
					bp.P = 500000
					bp.position = item.Handle.Position
					bp.Parent = item.Handle

					local bav = Instance.new("BodyAngularVelocity")
					bav.Name = "BAV"
					bav.P = 700000
					bav.maxTorque = Vector3.new(0, bav.P, 0)
					bav.angularvelocity = Vector3.new(0, 100, 0)
					bav.Parent = item.Handle
					
					tick()
					fire = Instance.new("Fire")
					fire.Heat = 15
					fire.Size = 4
					fire.Color = Color3.new(math.random(1, 255)/255, math.random(1, 255)/255, math.random(1, 255)/255) 
					fire.SecondaryColor = Color3.new(math.random(1, 255)/255, math.random(1, 255)/255, math.random(1, 255)/255)
					fire.Parent = firePart
					
					item.Handle.CanCollide = false
				end
			end
		end
	else 
		-- do nothing
	end
end

if asset then 
	assetId = asset.Value
	while assetId do 		
		spawnGear()
		wait(25.0)
	end
end
]]
	elseif v.Name == "AutomaticUpdating" then
		source = [[local Tool = script.Parent.Parent;

function IsVersionOutdated(Version)
	-- Returns whether the given version of Building Tools is out of date

	-- Check most recent version number
	local AssetInfo = Game:GetService('MarketplaceService'):GetProductInfo(142785488, Enum.InfoType.Asset);
	local LatestMajorVersion, LatestMinorVersion, LatestPatchVersion = AssetInfo.Description:match '%[Version: ([0-9]+)%.([0-9]+)%.([0-9]+)%]';
	local CurrentMajorVersion, CurrentMinorVersion, CurrentPatchVersion = Version:match '([0-9]+)%.([0-9]+)%.([0-9]+)';

	-- Convert version data into numbers
	local LatestMajorVersion, LatestMinorVersion, LatestPatchVersion =
		tonumber(LatestMajorVersion), tonumber(LatestMinorVersion), tonumber(LatestPatchVersion);
	local CurrentMajorVersion, CurrentMinorVersion, CurrentPatchVersion =
		tonumber(CurrentMajorVersion), tonumber(CurrentMinorVersion), tonumber(CurrentPatchVersion);

	-- Determine whether current version is outdated
	if LatestMajorVersion > CurrentMajorVersion then
		return true;
	elseif LatestMajorVersion == CurrentMajorVersion then
		if LatestMinorVersion > CurrentMinorVersion then
			return true;
		elseif LatestMinorVersion == CurrentMinorVersion then
			return LatestPatchVersion > CurrentPatchVersion;
		end;
	end;

	-- Return an up-to-date status if not oudated
	return false;

end;

-- Ensure tool mode is enabled, auto-updating is enabled, and version is outdated
if not (Tool:IsA 'Tool' and Tool.AutoUpdate.Value and IsVersionOutdated(Tool.Version.Value)) then
	return;
end;

-- Use module to insert latest tool
local GetLatestTool = require(580330877);
if not GetLatestTool then
	return;
end;

-- Get latest copy of tool
local NewTool = GetLatestTool();
if NewTool then

	-- Prevent update attempt loops since fetched version is now cached
	NewTool.AutoUpdate.Value = false;

	-- Cancel replacing current tool if fetched version is the same
	if NewTool.Version.Value == Tool.Version.Value then
		return;
	end;

	-- Detach update script from tool and save old tool parent
	script.Parent = nil;
	local ToolParent = Tool.Parent;

	-- Remove current tool (delayed to prevent parenting conflicts)
	wait(0.05);
	Tool.Parent = nil;

	-- Remove the tool again if anything attempts to reparent it
	Tool.Changed:Connect(function (Property)
		if Property == 'Parent' and Tool.Parent then
			wait(0.05);
			Tool.Parent = nil;
		end;
	end);

	-- Add the new tool
	NewTool.Parent = ToolParent;

end;]]
	elseif v.Name == "DescendantCounter" then
		source = [[local Count = script.Parent;
local Tool = Count.Parent.Parent;

-- Exclude counting autoremoving items (thumbnail and autoupdating script)
local AutoremovingItemsCount = 5 + 1;

-- Provide total count of all descendants
Count.Value = #Tool:GetDescendants() - AutoremovingItemsCount;]]
	elseif v.Name == "ServerEndpoint" then
		source = [[local ServerEndpoint = script.Parent;
local SyncAPI = ServerEndpoint.Parent;
local Tool = SyncAPI.Parent;

-- Start the server-side sync module
SyncModule = require(SyncAPI:WaitForChild 'SyncModule');

-- Provide functionality to the server API endpoint instance
ServerEndpoint.OnServerInvoke = function (Client, ...)
	return SyncModule.PerformAction(Client, ...);
end;]]
	elseif v.Name == "PluginInitializer" then
		source = [[if plugin then
    require(script.Parent)
end]]
	elseif v.Name == "Smooth Color Changing Script" then
		source = [[r = 255
g = 0
b = 0

while true do
	wait(0.005)
	
    while (r == 255 and g ~= 255) do
	wait(0.005)
	g = g + 1
	script.Parent.Color = Color3.fromRGB(r,g,b)
	end
	wait(0.005)
	r = r - 1
	script.Parent.Color = Color3.fromRGB(r,g,b)
	while (r ~= 0) do
	wait(0.005)
	r = r - 1
	script.Parent.Color = Color3.fromRGB(r,g,b)
	end

    while (g == 255 and b ~= 255) do
	wait(0.005)
	b = b + 1
	script.Parent.Color = Color3.fromRGB(r,g,b)
	end
	wait(0.005)
	g = g - 1
	script.Parent.Color = Color3.fromRGB(r,g,b)
	while (g ~= 0) do
	wait(0.005)
	g = g - 1
	script.Parent.Color = Color3.fromRGB(r,g,b)
	end
	
	while (b == 255 and r ~= 255) do
	wait(0.005)
	r = r + 1
	script.Parent.Color = Color3.fromRGB(r,g,b)
	end
	wait(0.005)
	b = b - 1
	script.Parent.Color = Color3.fromRGB(r,g,b)
	while (b ~= 0) do
	wait(0.005)
	b = b - 1
	script.Parent.Color = Color3.fromRGB(r,g,b)
	end
	
end]]
	elseif v.Name == "BerezaaGamesNuclearScript" then
		source = [[-- Fun nuke by berezaa
-- Credit to FriendlyBiscuit/eric for uploading the loopable alarm sound for me

wait(1)

script.Parent.Missle.Base.Anchored = true

debounce = false

script.Parent.Button.ClickDetector.MouseClick:connect(function()
	if debounce == false then
		debounce = true
		script.Parent.Button.Sound:Play()
		
		local siren = script.Parent.Button.Siren
		siren.Parent = workspace
		siren:Play()
		
		coroutine.resume(coroutine.create(function()
			local lights = script.Parent.Lights:GetChildren()
			for i=1,100 do
				for i,v in pairs(lights) do
					v.SpotLight.Enabled = true
				end
				wait(0.54)
				for i,v in pairs(lights) do
					v.SpotLight.Enabled = false
				end
				wait(0.54)			
			end
		end))
		
		wait(2)
		
		script.Parent.Missle.Base.Fire.Enabled = true
		script.Parent.Missle.Base.Smoke.Enabled = true
		
		wait(3)
		
		script.Parent.Missle.PrimaryPart = script.Parent.Missle.Base	
		for i=1,320 do
			script.Parent.Missle:SetPrimaryPartCFrame(script.Parent.Missle:GetPrimaryPartCFrame()+Vector3.new(0,0.05*((1.1^(i/5))/3),0))
			wait()
		end
		wait()
		for i=1,100 do
			script.Parent.Missle:SetPrimaryPartCFrame(script.Parent.Missle:GetPrimaryPartCFrame()+Vector3.new(0,0.05*(1.1^((250-i)/5)/3),0))
				script.Parent.Missle:SetPrimaryPartCFrame(script.Parent.Missle:GetPrimaryPartCFrame()*CFrame.Angles(0,math.pi/100,0))
				script.Parent.Missle:SetPrimaryPartCFrame(script.Parent.Missle:GetPrimaryPartCFrame()+Vector3.new(0,0,-i/100))	
			wait()
		end
		wait()
		for i=200,120,-1 do
			script.Parent.Missle:SetPrimaryPartCFrame(script.Parent.Missle:GetPrimaryPartCFrame()-Vector3.new(0,0.1*((1.1^(i/2.95))/4),0))
			wait()
		end	
		
		script.Parent.Missle.Tip.Transparency = 0.5
		script.Parent.Missle.Tip.CanCollide = false
		script.Parent.Missle.Tip.Mesh.Scale = Vector3.new(1,1,1)
		local boom = script.Parent.Button.Boom
		boom.Parent=workspace
		boom:Play()
		local frame = script.Parent.Missle.Tip.CFrame
		
		script.Parent.Missle.Tip.Boom.Disabled = false	
		
		for i=1,400 do
			script.Parent.Missle.Tip.Size=script.Parent.Missle.Tip.Size+Vector3.new(3,3,3)
			script.Parent.Missle.Tip.CFrame=frame
			wait()
		end
		script.Parent.Missle.Tip.Boom.Disabled=true
		script.Parent.Missle:Destroy()
		siren:Stop()
		boom:Stop()
		
		
	end
end)]]
	elseif v.Name == "Boom" and v.Parent.Name == "Tip" then
		source = [[while true do
c = game.Workspace:GetChildren()
for i =1,#c do
if ((c[i].className == "Part" or c[i].className == "TrussPart" or c[i].className == "WedgePart" or c[i].className == "Seat" or c[i].className == "VehicleSeat") and (c[i].Position - script.Parent.Position).magnitude < (script.Parent.Size.X / 2.1) - 5) then
if c[i].Locked == false then
c[i].Material = Enum.Material.CorrodedMetal
c[i].Anchored = false
c[i]:BreakJoints()
local miniboom = script.Parent.Parent.Parent.Button.SmallBoom:Clone()
miniboom.Parent=c[i]
miniboom:Play()
game.Debris:AddItem(miniboom,1)
end
end
if (c[i].className == "Model") then
end
g = c[i]:GetChildren()
for j =1,#g do
if ((g[j].className == "Part" or g[j].className == "TrussPart" or g[j].className == "WedgePart" or g[j].className == "Seat" or g[j].className == "VehicleSeat") and g[j].Name ~= script.Parent.Name and g[j].Name ~= "Glow" and (g[j].Position - script.Parent.Position).magnitude < (script.Parent.Size.X / 2.1) - 5) then
g[j].Material = Enum.Material.CorrodedMetal
g[j].Anchored = false
g[j]:BreakJoints()
local miniboom = script.Parent.Parent.Parent.Button.SmallBoom:Clone()
miniboom.Parent=c[i]
miniboom:Play()
game.Debris:AddItem(miniboom,1)
end
if (g[j].className == "Model") then
end
t = g[j]:GetChildren()
for s =1,#t do
if ((t[s].className == "Part" or t[s].className == "TrussPart" or t[s].className == "WedgePart" or t[s].className == "Seat" or t[s].className == "VehicleSeat") and t[s].Name ~= script.Parent.Name and t[s].Name ~= "Glow" and (t[s].Position - script.Parent.Position).magnitude < (script.Parent.Size.X / 2.1) - 5) then
t[s].Material = Enum.Material.CorrodedMetal
t[s].Anchored = false
t[s]:BreakJoints()
end
if (t[s].className == "Model") then
end
a = t[s]:GetChildren()
for z =1,#a do
if ((a[z].className == "Part" or a[z].className == "TrussPart" or a[z].className == "WedgePart" or a[z].className == "Seat" or a[z].className == "VehicleSeat") and a[z].Name ~= script.Parent.Name and a[z].Name ~= "Glow" and (a[z].Position - script.Parent.Position).magnitude < (script.Parent.Size.X / 2.1) - 5) then
a[z].Material = Enum.Material.CorrodedMetal
a[z].Anchored = false
a[z]:BreakJoints()
end
if (a[z].className == "Model") then
end
p = a[z]:GetChildren()
for l =1,#p do
if ((p[l].className == "Part" or p[l].className == "TrussPart" or p[l].className == "WedgePart" or p[l].className == "Seat" or p[l].className == "VehicleSeat") and p[l].Name ~= script.Parent.Name and p[l].Name ~= "Glow" and (p[l].Position - script.Parent.Position).magnitude < (script.Parent.Size.X / 2.1) - 5) then
p[l].Material = Enum.Material.CorrodedMetal
p[l].Anchored = false
p[l]:BreakJoints()
end
end
end
end
end
end
wait(.3)
end
]]
	elseif v.Name == "TeleporterScript" then
		source = [[local buttons = {}
local doors = {}
local teleports = {}
local running = false
local opening = false

function CheckChildren(obj)
	for i, v in pairs(obj:GetChildren()) do
		if v.Name == "Doors" then
			table.insert(doors, v)
		elseif v.Name == "Button" then
			table.insert(buttons, v)
		elseif v.Name == "Teleport" then
			table.insert(teleports, v)
		end
		CheckChildren(v)
	end
end

CheckChildren(script.Parent)

function openDoors()
	if not opening then
		opening = true
		for i, v in pairs(buttons) do
			v.DoorSound:Play()
		end
		for i = 1, 37 do
			for i, v in pairs(doors) do
				v.LeftDoor:SetPrimaryPartCFrame(v.LeftDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(2), 0))
				v.RightDoor:SetPrimaryPartCFrame(v.RightDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(-2), 0))
			end
			wait()
		end
		running = false
	end
	opening = false
end

function closeDoors()
	for i = 1, 37 do
		for i, v in pairs(buttons) do
			v.DoorSound:Play()
		end
		for i, v in pairs(doors) do
			v.LeftDoor:SetPrimaryPartCFrame(v.LeftDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(-2), 0))
			v.RightDoor:SetPrimaryPartCFrame(v.RightDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(2), 0))
		end
		wait()
	end
end

function moveChars(teleport)
	local p = teleport.Parent.Floor.Position
	local region = Region3.new(p - Vector3.new(2.2, 0, 2.2), p + Vector3.new(2.2, 7, 2.2))
	local parts = workspace:FindPartsInRegion3(region, nil, math.huge)
	local chars = {}
	
	for _, v in pairs(parts) do
		if v.Parent:FindFirstChild("Humanoid") then
			local match = false
			for i, c in pairs(chars) do
				if chars[i] == v.Parent then
					match = true
				end
			end
			if not match then
				table.insert(chars, v.Parent)
			end
		end
	end	
	
	for i = 0, 1, 0.05 do
		for _, v in pairs(chars) do
			for x, c in pairs(v:GetChildren()) do
				if c:IsA("BasePart") and c.Name ~= "HumanoidRootPart" then
					c.Transparency = i
				elseif c:FindFirstChild("Handle") then
					c.Handle.Transparency = i
				end
			end
		end
		wait()
	end
	
	local newTeleport
	for i, v in pairs(teleports) do
		if v ~= teleport then
			newTeleport = v
		end
	end
	local posA = teleport.Parent.Floor.Position
	local posB = newTeleport.Parent.Floor.Position
	local offset = posB - posA
	print(offset)
	
	for _, v in pairs(chars) do
		v:TranslateBy(offset)
	end
	
	for i = 1, 0, -0.05 do
		for _, v in pairs(chars) do
			for x, c in pairs(v:GetChildren()) do
				if c:IsA("BasePart") and c.Name ~= "HumanoidRootPart" then
					c.Transparency = i
				elseif c:FindFirstChild("Handle") then
					c.Handle.Transparency = i
				end
			end
		end
		wait()
	end
end

function runEffect(teleport)
	local emitters = {}
	local t = 100 -- delay timer
	local maxP = 50 -- max particles
	local n = 240 -- number of iterations for startup and cooldown
	local r = 100 -- run time at full speed
	
	for i, v in pairs(teleport:GetChildren()) do
		if v:FindFirstChild("ParticleEmitter") then
			table.insert(emitters, v)
		end
	end
	
	for i = 1, n do
		teleport:SetPrimaryPartCFrame(teleport.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(i/10), 0))
		for e = 1, 4 do
			emitters[e].Transparency = math.max((t-i)/t, 0)
			emitters[e].ParticleEmitter.Rate = math.min(i - t, maxP)
		end
		wait()
	end
	for i = 1, 100 do
		teleport:SetPrimaryPartCFrame(teleport.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(20), 0))
		wait()
		if i == 40 then
			spawn(function()
				moveChars(teleport)
			end)
		end
	end
	for i = n, 0, -1 do
		teleport:SetPrimaryPartCFrame(teleport.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(i/10), 0))
		for e = 1, 4 do
			emitters[e].Transparency = math.max(t/i, 0)
			emitters[e].ParticleEmitter.Rate = math.min(i -1 , maxP)
		end
		wait()
	end
	wait(1)
	openDoors()
end




for i, v in pairs(buttons) do -- when a player clicks on the teleport button
	v.ClickDetector.MouseClick:connect(function()
		v.ButtonSound:Play()
		v.CFrame = v.CFrame * CFrame.new(0.05, 0, 0)
		wait()
		v.CFrame = v.CFrame * CFrame.new(-0.05, 0, 0)
		if not running then
			running = true
			wait(1)
			closeDoors()
			wait(1)
			for i, v in pairs(teleports) do
				spawn(function()
					runEffect(v)
				end)
			end
		end
	end)
end

for i, v in pairs(doors) do -- set up initial door positions
	v.LeftDoor:SetPrimaryPartCFrame(v.LeftDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(74), 0))
	v.RightDoor:SetPrimaryPartCFrame(v.RightDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(-74), 0))
end]]
	elseif v.Name == "DoorsScript" then
		source = [[local lDoor = script.Parent.LeftDoor
local rDoor = script.Parent.RightDoor
local button = script.Parent.Button
local closed = false

lDoor:SetPrimaryPartCFrame(lDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(74), 0))
rDoor:SetPrimaryPartCFrame(rDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(-74), 0))

button.ClickDetector.MouseClick:connect(function(player)
	if closed == false then
		closed = true
		for i = 1, 37 do
			lDoor:SetPrimaryPartCFrame(lDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(-2), 0))
			rDoor:SetPrimaryPartCFrame(rDoor.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(2), 0))
			wait()
		end
	end
end)]]
	elseif v.Name == "Script" and v.Parent.Name == "Fan" then
		source = [[while true do
	script.Parent.CFrame = script.Parent.CFrame * CFrame.Angles(0, math.rad(-10), 0)
	wait()
end]]
	elseif v.Name == "AffectScript" then
		source = [[local emitters = {}
local t = 100 -- delay timer
local maxP = 50 -- max particles
local n = 240 -- number of iterations for startup and cooldown
local r = 100 -- run time at full speed

for i, v in pairs(script.Parent:GetChildren()) do
	if v:FindFirstChild("ParticleEmitter") then
		table.insert(emitters, v)
	end
end

while true do
	wait(10)
	for i = 1, n do
		script.Parent:SetPrimaryPartCFrame(script.Parent.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(i/10), 0))
		for e = 1, 4 do
			emitters[e].Transparency = math.max((t-i)/t, 0)
			emitters[e].ParticleEmitter.Rate = math.min(i - t, maxP)
		end
		wait()
	end
	for i = 1, 100 do
		script.Parent:SetPrimaryPartCFrame(script.Parent.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(20), 0))
		wait()
	end
	for i = n, 0, -1 do
		script.Parent:SetPrimaryPartCFrame(script.Parent.PrimaryPart.CFrame * CFrame.Angles(0, math.rad(i/10), 0))
		for e = 1, 4 do
			emitters[e].Transparency = math.max(t/i, 0)
			emitters[e].ParticleEmitter.Rate = math.min(i -1 , maxP)
		end
		wait()
	end
	print("done")
end
]]
	elseif v.Name == "qPerfectionWeld" then
		source = [[-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]

		-- qPerfectionWeld.lua
		-- Created 10/6/2014
		-- Author: Quenty
		-- Version 1.0.3

		-- Updated 10/14/2014 - Updated to 1.0.1
		--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

		-- Updated 10/14/2014 - Updated to 1.0.2
		--- Fixed bug fix. 

		-- Updated 10/14/2014 - Updated to 1.0.3
		--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

		local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


		local function CallOnChildren(Instance, FunctionToCall)
			-- Calls a function on each of the children of a certain object, using recursion.  

			FunctionToCall(Instance)

			for _, Child in next, Instance:GetChildren() do
				CallOnChildren(Child, FunctionToCall)
			end
		end

		local function GetNearestParent(Instance, ClassName)
			-- Returns the nearest parent of a certain class, or returns nil

			local Ancestor = Instance
			repeat
				Ancestor = Ancestor.Parent
				if Ancestor == nil then
					return nil
				end
			until Ancestor:IsA(ClassName)

			return Ancestor
		end

		local function GetBricks(StartInstance)
			local List = {}

			-- if StartInstance:IsA("BasePart") then
			-- 	List[#List+1] = StartInstance
			-- end

			CallOnChildren(StartInstance, function(Item)
				if Item:IsA("BasePart") then
					List[#List+1] = Item;
				end
			end)

			return List
		end

		local function Modify(Instance, Values)
			-- Modifies an Instance by using a table.  

			assert(type(Values) == "table", "Values is not a table");

			for Index, Value in next, Values do
				if type(Index) == "number" then
					Value.Parent = Instance
				else
					Instance[Index] = Value
				end
			end
			return Instance
		end

		local function Make(ClassType, Properties)
			-- Using a syntax hack to create a nice way to Make new items.  

			return Modify(Instance.new(ClassType), Properties)
		end

		local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
		local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

		local function HasWheelJoint(Part)
			for _, SurfaceName in pairs(Surfaces) do
				for _, HingSurfaceName in pairs(HingSurfaces) do
					if Part[SurfaceName].Name == HingSurfaceName then
						return true
					end
				end
			end

			return false
		end

		local function ShouldBreakJoints(Part)
			--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
			--  definitely some edge cases. 

			if NEVER_BREAK_JOINTS then
				return false
			end

			if HasWheelJoint(Part) then
				return false
			end

			local Connected = Part:GetConnectedParts()

			if #Connected == 1 then
				return false
			end

			for _, Item in pairs(Connected) do
				if HasWheelJoint(Item) then
					return false
				elseif not Item:IsDescendantOf(script.Parent) then
					return false
				end
			end

			return true
		end

		local function WeldTogether(Part0, Part1, JointType, WeldParent)
			--- Weld's 2 parts together
			-- @param Part0 The first part
			-- @param Part1 The second part (Dependent part most of the time).
			-- @param [JointType] The type of joint. Defaults to weld.
			-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
			-- @return The weld created.

			JointType = JointType or "Weld"
			local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")

			local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
			Modify(NewWeld, {
				Name = "qCFrameWeldThingy";
				Part0  = Part0;
				Part1  = Part1;
				C0     = CFrame.new();--Part0.CFrame:inverse();
				C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
				Parent = Part1;
			})

			if not RelativeValue then
				RelativeValue = Make("CFrameValue", {
					Parent     = Part1;
					Name       = "qRelativeCFrameWeldValue";
					Archivable = true;
					Value      = NewWeld.C1;
				})
			end

			return NewWeld
		end

		local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
			-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
			-- @param MainPart The part to weld the model to (can be in the model).
			-- @param [JointType] The type of joint. Defaults to weld. 
			-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.

			for _, Part in pairs(Parts) do
				if ShouldBreakJoints(Part) then
					Part:BreakJoints()
				end
			end

			for _, Part in pairs(Parts) do
				if Part ~= MainPart then
					WeldTogether(MainPart, Part, JointType, MainPart)
				end
			end

			if not DoNotUnanchor then
				for _, Part in pairs(Parts) do
					Part.Anchored = false
				end
				MainPart.Anchored = false
			end
		end

		local function PerfectionWeld()	
			local Tool = GetNearestParent(script, "Tool")

			local Parts = GetBricks(script.Parent)
			local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

			if PrimaryPart then
				WeldParts(Parts, PrimaryPart, "Weld", false)
			else
				warn("qWeld - Unable to weld part")
			end

			return Tool
		end

		local Tool = PerfectionWeld()


		if Tool and script.ClassName == "Script" then
			--- Don't bother with local scripts

			script.Parent.AncestryChanged:connect(function()
				PerfectionWeld()
			end)
		end

		-- Created by Quenty (@Quenty, follow me on twitter).
		]]
	elseif v.Name == "TimePlayedClass" then
		source = [[--[[
  TimePlayedClass, RenanMSV @2023

  A script designed to update a leaderboard with
  the top 10 players who most play your game.
  
  Do not change this script. All configurations can be found
  in the Settings script.
]

		local PlayersService = game:GetService("Players")
		local DataStoreService = game:GetService("DataStoreService")
		local RunService = game:GetService("RunService")
		local ServerStorage = game:GetService("ServerStorage")

		local Config = require(script.Parent.Settings)

		local TimePlayedClass = {}
		TimePlayedClass.__index = TimePlayedClass


		function TimePlayedClass.new()
			local new = {}
			setmetatable(new, TimePlayedClass)

			new._dataStoreName = Config.DATA_STORE
			new._dataStoreStatName = Config.NAME_OF_STAT
			new._scoreUpdateDelay = Config.SCORE_UPDATE * 60
			new._boardUpdateDelay = Config.LEADERBOARD_UPDATE * 60
			new._useLeaderstats = Config.USE_LEADERSTATS
			new._nameLeaderstats = Config.NAME_LEADERSTATS
			new._show1stPlaceAvatar = Config.SHOW_1ST_PLACE_AVATAR
			if new._show1stPlaceAvatar == nil then new._show1stPlaceAvatar = true end
			new._doDebug = Config.DO_DEBUG

			new._datastore = nil
			new._scoreBlock = script.Parent.ScoreBlock
			new._updateBoardTimer = script.Parent.UpdateBoardTimer.Timer.TextLabel

			new._apiServicesEnabled = false
			new._isMainScript = nil

			new._isDancingRigEnabled = false
			new._dancingRigModule = nil

			new._usernameCache = {}
			new._thumbnailCache = {}

			new:_init()

			return new
		end


		function TimePlayedClass:_init()

			if self._doDebug then
				warn("TopTimePlayed Board: Debugging is enabled.")
			end

			self:_checkIsMainScript()

			if self._isMainScript then
				if not self:_checkDataStoreUp() then
					self:_clearBoard()
					self._scoreBlock.NoAPIServices.Warning.Visible = true
					return
				end
			else
				self._apiServicesEnabled = (ServerStorage:WaitForChild("TopTimePlayedLeaderboard_NoAPIServices_Flag", 99) :: BoolValue).Value
				if not self._apiServicesEnabled then
					self:_clearBoard()
					self._scoreBlock.NoAPIServices.Warning.Visible = true
					return
				end
			end

			local suc, err = pcall(function ()
				self._datastore = game:GetService("DataStoreService"):GetOrderedDataStore(self._dataStoreName)
			end)
			if not suc or self._datastore == nil then warn("Failed to load OrderedDataStore. Error:", err) script.Parent:Destroy() end

			self:_checkDancingRigEnabled()

			-- puts leaderstat value in player
			if self._useLeaderstats and self._isMainScript then
				local function createLeaderstats (player)
					task.spawn(function ()
						local stat = Instance.new("NumberValue")
						stat.Name = self._nameLeaderstats
						if self._doDebug then print("Searching for the player's leaderstats folder") end
						-- creates the leaderstats folder in case it does not find one in 8 seconds
						local leaderstatsFolder = player:WaitForChild("leaderstats", 8)
						if not leaderstatsFolder then
							if self._doDebug then print("Could not find the player's leaderstats folder. Creating one.") end
							leaderstatsFolder = Instance.new("Configuration")
							leaderstatsFolder.Name = "leaderstats"
							leaderstatsFolder.Parent = player
						end
						stat.Parent = leaderstatsFolder
						-- retrieves and updates leaderstat value to the player's time saved in the datastore
						local success, resultOrError = pcall(function ()
							return self._datastore:GetAsync(self._dataStoreStatName .. player.UserId)
						end)
						stat.Value = not success and 0 or resultOrError
						if self._doDebug and not success then print("Failed to GetAsync the player's time played. Will retry later.") end
					end)
				end
				for _, player: Player in pairs(PlayersService:GetPlayers()) do
					createLeaderstats(player)
				end
				PlayersService.PlayerAdded:Connect(function (player)
					createLeaderstats(player)
				end)
			end
			-- increments players time in the datastore
			task.spawn(function ()
				if not self._isMainScript then return end
				while true do
					task.wait(self._scoreUpdateDelay)
					self:_updateScore()
				end
			end)

			-- update leaderboard
			task.spawn(function ()
				self:_updateBoard() -- update once
				local count = self._boardUpdateDelay
				while true do
					task.wait(1)
					count -= 1
					self._updateBoardTimer.Text = ("Updating the board in %d seconds"):format(count)
					if count <= 0 then
						self:_updateBoard()
						count = self._boardUpdateDelay
					end
				end
			end)

		end


		function TimePlayedClass:_clearBoard ()
			for _, folder in pairs({self._scoreBlock.Leaderboard.Names, self._scoreBlock.Leaderboard.Photos, self._scoreBlock.Leaderboard.Score}) do
				for _, item in pairs(folder:GetChildren()) do
					item.Visible = false
				end
			end
		end


		function TimePlayedClass:_updateBoard ()
			if self._doDebug then print("Updating board") end
			local results = nil

			local suc, results = pcall(function ()
				return self._datastore:GetSortedAsync(false, 10, 1):GetCurrentPage()
			end)

			if not suc or not results then
				if self._doDebug then warn("Failed to retrieve top 10 with most time. Error:", results) end
				return
			end

			local sufgui = self._scoreBlock.Leaderboard
			self._scoreBlock.Credits.Enabled = true
			self._scoreBlock.Leaderboard.Enabled = #results ~= 0
			self._scoreBlock.NoDataFound.Enabled = #results == 0
			self:_clearBoard()
			for k, v in pairs(results) do
				local userid = tonumber(string.split(v.key, self._dataStoreStatName)[2])
				local name: string, thumbnail: string
				if userid <= 0 then -- ids below 0 are given for roblox studio test players
					name = "Studio Test Profile"
					thumbnail = "rbxassetid://11569282129"
				else
					name = self:_getUsernameAsync(userid)
					thumbnail = self:_getThumbnailAsync(userid)
				end
				local score = self:_timeToString(v.value)
				self:_onPlayerScoreUpdate(userid, v.value)
				sufgui.Names["Name"..k].Visible = true
				sufgui.Score["Score"..k].Visible = true
				sufgui.Photos["Photo"..k].Visible = true
				sufgui.Names["Name"..k].Text = name
				sufgui.Score["Score"..k].Text = score
				sufgui.Photos["Photo"..k].Image = thumbnail
				if k == 1 and self._dancingRigModule then
					task.spawn(function ()
						self._dancingRigModule.SetRigHumanoidDescription(userid > 0 and userid or 1)
					end)
				end
			end
			if self._scoreBlock:FindFirstChild("_backside") then self._scoreBlock["_backside"]:Destroy() end
			local temp = self._scoreBlock.Leaderboard:Clone()
			temp.Parent = self._scoreBlock
			temp.Name = "_backside"
			temp.Face = Enum.NormalId.Back
			if self._doDebug then print("Board updated sucessfully") end
		end


		function TimePlayedClass:_updateScore ()
			local suc, err = coroutine.resume(coroutine.create(function ()
				local players = PlayersService:GetPlayers()
				for _, player in pairs(players) do
					local stat = self._dataStoreStatName .. player.UserId
					local newval = self._datastore:IncrementAsync(stat, self._scoreUpdateDelay / 60)
					if self._doDebug then print("Incremented time played stat of", player, stat, "to", newval) end
				end
			end))
			if not suc then warn(err) end
		end


		function TimePlayedClass:_onPlayerScoreUpdate (userid, minutes)
			-- updates leaderstats if enabled
			if not self._useLeaderstats then return end
			if not self._isMainScript then return end
			local player = PlayersService:GetPlayerByUserId(userid)
			if not player or not player:FindFirstChild("leaderstats") then return end
			local leaderstat = player.leaderstats[self._nameLeaderstats]
			leaderstat.Value = tonumber(minutes)
		end


		function TimePlayedClass:_checkDancingRigEnabled()
			if self._show1stPlaceAvatar then
				local rigFolder = script.Parent:FindFirstChild("First Place Avatar")
				if not rigFolder then return end
				local rig = rigFolder:FindFirstChild("Rig")
				local rigModule = rigFolder:FindFirstChild("PlayAnimationInRig")
				if not rig or not rigModule then return end
				self._dancingRigModule = require(rigModule)
				if self._dancingRigModule then
					self._isDancingRigEnabled = true
				end
			else
				local rigFolder = script.Parent:FindFirstChild("First Place Avatar")
				if not rigFolder then return end
				rigFolder:Destroy()
			end
		end


		function TimePlayedClass:_checkIsMainScript()
			local timePlayedClassRunning = ServerStorage:FindFirstChild("TopTimePlayedLeaderboard_Running_Flag")
			if timePlayedClassRunning then
				self._isMainScript = false
			else
				self._isMainScript = true
				local boolValue = Instance.new("BoolValue", ServerStorage)
				boolValue.Name = "TopTimePlayedLeaderboard_Running_Flag"
				boolValue.Value = true
			end
		end


		function TimePlayedClass:_checkDataStoreUp()
			local status, message = pcall(function()
				-- This will error if current instance has no Studio API access:
				DataStoreService:GetDataStore("____PS"):SetAsync("____PS", os.time())
			end)
			if status == false and
				(string.find(message, "404", 1, true) ~= nil or 
					string.find(message, "403", 1, true) ~= nil or -- Cannot write to DataStore from studio if API access is not enabled
					string.find(message, "must publish", 1, true) ~= nil) then -- Game must be published to access live keys
				local boolValue = Instance.new("BoolValue", ServerStorage)
				boolValue.Value = false
				boolValue.Name = "TopTimePlayedLeaderboard_NoAPIServices_Flag"
				return false
			end
			self._apiServicesEnabled = true
			local boolValue = Instance.new("BoolValue", ServerStorage)
			boolValue.Value = true
			boolValue.Name = "TopTimePlayedLeaderboard_NoAPIServices_Flag"
			return self._apiServicesEnabled
		end


		function TimePlayedClass:_getUsernameAsync(userid: number)
			if self._usernameCache[userid] then -- already cached, return
				return self._usernameCache[userid]
			end
			local success: boolean, resultOrError: string = pcall(function ()
				return PlayersService:GetNameFromUserIdAsync(userid)
			end)
			if not success then
				if self._doDebug then
					warn(("TopTimePlayed Board: Error retrieving username for userid %d. Cause: %s"):format(userid, resultOrError))
				end
				return "Name not found"
			else
				self._usernameCache[userid] = resultOrError
				return resultOrError
			end
		end


		function TimePlayedClass:_getThumbnailAsync(userid: number)
			if self._thumbnailCache[userid] then -- already cached, return
				return self._thumbnailCache[userid]
			end
			local success: boolean, resultOrError: string = pcall(function ()
				return PlayersService:GetUserThumbnailAsync(userid, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size150x150)
			end)
			if not success then
				if self._doDebug then
					warn(("TopTimePlayed Board: Error retrieving thumbnail for userid %d. Cause: %s"):format(userid, resultOrError))
				end
				return "rbxassetid://5107154082"
			else
				self._thumbnailCache[userid] = resultOrError
				return resultOrError
			end
		end


		function TimePlayedClass:_timeToString(_time)
			_time = _time * 60
			local days = math.floor(_time / 86400)
			local hours = math.floor(math.fmod(_time, 86400) / 3600)
			local minutes = math.floor(math.fmod(_time, 3600) / 60)
			return string.format("%02dd : %02dh : %02dm",days,hours,minutes)
		end


		TimePlayedClass.new()
		]]
	elseif v.Name == "DemoMode" and v.Parent.Name == "AMECOTouch" then
		source = [[script.Parent.FanClick.ClickDetector.MouseClick:Connect(function()
	if script.Parent.Demo.Value == 0 then
		script.Parent.Demo.Value = 1
		wait(5)
		script.Parent.Demo.Value = 0
	end
end)

script.Parent.LightClick.ClickDetector.MouseClick:Connect(function()
	if script.Parent.Demo.Value == 1 then
		script.Parent.Demo.Value = 2
	end
end)

script.Parent.FanClick.ClickDetector.MouseClick:Connect(function()
	if script.Parent.Demo.Value == 2 then
		script.Parent.Demo.Value = 3
	end
end)

script.Parent.LightClick.ClickDetector.MouseClick:Connect(function()
	if script.Parent.Demo.Value == 3 then
		script.Parent.Demo.Value = 4
	end
end)

script.Parent.FanClick.ClickDetector.MouseClick:Connect(function()
	if script.Parent.Demo.Value == 4 then
		script.Parent.Demo.Value = 5
		script.Parent.Light.Value = 5
		script.Parent.Parent.Fan.Light.Material = "SmoothPlastic"
		script.Parent.Parent.Fan.Light.PointLight.Enabled = false
		script.Parent.Parent.Fan.Light.PointLight.Brightness = 0
		wait(1.6)
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.AngularVelocity = Vector3.new(0,-100,0)
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new(0,0,0)
		script.Parent.Speed.Value = 7
		wait(8)
		script.Parent.Parent.Fan.Light.Material = "Neon"
		script.Parent.Parent.Fan.Light.PointLight.Enabled = true
		script.Parent.Parent.Fan.Light.PointLight.Brightness = 1
		wait(1)
		script.Parent.Parent.Fan.Light.PointLight.Brightness = 2
		wait(1)
		script.Parent.Parent.Fan.Light.PointLight.Brightness = 3
		wait(11)
		script.Parent.FanClick.beep:Play()
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,.5,0)
		wait(1)
		script.Parent.FanClick.beep:Play()
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,1,0)
		wait(1)
		script.Parent.FanClick.beep:Play()
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,1.25,0)
		wait(5)
		script.Parent.Parent.Fan.Light.PointLight.Brightness = 2
		wait(1)
		script.Parent.Parent.Fan.Light.PointLight.Brightness = 1
		wait(7)
		script.Parent.FanClick.beep:Play()
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,1.55,0)
		wait(1)
		script.Parent.FanClick.beep:Play()
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,2,0)
		wait(1)
		script.Parent.FanClick.beep:Play()
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new (0,2.5,0)
		wait(4.8)
		script.Parent.FanClick.beep:Play()
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.AngularVelocity = Vector3.new(0,100,0)
		wait(15.6)
		script.Parent.FanClick.beep:Play()
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.AngularVelocity = Vector3.new(0,-100,0)
		wait(4.7)
		script.Parent.FanClick.beep:Play()
		script.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new(0,0,0)
		wait(4.5)
		script.Parent.Parent.Fan.Light.Material = "SmoothPlastic"
		script.Parent.Parent.Fan.Light.PointLight.Enabled = false
		script.Parent.Parent.Fan.Light.PointLight.Brightness = 0
		script.Parent.Demo.Value = 0
		script.Parent.Speed.Value = 0
		script.Parent.Light.Value = 1
	end
end)]]
	elseif v.Parent.Name == "FanClick" then
		source = [[script.Parent.ClickDetector.MouseClick:Connect(function()
	if script.Parent.Parent.Speed.Value == 0 then
		script.Parent.Parent.Speed.Value = 7
		script.Parent.beep:Play()
		script.Parent.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new(0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Speed.Value = 1
		elseif script.Parent.Parent.Speed.Value == 1 then
		script.Parent.Parent.Speed.Value = 7
		script.Parent.beep:Play()
		script.Parent.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new(0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Speed.Value = 2
		elseif script.Parent.Parent.Speed.Value == 2 then
		script.Parent.Parent.Speed.Value = 7
		script.Parent.beep:Play()
		script.Parent.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new(0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Speed.Value = 3
		elseif script.Parent.Parent.Speed.Value == 3 then
		script.Parent.Parent.Speed.Value = 7
		script.Parent.beep:Play()
		script.Parent.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new(0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Speed.Value = 4
		elseif script.Parent.Parent.Speed.Value == 4 then
		script.Parent.Parent.Speed.Value = 7
		script.Parent.beep:Play()
		script.Parent.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.MaxTorque = Vector3.new(0,2.5,0)
		wait(1.5)
		script.Parent.Parent.Speed.Value = 5
		elseif script.Parent.Parent.Speed.Value == 5 then
		script.Parent.beep:Play()
		script.Parent.Parent.Speed.Value = 6
		elseif script.Parent.Parent.Speed.Value == 6 then
		script.Parent.beep:Play()
		script.Parent.Parent.Speed.Value = 0
	end
end)]]
	elseif v.Parent.Name == "LightClick" then
		source = [[script.Parent.ClickDetector.MouseClick:Connect(function()
	if script.Parent.Parent.Light.Value == 1 then
		script.Parent.Parent.Light.Value = 2
	elseif script.Parent.Parent.Light.Value == 2 then
		script.Parent.Parent.Light.Value = 3
	elseif script.Parent.Parent.Light.Value == 3 then
		script.Parent.Parent.Light.Value = 4
	elseif script.Parent.Parent.Light.Value == 4 then
		script.Parent.Parent.Light.Value = 1
	end
end)]]
	elseif v.Parent.Name == "ReverseClick" then
		source = [[script.Parent.ClickDetector.MouseClick:connect(function()
	if script.Parent.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.AngularVelocity == Vector3.new(0,-100,0) then
		script.Parent.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.AngularVelocity = Vector3.new(0,100,0)
		script.Parent.Parent.FanClick.beep:Play()
	else
		script.Parent.Parent.Parent.Fan.Motorset.Motor.BodyAngularVelocity.AngularVelocity = Vector3.new(0,-100,0)
		script.Parent.Parent.FanClick.beep:Play()
	end
end)]]
	elseif v.Parent.Name == "Motorset" and v.Name == "Script" then
		source = [[script.Parent:MakeJoints()]]
	elseif v.Name == "WeldScript" and v.Parent.Name == "Motorset" then
		source = [[function Weld(x, y)
 local weld = Instance.new("Weld")
 weld.Part0 = x
 weld.Part1 = y
 weld.C0 = x.CFrame:inverse() * CFrame.new(x.Position)
 weld.C1 = y.CFrame:inverse() * CFrame.new(x.Position)
 weld.Parent = x
end

local prev
local unanchor = {}

function search ( n )
 n = n or script.Parent
	for i, v in pairs(n:getChildren()) do
		if v:IsA("BasePart") and not v.Name:find("Wheel") then
			if prev then
	Weld(v, prev)
	prev = v
	unanchor[#unanchor + 0] = v
	else
	prev = v
	unanchor[#unanchor + 0] = v
	   end
	  end
	search(v)
	 end
	end

function unanchormodel(m)
	local g = m:GetChildren()
	for i = 1, #g do
		if (g[i]:IsA("BasePart")) then
			g[i].Anchored = false
		elseif (g[i]:IsA("Model")) then
			unanchormodel(g[i])
		end
	end
end



search()
wait()
unanchormodel(script.Parent)
]]
	elseif v.Name == "SpeedScript" and v.Parent.Name == "Motor" then
		source = [[while true do
	if script.Parent.Parent.Parent.Parent.AMECOTouch.Speed.Value == 0 then
		script.Parent.BodyAngularVelocity.MaxTorque = Vector3.new(0,0,0)
	elseif script.Parent.Parent.Parent.Parent.AMECOTouch.Speed.Value == 1 then
		script.Parent.BodyAngularVelocity.MaxTorque = Vector3.new(0,.5,0)
	elseif script.Parent.Parent.Parent.Parent.AMECOTouch.Speed.Value == 2 then
		script.Parent.BodyAngularVelocity.MaxTorque = Vector3.new(0,1,0)
	elseif script.Parent.Parent.Parent.Parent.AMECOTouch.Speed.Value == 3 then
		script.Parent.BodyAngularVelocity.MaxTorque = Vector3.new(0,1.25,0)
	elseif script.Parent.Parent.Parent.Parent.AMECOTouch.Speed.Value == 4 then
		script.Parent.BodyAngularVelocity.MaxTorque = Vector3.new(0,1.55,0)
	elseif script.Parent.Parent.Parent.Parent.AMECOTouch.Speed.Value == 5 then
		script.Parent.BodyAngularVelocity.MaxTorque = Vector3.new(0,2,0)
	elseif script.Parent.Parent.Parent.Parent.AMECOTouch.Speed.Value == 6 then
		script.Parent.BodyAngularVelocity.MaxTorque = Vector3.new(0,2.5,0)
	end
	wait()
end]]
	elseif v.Name == "LightScript" and v.Parent.Name == "Light" then
		source = [[while true do
	if script.Parent.Parent.Parent.AMECOTouch.Light.Value == 0 then
		script.Parent.PointLight.Brightness = 0
		script.Parent.PointLight.Enabled = false
		script.Parent.Material = "SmoothPlastic"
	elseif script.Parent.Parent.Parent.AMECOTouch.Light.Value == 1 then
		script.Parent.PointLight.Brightness = 0
		script.Parent.PointLight.Enabled = false
		script.Parent.Material = "SmoothPlastic"
	elseif script.Parent.Parent.Parent.AMECOTouch.Light.Value == 2 then
		script.Parent.PointLight.Brightness = 1
		script.Parent.PointLight.Enabled = true
		script.Parent.Material = "Neon"
	elseif script.Parent.Parent.Parent.AMECOTouch.Light.Value == 3 then
		script.Parent.PointLight.Brightness = 2
		script.Parent.PointLight.Enabled = true
		script.Parent.Material = "Neon"
	elseif script.Parent.Parent.Parent.AMECOTouch.Light.Value == 4 then
		script.Parent.PointLight.Brightness = 3
		script.Parent.PointLight.Enabled = true
		script.Parent.Material = "Neon"
	end
	wait()
end]]
	elseif v.Name == "HatHelperGuideGiverScript" then
		source = [[-- Guide to how to make a hat giver.

-- To adjust where your hat will be postioned on your head, go to the script line that says "h.AttachmentPos = Vector3.new(0,0,0)
-- The first number in the (0,0,0) will make your hat go to the left, or to the right, making the number positive will make your hat be
-- placed to the left, making it negative( ex. "-1") will make it be placed to the right. If your hat is pretty semetrical, you wont have to
-- adjust the first number, it stays usually in the middle, a zero.

-- The middle number adjusts how high/low the hat will be placed on the head. The higher the number is, the lower the hat will be
-- placed. If  you are at zero, and you want the hat to go  lower, make the number a negative. Negative numbers will make the hat
-- be place higher on your robloxian head.

-- The third number determines how far ahead/back your hat will be placed. Making the number positive will place the hat ahead of 
-- you, while making the number negative will place the hat behind you some.

-- NOTE, on the first, and last numbers, the ones that make your hat go left/right/ahead/back shouldn't be changed by whole numbers
-- to make your hat giver perfect, if you have to use those two numbers, move it slowly by ".1's"
-- This can also go for the middle number. If your hat is slightly higher than its supposed to be, than edit the number slightly. 
-- Do not change the numbers by whole numbers, or else it will go really far off.  Change the numbers by ".1's" and ".2's"



-- If you want to after how many seconds can you get another hat on your head, change the line that says "wait(5)"
-- Changing this will change after how many seconds can someone touch the giver, and get a hat. It's best to leave it as it is, 
-- Changing it really doesnt matter.

-- In build mode, after every time you change this script, copy the script, delete it, and paste it back into your hat, if you don't, 
-- nothing will change, I don't know why, but this is how I make my givers.

-- If you want to change the hat that you are trying on, change the "Mesh" Just delete the one in the brick that this script is in,
-- and copy a mesh from a different hat, that you want to try on with this script.

-- Do not rename the name of the "Mesh", leave it saying Mesh, or the giver wont work.


-- Ask any questions here:  http://www.roblox.com/Forum/ShowPost.aspx?PostID=13178947


-- If you want to know how to retexture a hat, read this:  http://www.roblox.com/Forum/ShowPost.aspx?PostID=10502388








debounce = true

function onTouched(hit)
	if (hit.Parent:findFirstChild("Humanoid") ~= nil and debounce == true) then
		debounce = false
		h = Instance.new("Hat")
		p = Instance.new("Part")
		h.Name = "Hat"   -- It doesn't make a difference, but if you want to make your place in Explorer neater, change this to the name of your hat.
		p.Parent = h
		p.Position = hit.Parent:findFirstChild("Head").Position
		p.Name = "Handle" 
		p.formFactor = 0
		p.Size = Vector3.new(-0,-0,-1) 
		p.BottomSurface = 0 
		p.TopSurface = 0 
		p.Locked = true 
		script.Parent.Mesh:clone().Parent = p
		h.Parent = hit.Parent
		h.AttachmentPos = Vector3.new(0, -0.05, 0.25) -- Change these to change the positiones of your hat, as I said earlier.
		wait(5)		debounce = true
	end
end

script.Parent.Touched:connect(onTouched)

-- Script Guide by HatHelper - kukuinya]]
	elseif v.Name == "Delete if used for decoration" then
		source = [[debounce = true

function onTouched(hit)
	if (hit.Parent:findFirstChild("Humanoid") ~= nil and debounce == true) then
		debounce = false
		h = Instance.new("Hat")
		p = Instance.new("Part")
		h.Name = "Hat" 
		p.Parent = h
		p.Position = hit.Parent:findFirstChild("Head").Position
		p.Name = "Handle" 
		p.formFactor = 0
		p.Size = Vector3.new(-0,-0,-1) 
		p.BottomSurface = 0 
		p.TopSurface = 0 
		p.Locked = true 
		script.Parent.Mesh:clone().Parent = p
		h.Parent = hit.Parent
		h.AttachmentPos = Vector3.new(0, -0.05, 0.25)
		wait(5)		debounce = true
	end
end

script.Parent.Touched:connect(onTouched)
]]
	elseif v.Name == "Welcome Badge" then
		source = [[--BonBonBakery--
BadgetId = 2124489069 --put the code here

game.Players.PlayerAdded:connect(function(p)-- Do not change 
wait(.5) --How long the person stays to earn the badge
b = game:GetService("BadgeService")-- Do not change 
b:AwardBadge(p.userId,BadgetId)-- Do not change
end)-- Do not change 
-- Time badge by rickymarckstadt]]
	elseif v.Name == "CheckpointScript" then
		source = [[local spawn = script.Parent
spawn.Touched:connect(function(hit)
	if hit and hit.Parent and hit.Parent:FindFirstChild("Humanoid") then
		local player = game.Players:GetPlayerFromCharacter(hit.Parent)
		local checkpointData = game.ServerStorage:FindFirstChild("CheckpointData")
		if not checkpointData then
			checkpointData = Instance.new("Model", game.ServerStorage)
			checkpointData.Name = "CheckpointData"
		end
		
		local checkpoint = checkpointData:FindFirstChild(tostring(player.userId))
		if not checkpoint then
			checkpoint = Instance.new("ObjectValue", checkpointData)
			checkpoint.Name = tostring(player.userId)
			
			player.CharacterAdded:connect(function(character)
				wait()
				character:WaitForChild("HumanoidRootPart").CFrame = game.ServerStorage.CheckpointData[tostring(player.userId)].Value.CFrame + Vector3.new(0, 4, 0)
			end)
		end
		
		checkpoint.Value = spawn
	end
end)]]
	elseif v.Parent.Name == "SoundBlock" then
		source = [[function onTouched(hit)
	local humanoid = hit.Parent:findFirstChild("Humanoid")
	if humanoid~=nil then
		wait(0.01)
		script.Parent.Sound:Play()
	end 
end 

script.Parent.Touched:connect(onTouched)
]]
	elseif v.Name == "Kills/Deaths" then
		source = [[local Players = game.Players

local Template = Instance.new 'BoolValue'
Template.Name = 'leaderstats'

Instance.new('IntValue', Template).Name = "Kills"
Instance.new('IntValue', Template).Name = "Deaths"


Players.PlayerAdded:connect(function(Player)
	wait(1)
	local Stats = Template:Clone()
	Stats.Parent = Player
	local Deaths = Stats.Deaths
	Player.CharacterAdded:connect(function(Character)
		Deaths.Value = Deaths.Value + 1
		local Humanoid = Character:FindFirstChild "Humanoid"
		if Humanoid then
			Humanoid.Died:connect(function()
				for i, Child in pairs(Humanoid:GetChildren()) do
					if Child:IsA('ObjectValue') and Child.Value and Child.Value:IsA('Player') then
						local Killer = Child.Value
						if Killer:FindFirstChild 'leaderstats' and Killer.leaderstats:FindFirstChild "Kills" then
							local Kills = Killer.leaderstats.Kills
							Kills.Value = Kills.Value + 1
						end
						return -- Only one player can get a KO for killing a player. Not 2, not 3. Only one.
					end
				end
			end)
		end
	end)
end)
-- Coded by JulienDethurens using gedit.]]
	elseif v.Name == "AssetLoader" and v.Parent:FindFirstChild("DeveloperProductHandler") then
		source = [[require(11370150761).Parent = script.Parent
-- Hello, User removing this script will break the board. If you need to ask something dm Yeah_Ember

--[[
	-----------[ THEMES ]-----------
  

	- LIGHT MODE:
	  If you want the light theme version of the board,
	  replace line 1 with: 
	  
	  require(11370150761).Parent = script.Parent
	
	- DARK MODE:
	  If you want the dark theme version of the board,
	  replace line 1 with: 
	  
	  require(11370294847).Parent = script.Parent

--]]
	elseif v.Name == "DeveloperProductHandler" then
		source = [[local runService = game:GetService('RunService')

if runService:IsStudio() then
	return
end

local products = require(script.Parent:WaitForChild('Products'))
local enabled = true

function GetData()
	local datastore = game:GetService("DataStoreService"):GetDataStore("BoardData")
	local data = datastore:GetAsync("Data")
	if data == nil then
		data = {ListSize = 15, Datastore = 1, Refresh = 1, Version = 2}
	end

	local tD = "TopDonators"

	if data.Datastore ~= 1 then
		tD = "TopDonators"..data.Datastore
	end

	return tD
end

function ReceiptHandler()
	warn("Donation Board: ProcessReceipt Activated")

	game:GetService("MarketplaceService").ProcessReceipt = function(receiptInfo)
		local playerProductKey = "player_" .. receiptInfo.PlayerId .. "_product_" .. receiptInfo.ProductId
		local numberBought = game:GetService("DataStoreService"):GetDataStore("PurchaseHistory"):IncrementAsync(playerProductKey, 1)
		local productBought = game:GetService("DataStoreService"):GetDataStore("PurchaseHistoryCount"):IncrementAsync(receiptInfo.ProductId, 1)
		local playerFound = false

		for i, v in pairs (game.Players:GetChildren()) do
			if v:IsA('Player') then
				if v.userId == receiptInfo.PlayerId then
					for _, p in pairs (products.Products) do
						if p.ProductId == receiptInfo.ProductId then
							if v ~= nil then
								playerFound = true
								game:GetService("DataStoreService"):GetOrderedDataStore(GetData()):IncrementAsync(receiptInfo.PlayerId, p.ProductPrice)
							end
						end
					end
				end
			end
		end

		if playerFound ~= true then
			return Enum.ProductPurchaseDecision.NotProcessedYet 
		else
			return Enum.ProductPurchaseDecision.PurchaseGranted		
		end
	end	
end

if products.AbortCustomPurchases then
	if products.AbortCustomPurchases == true then
		Enabled = false
		warn("Donation Board: Custom ProcessReceipt Enabled!")
	else
		ReceiptHandler()
	end
else
	ReceiptHandler()
end]]
	elseif v.Name == "SettingsHandler" and v.Parent:FindFirstChild("DeveloperProductHandler") then
		source = [[local runService = game:GetService('RunService')

if runService:IsStudio() then
	return
end

local products = require(script.Parent:WaitForChild("Products"))
local custom = false

if products.AbortCustomPurchases then
	if products.AbortCustomPurchases == true then
		custom = true
		warn("Donation Board: Changing the donation board datastore is disabled if AbortCustomPurchases is true!")
	end
end

local retriever = script:WaitForChild("Retriever")
local datastore = game:GetService("DataStoreService"):GetDataStore("BoardData")
local data = datastore:GetAsync("Data")

if data == nil then
	data = {ListSize = 15, Datastore = 1, Refresh = 1, Version = 2}
else
	if (not data.Version) then
		data = {ListSize = 15, Datastore = 1, Refresh = 1, Version = 2}
		datastore:SetAsync("Data",data)
	elseif (data.Version ~= 2) then
		data = {ListSize = 15, Datastore = 1, Refresh = 1, Version = 2}
		datastore:SetAsync("Data",data)		
	end
end

function getOwner()
	if game.CreatorType == Enum.CreatorType.User then
		return game.CreatorId,game.Players:GetNameFromUserIdAsync(game.CreatorId)
	else
		local owningGroupInfo = game:GetService("GroupService"):GetGroupInfoAsync(game.CreatorId)
		return owningGroupInfo.Owner.Id, owningGroupInfo.Owner.Name
	end
end

function retriever.OnServerInvoke(player,action,data)
	if action == "Authenticate" then
		local ownerId,ownerName = getOwner()
		if player.userId == ownerId then
			return true
		else 
			return false
		end
	elseif action == "GetData" then
		local data = datastore:GetAsync("Data")
		if data == nil then
			data = {ListSize = 15, Datastore = 1, Refresh = 1, Version = 2}
		end
		return data,custom
	elseif action == "SetData" then
		local ownerId,ownerName = getOwner()
		if player.userId == ownerId then		
			datastore:SetAsync("Data",data)
		end
	end
end
]]
	elseif v.Name == "Loader" and v.Parent:FindFirstChild("PlayAnimation") then
		source = [[local Model = script.Parent
local Config = Model.Configuration
local userId = Config.userId.Value

local Loader

if Config.AutoUpdateLoader.Value then
	Loader = require(10599737239)
else
	Loader = require(script.MainModule)
end


-------------------------------------------------------------------------------------

Loader:updateModel(Model, Config.userId.Value)

if Config.AutoUpdateCharacter.Value then
	while wait(Config.AutoUpdateCharacter.Delay.Value) do
		Loader:updateModel(Model, Config.userId.Value)
	end
end]]
	elseif v.Name == "AnchorScript" then
		source = [[script.Parent.Anchored = true]]
	elseif v.Parent.Name == "pName" then
		source = [[local thing = script.Parent
local uiGradient = thing:WaitForChild("UIGradient")
local tweenService = game:GetService("TweenService")

while true do
	local tween = tweenService:Create(uiGradient, TweenInfo.new(2, Enum.EasingStyle.Linear), {Offset = Vector2.new(-1, 0)})
	tween:Play()
	wait(2)
	uiGradient.Offset = Vector2.new(1, 0)
	local tween2 = tweenService:Create(uiGradient, TweenInfo.new(2, Enum.EasingStyle.Linear), {Offset = Vector2.new(0, 0)})
	tween2:Play()
	wait(2)
end
]]
	elseif v.Name == "Updater" and v.Parent.Name == "Buttons" then
		source = [[local runService = game:GetService('RunService')

local surfaceGui = script.Parent:WaitForChild('SurfaceGui')

if runService:IsStudio() then
	surfaceGui.MainFrame.ScrollingFrame.Message.Visible = true
	return
else
	surfaceGui.MainFrame.ScrollingFrame.Message:Destroy()		
end

local products = require(script.Parent.Parent:WaitForChild('Products')).Products

function updateBoard(data)
	for _,v in pairs (surfaceGui.MainFrame.ScrollingFrame:GetChildren()) do
		v:TweenPosition(UDim2.new(-1,0,0,v.Position.Y.Offset),'In','Quad',1,true)
		delay(1,function()
			v:Destroy()
		end)
	end

	local n = 0

	for k, v in pairs(data) do
		local clone = script.Frame:Clone()
		clone.Title.Text = "Donate "..v.ProductPrice.." Robux"
		clone.Id.Value = v.ProductId
		clone.Position = UDim2.new(1,0,0,(n* 20) + (n*5))
		clone.Parent = surfaceGui.MainFrame.ScrollingFrame
		clone:TweenPosition(UDim2.new(0,0,0,(n* 20) + (n*5)),'In','Quad',1,true)	
		n = n + 1		
		surfaceGui.MainFrame.ScrollingFrame.CanvasSize = UDim2.new(0,0,0,(n * 20) + (n*5))
		wait()
	end	
end

updateBoard(products)]]
	elseif v.Name == "ScoreUpdater" then
		source = [[local runService = game:GetService('RunService')

local surfaceGui = script.Parent:WaitForChild('SurfaceGui')

if runService:IsStudio() then
	surfaceGui.MainFrame.ScrollingFrame.Message.Visible = true
	return
else
	surfaceGui.MainFrame.ScrollingFrame.Message:Destroy()
end

function GetData()
	local Datastore = game:GetService("DataStoreService"):GetDataStore("BoardData")
	local Data = Datastore:GetAsync("Data")
	if Data == nil then
		Data = {ListSize = 15, Datastore = 1, Refresh = 1, Version = 2}
	end
	
	local TD = game:GetService("DataStoreService"):GetOrderedDataStore("TopDonators")
	
	if Data.Datastore ~= 1 then
		TD = game:GetService("DataStoreService"):GetOrderedDataStore("TopDonators"..Data.Datastore)
	end
	
	return TD:GetSortedAsync(false, Data.ListSize),Data.ListSize,Data.Refresh
end

function updateBoard(board, data, num)
	surfaceGui.MainFrame.Title.Title.Title.Text = "Top "..num.." Donators"

	for _,v in pairs (script.Parent.SurfaceGui.MainFrame.ScrollingFrame:GetChildren()) do
		v:TweenPosition(UDim2.new(-1,0,0,v.Position.Y.Offset),'InOut','Quart',.5,true)
		wait()
		delay(1,function()
			v:Destroy()
		end)
	end

	local n = 0

	for k, v in pairs(data) do
		local name = v.key
		local score = v.value
		local clone = script.Frame:Clone()	
		local ln = n + 1

		spawn(function()
			pcall(function()
				clone.Number.Text = ln.."."
				clone.Title.Text = game.Players:GetNameFromUserIdAsync(name)
			end)
		end)

		clone.Explaination.Text = score
		clone.Position = UDim2.new(1,0,0,(n* 25) + (n*5))
		clone.Parent = surfaceGui.MainFrame.ScrollingFrame
		clone:TweenPosition(UDim2.new(0,0,0,(n* 25) + (n*5)),'InOut','Quart',.5,true)		
		n = n + 1
		if n == 1 then
			clone.Title.TextColor3 = Color3.new(1, 1, 0)
			clone.Number.TextColor3 = Color3.new(1, 1, 0)
			game.Workspace.Boards.R15Loader.Configuration.userId.Value = name
			game.Workspace.Boards.R15Loader.Tags.Container.pName.Text = game.Players:GetNameFromUserIdAsync(name)
		elseif n == 2 then
			clone.Title.TextColor3 = Color3.new(1, 1, 1)
			clone.Number.TextColor3 = Color3.new(1, 1, 1)
		elseif n == 3 then		
			clone.Title.TextColor3 = Color3.new(1, 0.666667, 0)
			clone.Number.TextColor3 = Color3.new(1, 0.666667, 0)

		end
		surfaceGui.MainFrame.ScrollingFrame.CanvasSize = UDim2.new(0,0,0,(n * 25) + (n*5))
		wait()
	end	
end

while true do
	local refreshTime = 1
	pcall(function()
		local pages,num,refresh = GetData()
		local data = pages:GetCurrentPage()
		updateBoard(script.Parent, data, num)
		if refresh and typeof(refresh) == 'number' then
			refreshTime = refresh
		end
	end)
	wait(refreshTime * 60)
end]]
	elseif v.Name == "MainScript" and v.Parent.Name == "DonoBoard" then
		source = [[local leaderboardbuttons = script:WaitForChild("LeaderBoardButtons")
local firstplace = script.Parent:WaitForChild("FirstPlace")
local secondplace = script.Parent:WaitForChild("SecondPlace")
local therdplace = script.Parent:WaitForChild("ThirdPlace")
local buttons = script.Parent:WaitForChild("Buttons")
local screen = script.Parent:WaitForChild("Screen")
local infomation = script.Parent:WaitForChild("Infomation")

local datastore = game:GetService("DataStoreService")
local DSLB = datastore:GetOrderedDataStore("DonoPurchaseLB")
local productsmodule = require(script.Parent:WaitForChild("Products"))
local market = game:GetService("MarketplaceService")
local products = productsmodule.Products
local PeopleDonatedinlast1minute = {}

leaderboardbuttons.Disabled = false
leaderboardbuttons.Parent = game.StarterPlayer.StarterPlayerScripts

function Defult()
  coroutine.wrap(updatecharacter)(78217237,1)coroutine.wrap(updatecharacter)(78217237,2)coroutine.wrap(updatecharacter)(78217237,3)
  screen.SurfaceGui.MainFrame.Title.Title.Title.Text = "Top "..infomation.AmountofPlayers.Value.." Donors"
  buttons.SurfaceGui.MainFrame.Scroll.TempDono.Parent = script
  screen.SurfaceGui.MainFrame.Scroll.TempScreen.Parent = script
  for _,v in pairs(screen.SurfaceGui.MainFrame.Scroll:GetChildren()) do if v:IsA("Frame") then v:Destroy() end end
  if infomation.DoPages.Value then
    local numberofplayers = math.ceil(infomation.AmountofPlayers.Value/15)
    local numberofproducts = math.ceil(#products/4)
    for i = 1,numberofplayers do
      local temp = screen.SurfaceGui.MainFrame.Pages.ScreenPageTemp:Clone()
      temp.Parent = screen.SurfaceGui.MainFrame.Pages
      temp.Name = "P"..i
    end
    screen.SurfaceGui.MainFrame.Pages.P1.Visible = true
    screen.SurfaceGui.MainFrame.Pages.ScreenPageTemp:Destroy()
    screen.SurfaceGui.MainFrame.Scroll:Destroy()
    for i = 1,numberofproducts do
      local temp = buttons.SurfaceGui.MainFrame.Pages.ButtonPageTemp:Clone()
      temp.Parent = buttons.SurfaceGui.MainFrame.Pages
      temp.Name = "P"..i
    end
    buttons.SurfaceGui.MainFrame.Pages.ButtonPageTemp:Destroy()
    buttons.SurfaceGui.MainFrame.Scroll:Destroy()
    if #screen.SurfaceGui.MainFrame.Pages:GetChildren() == 1 then
      screen.SurfaceGui.MainFrame.Footer.PageNumbers:Destroy()
    end
    if #buttons.SurfaceGui.MainFrame.Pages:GetChildren() == 1 then
      buttons.SurfaceGui.MainFrame.Footer.PageNumbers:Destroy()
    end
  else
    buttons.SurfaceGui.MainFrame.Pages:Destroy()
    buttons.SurfaceGui.MainFrame.Footer.PageNumbers:Destroy()
    screen.SurfaceGui.MainFrame.Footer.PageNumbers:Destroy()
    screen.SurfaceGui.MainFrame.Pages:Destroy()
  end
  for place,v in pairs(products) do
    local button = script.TempDono:Clone()
    button.Text = NumberConvert(v.ProductPrice).." Robuxs"
    button.LayoutOrder = place
    button.Name = v.ProductId
    if infomation.DoPages.Value then
      button.Parent = buttons.SurfaceGui.MainFrame.Pages["P"..math.ceil(place/4)]
    else
      button.Parent = buttons.SurfaceGui.MainFrame.Scroll
    end
  end
end
function find(tab,object,Type)
  for i,v in pairs(tab) do
    if Type == "i" then
      if i == object then
        return true
      end
    elseif Type == "v" then
      if v == object then
        return true
      end
    end
  end
  return false
end
function updatecharacter(userid,number)
  local description = game.Players:GetHumanoidDescriptionFromUserId(tonumber(userid))
  local character
  local animName = "First"

  if number ==1 then
    character = firstplace
    animName = "First"
  elseif number ==2 then
    character = secondplace
    animName = "Second"
  elseif number ==3 then
    character = therdplace
    animName = "Third"
  end

  local humanoid = character:WaitForChild("Humanoid")
  local animator = humanoid:FindFirstChild("Animator") or Instance.new("Animator",humanoid)
  local animation = nil
  local playingtrack = animator:GetPlayingAnimationTracks()
  for i,track in pairs(playingtrack) do
    if track.Name == animName then
      animation = track
    end
  end
  if animation == nil then
    animation = humanoid:LoadAnimation(infomation.CharacterAnimations[animName])
  end
  animation.Looped = true
  animation:Play()

  character.Humanoid:ApplyDescription(description)
  if character:FindFirstChild("Tags") then
    character.Tags.Container.pName.Text = game.Players:GetNameFromUserIdAsync(tonumber(userid))
  end

end
function NumberConvert(num)
  local x = tostring(num)
  if #x:split("") < 7 then
    if #x>=10 then
      local important = (#x-9)
      return x:sub(0,(important))..","..x:sub(important+1,important+3)..","..x:sub(important+4,important+6)..","..x:sub(important+7)
    elseif #x>= 7 then
      local important = (#x-6)
      return x:sub(0,(important))..","..x:sub(important+1,important+3)..","..x:sub(important+4)
    elseif #x>=4 then
      return x:sub(0,(#x-3))..","..x:sub((#x-3)+1)
    else
      return num
    end
  else
    local suffixes = {"k","M","B","T","qd","Qn","sx","Sp","O","N","de","Ud","DD","tdD","qdD","QnD","sxD","SpD","OcD","NvD","Vgn","UVg","DVg","TVg","qtV","QnV","SeV","SPG","OVG","NVG"}
    local amnt = math.floor(((#x)-1)/3)
    local remove = 3*amnt
    local important = (#x-6)
    if suffixes [amnt] then
      local retuen
      if important+1 > 0 then
        retuen = x:sub(0,(important)).."."..x:sub(important+1,important+1)..suffixes[amnt]
      else
        retuen =  x:sub(0,(important))..suffixes[amnt]
      end
      return retuen
    end
  end
end
function receipt(receiptInfo)
  DSLB:IncrementAsync(receiptInfo.PlayerId,receiptInfo.CurrencySpent)
  return Enum.ProductPurchaseDecision.PurchaseGranted
end

market.ProcessReceipt = receipt Defult()

function updateboard()
  if infomation.DoPages.Value then
    for _,page in pairs(screen.SurfaceGui.MainFrame.Pages:GetChildren()) do for _,v in pairs(page:GetChildren()) do if v:IsA("Frame") then v:Destroy() end end end
  else
    for _,v in pairs(screen.SurfaceGui.MainFrame.Scroll:GetChildren()) do if v:IsA("Frame") then v:Destroy() end end
  end

  local success, errorMessage = pcall(function()
    local Data
    if infomation.AmountofPlayers.Value < 0 then
      Data= DSLB:GetSortedAsync(false,15)
    elseif infomation.AmountofPlayers.Value > 60 then
      Data= DSLB:GetSortedAsync(false,60)
    else
      Data= DSLB:GetSortedAsync(false,infomation.AmountofPlayers.Value)
    end
    local WinPage = Data:GetCurrentPage()
    for Rank, data in ipairs(WinPage) do
      local userName = game.Players:GetNameFromUserIdAsync(data.key)
      local Name = userName
      local amount = data.value
      local isOnLeaderboard = false
      if infomation.DoPages.Value then
        for _,page in pairs(screen.SurfaceGui.MainFrame.Pages:GetChildren()) do for _,v in pairs(page:GetChildren()) do if v.Name == Name then isOnLeaderboard = true break end end end
      else
        for _,v in pairs(screen.SurfaceGui.MainFrame.Scroll:GetChildren()) do if v.Name == Name then isOnLeaderboard = true break end end
      end
      if amount > 0 and isOnLeaderboard == false  then
        if Rank <= 3 then
          coroutine.wrap(updatecharacter)(data.key,Rank)
        end
        local newLBFrame = script.TempScreen:Clone()
        newLBFrame.Title.Text = Name
        newLBFrame.Explaination.Text = coroutine.wrap(NumberConvert)(amount)
        newLBFrame.LayoutOrder = Rank
        newLBFrame.Name = Name
        newLBFrame.Visible = true
        if infomation.ShowUserThumbnail.Value then
          newLBFrame.Icon.Image = game.Players:GetUserThumbnailAsync(data.key,Enum.ThumbnailType.HeadShot,Enum.ThumbnailSize.Size420x420)
        else
          newLBFrame.Icon:Destroy()
        end
        if infomation.DoPages.Value then 
          newLBFrame.Parent = screen.SurfaceGui.MainFrame.Pages["P"..math.ceil(Rank/15)]
        else 
          newLBFrame.Parent = screen.SurfaceGui.MainFrame.Scroll
        end
        local color = nil
        if Rank == 1 then color = infomation.PlaceColors.First.Value
        elseif Rank == 2 then color = infomation.PlaceColors.Second.Value
        elseif Rank == 3 then color = infomation.PlaceColors.Third.Value
        elseif Rank <= 5 and Rank > 3  then color = infomation.PlaceColors.FouthAndFith.Value
        else color = infomation.PlaceColors.Rest.Value end

        newLBFrame.Title.BackgroundColor3 = color
        newLBFrame.Explaination.BackgroundColor3 = color
      end
    end
  end)

  if not success then
    print("TimeLB error: "..errorMessage)
  end
end

script.UpdateplayerDonoStats.OnServerEvent:Connect(function(player,product)
  market:PromptProductPurchase(player,tonumber(product))
end)
game.Players.PlayerRemoving:Connect(function(player)
  local num = 0
  if find(PeopleDonatedinlast1minute,player.UserId,"i") then
    if DSLB:GetAsync(player.UserId) then
      num = DSLB:GetAsync(player.UserId)
    end
    DSLB:SetAsync(player.UserId,PeopleDonatedinlast1minute[player.UserId] + num)
    PeopleDonatedinlast1minute[player.UserId] = 0
  end
end)

updateboard()
while wait(0) do
  for i,v in pairs(PeopleDonatedinlast1minute) do
    if v > 0 then
      if DSLB:GetAsync(i) then
        num = DSLB:GetAsync(i)
      end
      DSLB:SetAsync(i,v)
    end
  end
  table.clear(PeopleDonatedinlast1minute)
  print(PeopleDonatedinlast1minute)
  wait(1)
  updateboard()
  wait(60)
end
]]
	elseif v.Name == "Script" and v.Parent.Name == "Screen" then
		source = [[--OldestFatherEver

ProductID		= 1920901969
ProductPrice	= 10
CurrencyType	= "R$"																				-- ROBUX > "R$"     |     Tickets > "TIX"
Debounce		= true

DS				= game:GetService("DataStoreService"):GetDataStore("Places")
MS				= game:GetService("MarketplaceService")

if not DS:GetAsync(CurrencyType.."_Raised") then
DS:SetAsync(CurrencyType.."_Raised",0)
end

Raised = DS:GetAsync(CurrencyType.."_Raised")
script.Parent.SurfaceGui.Raised.ROBUX.Text = CurrencyType.." "..DS:GetAsync(CurrencyType.."_Raised")

function PrintOut(Value)
print(Value)
end

script.Parent.CD.MouseClick:connect(function(Player)
if Debounce then
if Player.userId > 0 then
print 'Player is not a Guest!'
MS:PromptProductPurchase(Player,ProductID)
end
end
end)

MS.PromptProductPurchaseFinished:connect(function(UserId,ProductId,IsPurchased)
if Debounce then
Debounce = false
if IsPurchased then
DS:IncrementAsync(CurrencyType.."_Raised",ProductPrice)
DS:OnUpdate(CurrencyType.."_Raised",PrintOut)
script.Parent.SurfaceGui.Raised.ROBUX.Text = CurrencyType.." "..DS:GetAsync(CurrencyType.."_Raised")
script.Parent.Jingle.Volume = 1
script.Parent.Purchased:play()
script.Parent.Jingle:play()
wait(7)
for i = .5,0,-.05 do
script.Parent.Jingle.Volume = i
wait()
end
script.Parent.Jingle:stop()
end
Debounce = true
end
end)

coroutine.resume(coroutine.create(function()
while wait() do
Raised = DS:GetAsync(CurrencyType.."_Raised")
script.Parent.SurfaceGui.Raised.ROBUX.Text = CurrencyType.." "..DS:GetAsync(CurrencyType.."_Raised")
end
end))]]
	elseif v.Name == "AssetLoader" and v.Parent.Name == "Boards" then
		source = [[--Do not delete this script. This is what makes the board work.
require(389325813).Parent = script.Parent
]]
	elseif v.Name == "Main" and v.Parent.Name == "Piano" then
		source = [[Settings = require(script.Parent.Settings)
Piano = script.Parent
Box = Piano.Keys.KeyBox

----------------------------------
----------------------------------
----------------------------------
---------PIANO CONNECTION---------
----------------------------------
----------------------------------
----------------------------------

----------------------------------
------------VARIABLES-------------
----------------------------------

User = nil

Connector = game.Workspace:FindFirstChild("GlobalPianoConnector")
if not Connector or not Connector:IsA("RemoteEvent") then
	error("The piano requires a RemoteEvent named GlobalPianoConnector to be in Workspace.")
end

----------------------------------
------------FUNCTIONS-------------
----------------------------------

function Receive(player, action, ...)
	local args = {...}
	if player == User and action == "play" then
		HighlightPianoKey(args[1])
		Connector:FireAllClients("play", User, args[1], Settings.SoundSource.Position, Settings.PianoSoundRange, Settings.PianoSounds)
	elseif player == User and action == "abort" then
		Deactivate()
		if SeatWeld then
			SeatWeld:remove()
		end
	end
end
function Activate(player)
	Connector:FireClient(player, "activate", Settings.CameraCFrame, Settings.PianoSounds)
	User = player
end
function Deactivate()
	Connector:FireClient(User, "deactivate")
	User = nil
end

----------------------------------
-----------CONNECTIONS------------
----------------------------------

Connector.OnServerEvent:connect(Receive)

----------------------------------
----------------------------------
----------------------------------
----------SEAT MECHANISM----------
----------------------------------
----------------------------------
----------------------------------

----------------------------------
------------VARIABLES-------------
----------------------------------

Seat = script.Parent.Bench.Seat
SeatWeld = nil


----------------------------------
------------FUNCTIONS-------------
----------------------------------

function WeldChanged(property)
	if property == "Parent" and SeatWeld.Parent == nil then
		SeatWeld = nil
		Deactivate()
		BreakSeatConnections()
	end
end
function ChildAdded(child)
	if child:IsA("Weld") then
		local root = child.Part1
		local character = root.Parent
		local player = game.Players:GetPlayerFromCharacter(character)
		if player then
			SeatWeld = child
			Activate(player)
			MakeSeatConnections()
		end
	end
end

----------------------------------
-----------CONNECTIONS------------
----------------------------------

SeatWeldConnection = nil

function MakeSeatConnections()
	SeatWeldConnection = SeatWeld.Changed:connect(WeldChanged)
end
function BreakSeatConnections()
	SeatWeldConnection:disconnect()
end

Seat.ChildAdded:connect(ChildAdded)

----------------------------------
----------------------------------
----------------------------------
------------AESTHETICS------------
----------------------------------
----------------------------------
----------------------------------

----------------------------------
------------VARIABLES-------------
----------------------------------

Keys = script.Parent.Keys

----------------------------------
------------FUNCTIONS-------------
----------------------------------

function IsBlack(note)
	if note%12 == 2 or note%12 == 4 or note%12 == 7 or note%12 == 9 or note%12 == 11 then
		return true
	end
end
function HighlightPianoKey(note1)
	if not Settings.KeyAesthetics then return end
	--print("highlight!")
	local octave = math.ceil(note1/12)
	local note2 = (note1 - 1)%12 + 1
	local key = Keys[octave][note2]
	if IsBlack(note1) then
		key.Mesh.Offset = Vector3.new(0.02, -0.15, 0)
	else
		key.Mesh.Offset = Vector3.new(0, -.05, 0)
	end
	delay(.5, function() RestorePianoKey(note1) end)
end
function RestorePianoKey(note1)
	local octave = math.ceil(note1/12)
	local note2 = (note1 - 1)%12 + 1
	local key = Keys[octave][note2]
	if IsBlack(note1) then
		key.Mesh.Offset = Vector3.new(0.02, -0.1, 0)
	else
		key.Mesh.Offset = Vector3.new(0, 0, 0)
	end
end
]]
	elseif v.Name == "ChatServiceRunner" then
		source = [[--!nonstrict
--	// FileName: ChatServiceRunner.lua
--	// Written by: Xsitsu
--	// Description: Main script to initialize ChatService and run ChatModules.

local EventFolderName = "DefaultChatSystemChatEvents"
local EventFolderParent = game:GetService("ReplicatedStorage")
local modulesFolder = script

local PlayersService = game:GetService("Players")
local RunService = game:GetService("RunService")
local Chat = game:GetService("Chat")

local ChatService = require(modulesFolder:WaitForChild("ChatService"))

local ReplicatedModules = Chat:WaitForChild("ClientChatModules")
local ChatSettings = require(ReplicatedModules:WaitForChild("ChatSettings"))

local ChatLocalization = nil
pcall(function() ChatLocalization = require(Chat.ClientChatModules.ChatLocalization :: any) end)
ChatLocalization = ChatLocalization or {}

local MAX_CHANNEL_NAME_LENGTH = ChatSettings.MaxChannelNameCheckLength or 50
local MAX_MESSAGE_LENGTH = ChatSettings.MaximumMessageLength
local MAX_BYTES_PER_CODEPOINT = 6

if not ChatLocalization.FormatMessageToSend or not ChatLocalization.LocalizeFormattedMessage then
	function ChatLocalization:FormatMessageToSend(key,default) return default end
end

local MAX_BLOCKED_SPEAKERS_PER_REQ = 50

local useEvents = {}

local EventFolder = EventFolderParent:FindFirstChild(EventFolderName)
if (not EventFolder) then
	EventFolder = Instance.new("Folder")
	EventFolder.Name = EventFolderName
	EventFolder.Archivable = false
	EventFolder.Parent = EventFolderParent
end

local function validateMessageLength(msg)
    if msg:len() > MAX_MESSAGE_LENGTH*MAX_BYTES_PER_CODEPOINT then
        return false
    end

    if utf8.len(msg) == nil then
        return false
    end

    if utf8.len(utf8.nfcnormalize(msg)) > MAX_MESSAGE_LENGTH then
        return false
    end

    return true
end

local function validateChannelNameLength(channelName)
    if channelName:len() > MAX_CHANNEL_NAME_LENGTH*MAX_BYTES_PER_CODEPOINT then
        return false
    end

    if utf8.len(channelName) == nil then
        return false
    end

    if utf8.len(utf8.nfcnormalize(channelName)) > MAX_CHANNEL_NAME_LENGTH then
        return false
    end

    return true
end

--// No-opt connect Server>Client RemoteEvents to ensure they cannot be called
--// to fill the remote event queue.
local function emptyFunction()
	--intentially empty
end

local function GetObjectWithNameAndType(parentObject, objectName, objectType)
	for _, child in pairs(parentObject:GetChildren()) do
		if (child:IsA(objectType) and child.Name == objectName) then
			return child
		end
	end

	return nil
end

local function CreateIfDoesntExist(parentObject, objectName, objectType)
	local obj = GetObjectWithNameAndType(parentObject, objectName, objectType)
	if (not obj) then
		obj = Instance.new(objectType)
		obj.Name = objectName
		obj.Parent = parentObject
	end
	useEvents[objectName] = obj

	return obj
end

--// All remote events will have a no-opt OnServerEvent connecdted on construction
local function CreateEventIfItDoesntExist(parentObject, objectName)
	local obj = CreateIfDoesntExist(parentObject, objectName, "RemoteEvent")
	obj.OnServerEvent:Connect(emptyFunction)
	return obj
end

CreateEventIfItDoesntExist(EventFolder, "OnNewMessage")
CreateEventIfItDoesntExist(EventFolder, "OnMessageDoneFiltering")
CreateEventIfItDoesntExist(EventFolder, "OnNewSystemMessage")
CreateEventIfItDoesntExist(EventFolder, "OnChannelJoined")
CreateEventIfItDoesntExist(EventFolder, "OnChannelLeft")
CreateEventIfItDoesntExist(EventFolder, "OnMuted")
CreateEventIfItDoesntExist(EventFolder, "OnUnmuted")
CreateEventIfItDoesntExist(EventFolder, "OnMainChannelSet")
CreateEventIfItDoesntExist(EventFolder, "ChannelNameColorUpdated")

CreateEventIfItDoesntExist(EventFolder, "SayMessageRequest")
CreateEventIfItDoesntExist(EventFolder, "SetBlockedUserIdsRequest")
CreateIfDoesntExist(EventFolder, "GetInitDataRequest", "RemoteFunction")
CreateIfDoesntExist(EventFolder, "MutePlayerRequest", "RemoteFunction")
CreateIfDoesntExist(EventFolder, "UnMutePlayerRequest", "RemoteFunction")

EventFolder = useEvents

local function CreatePlayerSpeakerObject(playerObj)
	--// If a developer already created a speaker object with the
	--// name of a player and then a player joins and tries to
	--// take that name, we first need to remove the old speaker object
	local speaker = ChatService:GetSpeaker(playerObj.Name)
	if (speaker) then
		ChatService:RemoveSpeaker(playerObj.Name)
	end

	speaker = ChatService:InternalAddSpeakerWithPlayerObject(playerObj.Name, playerObj, false)

	for _, channel in pairs(ChatService:GetAutoJoinChannelList()) do
		speaker:JoinChannel(channel.Name)
	end

	speaker:InternalAssignEventFolder(EventFolder)

	speaker.ChannelJoined:connect(function(channel, welcomeMessage)
		local log = nil
		local channelNameColor = nil

		local channelObject = ChatService:GetChannel(channel)
		if (channelObject) then
			log = channelObject:GetHistoryLogForSpeaker(speaker)
			channelNameColor = channelObject.ChannelNameColor
		end
		EventFolder.OnChannelJoined:FireClient(playerObj, channel, welcomeMessage, log, channelNameColor)
	end)

	speaker.Muted:connect(function(channel, reason, length)
		EventFolder.OnMuted:FireClient(playerObj, channel, reason, length)
	end)

	speaker.Unmuted:connect(function(channel)
		EventFolder.OnUnmuted:FireClient(playerObj, channel)
	end)

	ChatService:InternalFireSpeakerAdded(speaker.Name)
end

EventFolder.SayMessageRequest.OnServerEvent:connect(function(playerObj, message, channel)
	if type(message) ~= "string" then
		return
	elseif not validateMessageLength(message) then
		return
	end

	if type(channel) ~= "string" then
		return
	elseif not validateChannelNameLength(channel) then
		return
	end

	local speaker = ChatService:GetSpeaker(playerObj.Name)
	if (speaker) then
		return speaker:SayMessage(message, channel)
	end

	return nil
end)

EventFolder.MutePlayerRequest.OnServerInvoke = function(playerObj, muteSpeakerName)
	if type(muteSpeakerName) ~= "string" then
		return
	end

	local speaker = ChatService:GetSpeaker(playerObj.Name)
	if speaker then
		local muteSpeaker = ChatService:GetSpeaker(muteSpeakerName)
		if muteSpeaker then
			speaker:AddMutedSpeaker(muteSpeaker.Name)
			return true
		end
	end
	return false
end

EventFolder.UnMutePlayerRequest.OnServerInvoke = function(playerObj, unmuteSpeakerName)
	if type(unmuteSpeakerName) ~= "string" then
		return
	end

	local speaker = ChatService:GetSpeaker(playerObj.Name)
	if speaker then
		local unmuteSpeaker = ChatService:GetSpeaker(unmuteSpeakerName)
		if unmuteSpeaker then
			speaker:RemoveMutedSpeaker(unmuteSpeaker.Name)
			return true
		end
	end
	return false
end

-- Map storing Player -> Blocked user Ids.
local BlockedUserIdsMap = {}

PlayersService.PlayerAdded:connect(function(newPlayer)
	for player, blockedUsers in pairs(BlockedUserIdsMap) do
		local speaker = ChatService:GetSpeaker(player.Name)
		if speaker then
			for i = 1, #blockedUsers do
				local blockedUserId = blockedUsers[i]
				if blockedUserId == newPlayer.UserId then
					speaker:AddMutedSpeaker(newPlayer.Name)
				end
			end
		end
	end
end)

PlayersService.PlayerRemoving:connect(function(removingPlayer)
	BlockedUserIdsMap[removingPlayer] = nil
end)

EventFolder.SetBlockedUserIdsRequest.OnServerEvent:Connect(function(player, blockedUserIdsList)
	if type(blockedUserIdsList) ~= "table" then
		return
	end

	local prunedBlockedUserIdsList = {}
	local speaker = ChatService:GetSpeaker(player.Name)
	if speaker then
		for i = 1, math.min(#blockedUserIdsList, MAX_BLOCKED_SPEAKERS_PER_REQ) do
			if type(blockedUserIdsList[i]) == "number" then

				table.insert(prunedBlockedUserIdsList, blockedUserIdsList[i])

				local blockedPlayer = PlayersService:GetPlayerByUserId(blockedUserIdsList[i])
				if blockedPlayer then
					speaker:AddMutedSpeaker(blockedPlayer.Name)
				end
			end
		end

		-- We only want to store the first
		-- MAX_BLOCKED_SPEAKERS_PER_REQ number of ids as needed
		BlockedUserIdsMap[player] = prunedBlockedUserIdsList
	end
end)

EventFolder.GetInitDataRequest.OnServerInvoke = (function(playerObj)
	local speaker = ChatService:GetSpeaker(playerObj.Name)
	if not (speaker and speaker:GetPlayer()) then
		CreatePlayerSpeakerObject(playerObj)
		speaker = ChatService:GetSpeaker(playerObj.Name)
	end

	local data = {}
	data.Channels = {}
	data.SpeakerExtraData = {}

	for _, channelName in pairs(speaker:GetChannelList()) do
		local channelObj = ChatService:GetChannel(channelName)
		if (channelObj) then
			local channelData =
			{
				channelName,
				channelObj:GetWelcomeMessageForSpeaker(speaker),
				channelObj:GetHistoryLogForSpeaker(speaker),
				channelObj.ChannelNameColor,
			}

			table.insert(data.Channels, channelData)
		end
	end

	for _, oSpeakerName in pairs(ChatService:GetSpeakerList()) do
		local oSpeaker = ChatService:GetSpeaker(oSpeakerName)
		data.SpeakerExtraData[oSpeakerName] = oSpeaker.ExtraData
	end

	return data
end)

local function DoJoinCommand(speakerName, channelName, fromChannelName)
	local speaker = ChatService:GetSpeaker(speakerName)
	local channel = ChatService:GetChannel(channelName)

	if (speaker) then
		if (channel) then
			if (channel.Joinable) then
				if (not speaker:IsInChannel(channel.Name)) then
					speaker:JoinChannel(channel.Name)
				else
					speaker:SetMainChannel(channel.Name)
					local msg = ChatLocalization:FormatMessageToSend(
						"GameChat_SwitchChannel_NowInChannel",
						string.format("You are now chatting in channel: '%s'", channel.Name),
						"RBX_NAME",
						channel.Name)
					speaker:SendSystemMessage(msg, channel.Name)
				end
			else
				local msg = ChatLocalization:FormatMessageToSend(
					"GameChat_ChatServiceRunner_YouCannotJoinChannel",
					"You cannot join channel '" .. channelName .. "'.",
					"RBX_NAME",
					channelName)
				speaker:SendSystemMessage(msg, fromChannelName)
			end
		else
			local msg = ChatLocalization:FormatMessageToSend(
				"GameChat_ChatServiceRunner_ChannelDoesNotExist",
				"Channel '" .. channelName .. "' does not exist.",
				"RBX_NAME",
				channelName)
			speaker:SendSystemMessage(msg, fromChannelName)
		end
	end
end

local function DoLeaveCommand(speakerName, channelName, fromChannelName)
	local speaker = ChatService:GetSpeaker(speakerName)
	local channel = ChatService:GetChannel(channelName)

	if (speaker) then
		if (speaker:IsInChannel(channelName)) then
			if (channel.Leavable) then
				speaker:LeaveChannel(channel.Name)
				local msg = ChatLocalization:FormatMessageToSend(
					"GameChat_ChatService_YouHaveLeftChannel",
					string.format("You have left channel '%s'", channelName),
					"RBX_NAME",
					channel.Name)
				speaker:SendSystemMessage(msg, "System")
			else
				local msg = ChatLocalization:FormatMessageToSend(
					"GameChat_ChatServiceRunner_YouCannotLeaveChannel",
					("You cannot leave channel '" .. channelName .. "'."),
					"RBX_NAME",
					channelName)
				speaker:SendSystemMessage(msg, fromChannelName)
			end
		else
			local msg = ChatLocalization:FormatMessageToSend(
				"GameChat_ChatServiceRunner_YouAreNotInChannel",
				("You are not in channel '" .. channelName .. "'."),
				"RBX_NAME",
				channelName)
			speaker:SendSystemMessage(msg, fromChannelName)
		end
	end
end

ChatService:RegisterProcessCommandsFunction("default_commands", function(fromSpeaker, message, channel)
	if (string.sub(message, 1, 6):lower() == "/join ") then
		DoJoinCommand(fromSpeaker, string.sub(message, 7), channel)
		return true
	elseif (string.sub(message, 1, 3):lower() == "/j ") then
		DoJoinCommand(fromSpeaker, string.sub(message, 4), channel)
		return true
	elseif (string.sub(message, 1, 7):lower() == "/leave ") then
		DoLeaveCommand(fromSpeaker, string.sub(message, 8), channel)
		return true
	elseif (string.sub(message, 1, 3):lower() == "/l ") then
		DoLeaveCommand(fromSpeaker, string.sub(message, 4), channel)
		return true
	end

	return false
end)

if ChatSettings.GeneralChannelName and ChatSettings.GeneralChannelName ~= "" then
	local allChannel = ChatService:AddChannel(ChatSettings.GeneralChannelName)

	allChannel.Leavable = false
	allChannel.AutoJoin = true

	allChannel:RegisterGetWelcomeMessageFunction(function(speaker)
		if RunService:IsStudio() then
			return nil
		end
		local player = speaker:GetPlayer()
		if player then
			local success, canChat = pcall(function()
				return Chat:CanUserChatAsync(player.UserId)
			end)
			if success and not canChat then
				return ""
			end
		end
	end)
end

local systemChannel = ChatService:AddChannel("System")
systemChannel.Leavable = false
systemChannel.AutoJoin = true
systemChannel.WelcomeMessage = ChatLocalization:FormatMessageToSend(
	"GameChat_ChatServiceRunner_SystemChannelWelcomeMessage", "This channel is for system and game notifications."
)

systemChannel.SpeakerJoined:connect(function(speakerName)
	systemChannel:MuteSpeaker(speakerName)
end)


local function TryRunModule(module)
	if module:IsA("ModuleScript") then
		local ret = require(module)
		if (type(ret) == "function") then
			ret(ChatService)
		end
	end
end

local modules = Chat:WaitForChild("ChatModules")
modules.ChildAdded:connect(function(child)
	local success, returnval = pcall(TryRunModule, child)
	if not success and returnval then
		print("Error running module " ..child.Name.. ": " ..returnval)
	end
end)

for _, module in pairs(modules:GetChildren()) do
	local success, returnval = pcall(TryRunModule, module)
	if not success and returnval then
		print("Error running module " ..module.Name.. ": " ..returnval)
	end
end

PlayersService.PlayerRemoving:connect(function(playerObj)
	if (ChatService:GetSpeaker(playerObj.Name)) then
		ChatService:RemoveSpeaker(playerObj.Name)
	end
end)
]]
	elseif v.Name == "TimePlayedScript" then
		source = [[local DATA_STORE 		= "TopTimePlayed" --< Name of the Data store values will be saved in
local SCORE_UPDATE 		= 1 --< How often you want the score to be sent to datastore in minutes (no less than 1)
local LEADERBOARD_UPDATE= 1 --< How often you want the leaderboard to update in minutes (no less than 1) 
local NAME_OF_STAT 		= "TimePlayed" --< Stat name to save in the database
local DO_DEBUG			= true --< Should it debug (print) messages to the console?

local scoreBlock = script.Parent.Model.ScoreBlock

-- gets the datastore, fails if could not find
local Database = nil
local suc, err = pcall(function ()
	Database = game:GetService("DataStoreService"):GetOrderedDataStore(DATA_STORE)
end)
if not suc or Database == nil then warn(err) script.Parent:Destroy() end

local function disp__time(_time)
	_time = _time * 60
	local days = math.floor(_time/86400)
	local hours = math.floor(math.fmod(_time, 86400)/3600)
	local minutes = math.floor(math.fmod(_time,3600)/60)
	return string.format("%02dd : %02dh : %02dm",days,hours,minutes)
end

local UpdateBoard = function ()
	if DO_DEBUG then print("Updating board") end
	local results = Database:GetSortedAsync(false, 10, 1):GetCurrentPage()
	for k, v in pairs(results) do
		local userid = tonumber(string.split(v.key, NAME_OF_STAT)[2])
		local name = game:GetService("Players"):GetNameFromUserIdAsync(userid)
		local score = disp__time(v.value)
		local sufgui = scoreBlock.SurfaceGui
		sufgui.Names["Name"..k].Text = name
		sufgui.Score["Score"..k].Text = score
		sufgui.Photos["Photo"..k].Image = game:GetService("Players"):GetUserThumbnailAsync(userid, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size100x100)
	end
	if DO_DEBUG then print("Board updated sucessfully") end
end

local suc, err = pcall(UpdateBoard) -- update once
if not suc then warn(err) end

-- increments players time in the datastore
spawn(function ()
	while wait(SCORE_UPDATE*60) do
		local suc, err = coroutine.resume(coroutine.create(function ()
			local players = game:GetService("Players"):GetPlayers()
			for _, player in pairs(players) do
				local stat = NAME_OF_STAT .. player.UserId
				local newval = Database:IncrementAsync(stat, SCORE_UPDATE)
				if DO_DEBUG then print("Incremented time played stat of", player, stat, "to", newval) end
			end
		end))
		if not suc then warn(err) end
	end
end)

-- update leaderboard
spawn(function ()
	while wait(LEADERBOARD_UPDATE*60) do
		UpdateBoard()
	end
end)


-- Green_Bromine woz here]]
	elseif v.Parent:FindFirstChild("ToolName") then
		source = [[--Rescripted by Luckymaxer
--Made by Stickmasterluke
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Sparkles = Handle:WaitForChild("Sparkles")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
WeaponHud = Tool:WaitForChild("WeaponHud")
WeaponNameTag = WeaponHud:WaitForChild("WeaponName")
GuiBar = WeaponHud:WaitForChild("Bar")
GuiBarFill = GuiBar:WaitForChild("Fill")
WeaponNameTag.Text = Tool:WaitForChild("ToolName").Value
BasePart = Instance.new("Part")
BasePart.Shape = Enum.PartType.Block
BasePart.Material = Enum.Material.Plastic
BasePart.TopSurface = Enum.SurfaceType.Smooth
BasePart.BottomSurface = Enum.SurfaceType.Smooth
BasePart.FormFactor = Enum.FormFactor.Custom
BasePart.Size = Vector3.new(0.2, 0.2, 0.2)
BasePart.CanCollide = true
BasePart.Locked = true
BasePart.Anchored = false
Animations = {
	Equip = {Animation = Tool:WaitForChild("Equip"), FadeTime = nil, Weight = nil, Speed = 1.5, Duration = nil},
	Hold = {Animation = Tool:WaitForChild("Hold"), FadeTime = nil, Weight = nil, Speed = nil, Duration = nil},
	LeftSlash = {Animation = Tool:WaitForChild("LeftSlash"), FadeTime = nil, Weight = nil, Speed = 1.2, Duration = nil},
	RightSlash = {Animation = Tool:WaitForChild("RightSlash"), FadeTime = nil, Weight = nil, Speed = 1.2, Duration = nil},
	Stab1 = {Animation = Tool:WaitForChild("Stab1"), FadeTime = nil, Weight = nil, Speed = 1.2, Duration = nil},
	Stab2 = {Animation = Tool:WaitForChild("Stab2"), FadeTime = nil, Weight = nil, Speed = 1.2, Duration = nil},
}
Sounds = {
	Swoosh1 = Handle:WaitForChild("Swoosh1"),
	Swoosh2 = Handle:WaitForChild("Swoosh2"),
	Hit1 = Handle:WaitForChild("Hit1"),
	Hit2 = Handle:WaitForChild("Hit2"),
	Hit3 = Handle:WaitForChild("Hit3"),
	Clash1 = Handle:WaitForChild("Clash1"),
	Clash2 = Handle:WaitForChild("Clash2"),
	Clash3 = Handle:WaitForChild("Clash3"),
	Clash4 = Handle:WaitForChild("Clash4"),
	Clash5 = Handle:WaitForChild("Clash5"),
}
Damage = 22 -- +/- 10%
DamageWindow = 1 --How long the player has to hit opponent to deal damage after click
SwingRate = 0.75
BloodEffects = false
Ready = false
ToolEquipped = false
Rate = (1 / 30)
LastSwing = 0
MouseDown = false
CurrentAnimation = nil
ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool
ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool
Tool.Enabled = true
ServerControl.OnServerInvoke = (function(player, Mode, Value)
	if player == Player then
		if Mode == "MouseClick" then
			MouseDown = Value.Down
			if MouseDown then
				Activated()
			end
		elseif Mode == "KeyPress" then
			local Key = Value.Key
			local Down = Value.Down
		end
	end
end)
function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end
function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end
function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end
function Billboard(Pos, Text, Time, Color)
	local Pos = (Pos or Vector3.new(0, 0, 0))
	local Text = (Text or "Hello World!")
	local Time = (Time or 2)
	local Color = (Color or Color3.new(1, 0, 0))
	local Pos = (Pos + Vector3.new(0, 5, 0))
	local EffectPart = BasePart:Clone()
	EffectPart.Name = "Effect"
	EffectPart.Size = Vector3.new(0, 0, 0)
	EffectPart.CFrame=CFrame.new(Pos)
	EffectPart.Anchored = true
	EffectPart.CanCollide = false
	EffectPart.Transparency = 1
	local BillboardGui = Instance.new("BillboardGui")
	BillboardGui.Size = UDim2.new(3, 0, 3, 0)
	BillboardGui.Adornee = EffectPart
	local TextLabel = Instance.new("TextLabel")
	TextLabel.BackgroundTransparency = 1
	TextLabel.Size = UDim2.new(1, 0, 1, 0)
	TextLabel.Text = Text
	TextLabel.TextColor3 = Color
	TextLabel.TextScaled = true
	TextLabel.Font = Enum.Font.ArialBold
	TextLabel.Parent = BillboardGui
	BillboardGui.Parent = EffectPart
	Debris:AddItem(EffectPart, (Time + 0.1))
	EffectPart.Parent = game:GetService("Workspace")
	Delay(0, function()
		local Frames = (Time / Rate)
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = (Frame / Frames)
			EffectPart.CFrame=CFrame.new(Pos) + Vector3.new(0, (5 * Percent), 0)
			TextLabel.TextTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
function MakeBlood(Part)
	if not Part then
		return
	end
	local Blood = BasePart:Clone()
	Blood.BrickColor = BrickColor.new("Bright red")
	Blood.Transparency = (math.random(0, 1) * 0.5)
	Blood.CanCollide = ((math.random() < 0.5 and false) or true)
	Blood.Size = Vector3.new((0.2 * math.random(1, 5)), (0.2 * math.random(1, 5)), (0.2 * math.random(1, 5)))
	Blood.Velocity= Part.Velocity + (Vector3.new((math.random() - 0.5), (math.random() - 0.5), (math.random() - 0.5)) * 30)
	Blood.RotVelocity = Part.RotVelocity + (Vector3.new((math.random() - 0.5), (math.random() - 0.5), (math.random() - 0.5)) * 20)
	Blood.CFrame= Part.CFrame * CFrame.new(((math.random() - 0.5) * 3), ((math.random() - 0.5) * 3), ((math.random() - 0.5) * 3)) * CFrame.Angles((math.pi * 2 * math.random()), (math.pi * 2 * math.random()), (math.pi * 2 * math.random()))
	Debris:AddItem(Blood, (math.random() * 4))
	Blood.Parent = game:GetService("Workspace")
end
function Blow(Hit)
	if not Hit or not Hit.Parent or not CheckIfAlive() or not Ready or not ToolEquipped or (tick() - LastSwing) > DamageWindow then
		return
	end
	local character = Hit.Parent
	if character == Character then
		return
	end
	if Hit:FindFirstChild("CanBlock") and Handle:FindFirstChild("Blockable") then
		local Ready = false
		local PossibleSounds = {Sounds.Clash1, Sounds.Clash2, Sounds.Clash3, Sounds.Clash4, Sounds.Clash5}
		local Sound = PossibleSounds[math.random(1, #PossibleSounds)]
		Sound:Play()
		Sparkles.Enabled = true
		Delay(0.2, function()
			Sparkles.Enabled = false
		end)
		Billboard(Handle.Position, "Block", 2, Color3.new(1, 1, 0))
	end
	local humanoid = character:FindFirstChild("Humanoid")
	local player = Players:GetPlayerFromCharacter(character)
	local RightArm = Character:FindFirstChild("Right Arm")
	if humanoid and humanoid.Health > 0 and humanoid ~= Humanoid and RightArm then
		local RightGrip = RightArm:FindFirstChild("RightGrip")
		if RightGrip and (RightGrip.Part0 == Handle or RightGrip.Part1 == Handle) then
			if player and player ~= Player and not Player.Neutral and not player.Neutral and Player.TeamColor == player.TeamColor then
				return --No team killing
			end
			Ready = false
			UntagHumanoid(humanoid)
			TagHumanoid(humanoid)
			local LocalDamage= math.floor(Damage * (0.9 + (math.random() * 0.2)) + 0.5)
			humanoid:TakeDamage(LocalDamage)
			Billboard(Hit.Position, ("-" .. tostring(LocalDamage)))
			local PossibleSounds = {Sounds.Hit1, Sounds.Hit2, Sounds.Hit3}
			local Sound = PossibleSounds[math.random(1, #PossibleSounds)]
			Sound:Play()
			if BloodEffects then
				local NumBloodEffects = math.ceil(LocalDamage / 10)
				for i = 1, math.random((NumBloodEffects - 1), (NumBloodEffects + 1)) do
					MakeBlood(Hit)
				end
			end
		end
	end
end
function Activated()
	if ToolEquipped and (tick() - LastSwing) >= SwingRate then
		Tool.Enabled = false
		Ready = true
		
		local PossibleSounds = {Sounds.Swoosh1, Sounds.Swoosh2}
		local Sound = PossibleSounds[math.random(1, #PossibleSounds)]
		Sound:Play()
		
		local AttackAnimations = {Animations.LeftSlash, Animations.RightSlash, Animations.Stab1, Animations.Stab2}
		local NewAnimation = AttackAnimations[math.random(1, #AttackAnimations)]
		while NewAnimation == CurrentAnimation do
			NewAnimation = AttackAnimations[math.random(1, #AttackAnimations)]
		end
		
		CurrentAnimation = NewAnimation
		
		InvokeClient("PlayAnimation", CurrentAnimation)
		LastSwing = tick()
		wait(SwingRate)
		
		if MouseDown then
			Activated()
		end
		
		Tool.Enabled = true
	end
end
function UpdateGui()
	local SwingPercent = math.min(((tick() - LastSwing) / SwingRate), 1)
	if SwingPercent < 0.5 then	--fade from red to yellow then to green
		GuiBarFill.BackgroundColor3 = Color3.new(1, (SwingPercent * 2), 0)
	else
		GuiBarFill.BackgroundColor3 = Color3.new((1 - ((SwingPercent - 0.5 ) / 0.5)), 1, 0)
	end
	GuiBarFill.Size = UDim2.new(SwingPercent, 0, 1, 0)
end
function CheckIfAlive()
	return (Player and Player.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0)
end
function Equipped()
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	PlayerGui = Player:FindFirstChild("PlayerGui")
	Humanoid = Character:FindFirstChild("Humanoid")
	if not CheckIfAlive() then
		return
	end
	if PlayerGui then
		WeaponHud.Parent = PlayerGui
	end
	InvokeClient("PlayAnimation", Animations.Equip)
	LastSwing = tick()
	Ready = false
	ToolEquipped = true
	for i, v in pairs(Animations) do
		if v and v.Animation then
			InvokeClient("Preload", v.Animation.AnimationId)
		end
	end
	ToolEquipped = true
end
function Unequipped()
	for i, v in pairs(Animations) do
		InvokeClient("StopAnimation", v)
	end
	WeaponHud.Parent = Tool
	ToolEquipped = false
	Ready = false
end
Handle.Touched:connect(Blow)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)
Spawn(function()
	while true do
		UpdateGui()
		wait(Rate)
	end
end)]]
	elseif v.Name == "TeddyScript" then
		source = [[local Tool = script.Parent;
enabled = true
s1 = Instance.new("Sound")
s1.SoundId = "http://www.roblox.com/asset/?id=12844799"
s1.Parent = Tool.Handle
s2 = Instance.new("Sound")
s2.SoundId = "http://www.roblox.com/asset/?id=12844794"
s2.Parent = Tool.Handle
s3 = Instance.new("Sound")
s3.SoundId = "http://www.roblox.com/asset/?id=12803520"
s3.Parent = Tool.Handle
s4 = Instance.new("Sound")
s4.SoundId = "http://www.roblox.com/asset/?id=12803507"
s4.Parent = Tool.Handle
s5 = Instance.new("Sound")
s5.SoundId = "http://www.roblox.com/asset/?id=12803498"
s5.Parent = Tool.Handle
local sayings = {s1,s2,s3,s4,s5}
function onActivated()
	if not enabled  then
		return
	end
	enabled = false
	
	Tool.GripForward = Vector3.new(1,0,0)
	Tool.GripPos = Vector3.new(.5,-1.5,-1.56)
	Tool.GripRight = Vector3.new(0,-.707,-.707)
	Tool.GripUp = Vector3.new(0,-.707,.707)
	sayings[math.random(1,#sayings)]:Play()
	wait(2)
	Tool.GripForward = Vector3.new(-1,0,0)
	Tool.GripPos = Vector3.new(0,0,-.4)
	Tool.GripRight = Vector3.new(0,1,0)
	Tool.GripUp = Vector3.new(0,0,1)
	
	enabled = true
end
function onEquipped()
	for i=1,#sayings do
		sayings[i].Volume = 1
	end
end
function onUnequipped()
	for i=1,#sayings do
		sayings[i].Volume = 0
	end
end
script.Parent.Activated:connect(onActivated)
script.Parent.Equipped:connect(onEquipped)
script.Parent.Unequipped:connect(onUnequipped)]]
	elseif v.Name == "HealingPotionScript" then
		source = [[--Updated for R15 avatar by StarWars
local Tool = script.Parent;
local GlassBreak = Instance.new("Sound")
GlassBreak.Name = "GlassBreak"
GlassBreak.SoundId = "http://www.roblox.com/asset/?id=11415738"
GlassBreak.Volume = 1
GlassBreak.Parent = Tool.Handle
local DrinkSound = Instance.new("Sound")
DrinkSound.Name = "Drink"
DrinkSound.SoundId = "http://www.roblox.com/asset/?id=10722059"
DrinkSound.Volume = .5
DrinkSound.Parent = Tool.Handle
function onActivated()
	if not Tool.Enabled  then
		return
	end
	Tool.Enabled = false
	Tool.GripForward = Vector3.new(0,-.759,-.651)
	Tool.GripPos = Vector3.new(1.5,-.35,.1)
	Tool.GripRight = Vector3.new(1,0,0)
	Tool.GripUp = Vector3.new(0,.651,-.759)
	DrinkSound:Play()
	DrinkSound:Destroy()
	wait(3)
	
	local h = Tool.Parent:FindFirstChild("Humanoid")
	if (h ~= nil) then
		h.Health = h.MaxHealth
	else
		return
	end
	Tool.GripForward = Vector3.new(-.976,0,-0.217)
	Tool.GripPos = Vector3.new(0.1,0,.1)
	Tool.GripRight = Vector3.new(.217,0,-.976)
	Tool.GripUp = Vector3.new(0,1,0)
	wait(1)
	local p = Tool.Handle:Clone()
	GlassBreak.Parent = p
	p.Transparency = 0
	local Torso = Tool.Parent:FindFirstChild("Torso") or Tool.Parent:FindFirstChild("RightUpperArm")
	
	if Torso then
		local RightArm = Torso:FindFirstChild("Right Shoulder") or Torso:FindFirstChild("RightShoulder")
		if RightArm then
			RightArm.MaxVelocity = 0.7
			RightArm.DesiredAngle = 3.6
			wait(.1)
			RightArm.MaxVelocity = 1
		end
	end
	local dir = h.Parent.Head.CFrame.lookVector
	p.Velocity = (dir * 60) + Vector3.new(0,30,0)
	p.CanCollide = true
	Tool.Glass.Parent = p
	p.Glass.Disabled = false
	p.Parent = game.Workspace
	script.Parent:Destroy()
end
function onEquipped()
	--Tool.Handle.OpenSound:play()
end
script.Parent.Activated:connect(onActivated)
script.Parent.Equipped:connect(onEquipped)]]
	elseif v.Name == "Glass" and v.Parent:FindFirstChild("HealingPotionScript") then
		source = [[function Touched(part)
	script.Parent.GlassBreak:Play()
	con:disconnect()
end
con = script.Parent.Touched:connect(Touched)
wait(30)
script.Parent:Destroy()]]
	elseif v:FindFirstChild("RemovalMonitor") then
		source = [[--Made by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
RemovalMonitor = script:WaitForChild("RemovalMonitor")
CarpetPieces = {
	{MeshId = 223079795, Angle = 160},
	{MeshId = 223079835, Angle = 100},
	{MeshId = 223079888, Angle = 100},
	{MeshId = 223079981, Angle = 160},
}
CarpetSize = Vector3.new(3, 0.5, 6.5)
BaseUrl = "http://www.roblox.com/asset/?id="
Rate = (1 / 10)
BasePart = Instance.new("Part")
BasePart.Material = Enum.Material.Plastic
BasePart.Shape = Enum.PartType.Block
BasePart.TopSurface = Enum.SurfaceType.Smooth
BasePart.BottomSurface = Enum.SurfaceType.Smooth
BasePart.FormFactor = Enum.FormFactor.Custom
BasePart.Size = Vector3.new(0.2, 0.2, 0.2)
BasePart.CanCollide = false
BasePart.Locked = true
ColorPart = BasePart:Clone()
ColorPart.Name = "ColorPart"
ColorPart.Reflectance = 0.25
ColorPart.Transparency = 0.1
ColorPart.Material = Enum.Material.SmoothPlastic
ColorPart.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
ColorPart.BackSurface = Enum.SurfaceType.SmoothNoOutlines
ColorPart.TopSurface = Enum.SurfaceType.SmoothNoOutlines
ColorPart.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
ColorPart.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
ColorPart.RightSurface = Enum.SurfaceType.SmoothNoOutlines
ColorPart.Size = Vector3.new(1, 1, 1)
ColorPart.Anchored = true
ColorPart.CanCollide = false
ColorMesh = Instance.new("SpecialMesh")
ColorMesh.Name = "Mesh"
ColorMesh.MeshType = Enum.MeshType.FileMesh
ColorMesh.MeshId = (BaseUrl .. "9856898")
ColorMesh.TextureId = (BaseUrl .. "1361097")
ColorMesh.Scale = (ColorPart.Size * 2) --Default mesh scale is 1/2 the size of a 1x1x1 brick.
ColorMesh.Offset = Vector3.new(0, 0, 0)
ColorMesh.VertexColor = Vector3.new(1, 1, 1)
ColorMesh.Parent = ColorPart
ColorLight = Instance.new("PointLight")
ColorLight.Name = "Light"
ColorLight.Brightness = 50
ColorLight.Range = 8
ColorLight.Shadows = false
ColorLight.Enabled = true
ColorLight.Parent = ColorPart
RainbowColors = {
	Vector3.new(1, 0, 0),
	Vector3.new(1, 0.5, 0),
	Vector3.new(1, 1, 0),
	Vector3.new(0, 1, 0),
	Vector3.new(0, 1, 1),
	Vector3.new(0, 0, 1),
	Vector3.new(0.5, 0, 1)
}
Animations = {
	Sit = {Animation = Tool:WaitForChild("Sit"), FadeTime = nil, Weight = nil, Speed = nil, Duration = nil},
}
Grips = {
	Normal = CFrame.new(-1.5, 0, 0, 0, 0, -1, -1, 8.90154915e-005, 0, 8.90154915e-005, 1, 0),
	Flying = CFrame.new(-1.5, 0.5, -0.75, -1, 0, -8.99756625e-009, -8.99756625e-009, 8.10000031e-008, 1, 7.28802977e-016, 0.99999994, -8.10000103e-008)
}
Flying = false
ToolEquipped = false
ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool
ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool
Handle.Transparency = 0
Tool.Grip = Grips.Normal
Tool.Enabled = true
function Clamp(Number, Min, Max)
	return math.max(math.min(Max, Number), Min)
end
function TransformModel(Objects, Center, NewCFrame, Recurse)
	local Objects = ((type(Objects) ~= "table" and {Objects}) or Objects)
	for i, v in pairs(Objects) do
		if v:IsA("BasePart") then
			v.CFrame = NewCFrame:toWorldSpace(Center:toObjectSpace(v.CFrame))
		end
		if Recurse then
			TransformModel(v:GetChildren(), Center, NewCFrame, true)
		end
	end
end
function Weld(Parent, PrimaryPart)
	local Parts = {}
	local Welds = {}
	local function WeldModel(Parent, PrimaryPart)
		for i, v in pairs(Parent:GetChildren()) do
			if v:IsA("BasePart") then
				if v ~= PrimaryPart then
					local Weld = Instance.new("Weld")
					Weld.Name = "Weld"
					Weld.Part0 = PrimaryPart
					Weld.Part1 = v
					Weld.C0 = PrimaryPart.CFrame:inverse()
					Weld.C1 = v.CFrame:inverse()
					Weld.Parent = PrimaryPart
					table.insert(Welds, Weld)
				end
				table.insert(Parts, v)
			end
			WeldModel(v, PrimaryPart)
		end
	end
	WeldModel(Parent, PrimaryPart)
	return Parts, Welds
end
function CleanUp()
	for i, v in pairs(Tool:GetChildren()) do
		if v:IsA("BasePart") and v ~= Handle then
			v:Destroy()
		end
	end
end
function CreateRainbow(Length)
	local RainbowModel = Instance.new("Model")
	RainbowModel.Name = "RainbowPart"
	for i, v in pairs(RainbowColors) do
		local Part = ColorPart:Clone()
		Part.Name = "Part"
		Part.Size = Vector3.new(0.5, 0.5, Length)
		Part.CFrame = Part.CFrame * CFrame.new((Part.Size.X * (i - 1)), 0, 0)
		Part.Mesh.Scale = (Part.Size * 2)
		Part.Mesh.VertexColor = v
		Part.Light.Color = Color3.new(v.X, v.Y, v.Z)
		Part.Parent = RainbowModel
	end
	local RainbowBoundingBox = BasePart:Clone()
	RainbowBoundingBox.Name = "BoundingBox"
	RainbowBoundingBox.Transparency = 1
	RainbowBoundingBox.Size = RainbowModel:GetModelSize()
	RainbowBoundingBox.Anchored = true
	RainbowBoundingBox.CanCollide = false
	RainbowBoundingBox.CFrame = RainbowModel:GetModelCFrame()
	RainbowBoundingBox.Parent = RainbowModel
	return RainbowModel
end
function GetRainbowModel()
	local ModelName = (Player.Name .. "'s Rainbow")
	local Model = game:GetService("Workspace"):FindFirstChild(ModelName)
	if not Model then
		Model = Instance.new("Model")
		Model.Name = ModelName
		local RemovalMonitorClone = RemovalMonitor:Clone()
		RemovalMonitorClone.Disabled = false
		RemovalMonitorClone.Parent = Model
	end
	return Model
end
function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent and Player and Player.Parent) and true) or false)
end
function Activated()
	if not Tool.Enabled then
		return
	end
	Tool.Enabled = false
	Flying = not Flying
	if Flying then
		Handle.Transparency = 1
		CleanUp()
		local CarpetParts = {}
		for i, v in pairs(CarpetPieces) do
			local CarpetPart = BasePart:Clone()
			CarpetPart.CanCollide = false
			CarpetPart.Size = Vector3.new(CarpetSize.X, CarpetSize.Y, (CarpetSize.Z / #CarpetPieces))
			local Mesh = Instance.new("SpecialMesh")
			Mesh.MeshType = Enum.MeshType.FileMesh
			Mesh.MeshId = (BaseUrl .. v.MeshId)
			Mesh.TextureId = (BaseUrl .. "223080038")
			Mesh.Scale = Vector3.new(1.125, 1.125, 1.125)
			Mesh.VertexColor = Vector3.new(1, 1, 1)
			Mesh.Offset = Vector3.new(0, 0, 0)
			Mesh.Parent = CarpetPart
			local Weld = Instance.new("Weld")
			Weld.Part0 = Handle
			Weld.Part1 = CarpetPart
			local XOffset = (((i == 1 or i == #CarpetPieces) and -0.005) or 0)
			local YOffset = ((-((Handle.Size.Z / 2) - (CarpetPart.Size.Z / 2))) + ((CarpetPart.Size.Z * (i - 1))) + ((i == 2 and 0.245) or (i == 3 and 0.04) or (i == #CarpetPieces and 0.28) or 0))
			Weld.C1 = CFrame.new(0, XOffset, YOffset)
			Weld.Parent = CarpetPart
			table.insert(CarpetParts, {Part = CarpetPart, Weld = Weld, InitialCFrame = Weld.C0, Angle = v.Angle})
			CarpetPart.Parent = Tool
		end	
		
		spawn(function()
			InvokeClient("PlayAnimation", Animations.Sit)
			Tool.Grip = Grips.Flying
		end)
		Torso.Anchored = true
		delay(.2,function()
			Torso.Anchored = false
			Torso.Velocity = Vector3.new(0,0,0)
			Torso.RotVelocity = Vector3.new(0,0,0)
		end)
		
		FlightSpin = Instance.new("BodyGyro")
		FlightSpin.Name = "FlightSpin"
		FlightSpin.P = 10000
		FlightSpin.maxTorque = Vector3.new(FlightSpin.P, FlightSpin.P, FlightSpin.P)*100
		FlightSpin.cframe = Torso.CFrame
		
		FlightPower = Instance.new("BodyVelocity")
		FlightPower.Name = "FlightPower"
		FlightPower.velocity = Vector3.new(0, 0, 0)
		FlightPower.maxForce = Vector3.new(0, 0, 0)	--Vector3.new(1,1,1)*1000000
		FlightPower.P = 1000
		
		FlightHold = Instance.new("BodyPosition")
		FlightHold.Name = "FlightHold"
		FlightHold.P = 100000
		FlightHold.maxForce = Vector3.new(0, 0, 0)
		FlightHold.position = Torso.Position
		
		FlightSpin.Parent = Torso
		FlightPower.Parent = Torso
		FlightHold.Parent = Torso
		
		spawn(function()
			local LastPlace = nil
			while Flying and ToolEquipped and CheckIfAlive() do
				
				local CurrentPlace = Handle.Position
				local Velocity = Torso.Velocity
				Velocity = Vector3.new(Velocity.X, 0, Velocity.Z).magnitude
				
				if LastPlace and Velocity > 10 then
					
					spawn(function()
						local Model = GetRainbowModel()
						local Distance = (LastPlace - CurrentPlace).magnitude
						local Length = Distance + 3.5
						
						local RainbowModel = CreateRainbow(Length)
						
						--Thanks so much to ArceusInator for helping solve this part!
						local RainbowCFrame = CFrame.new((LastPlace + (CurrentPlace - LastPlace).unit * (Distance / 2)), CurrentPlace)
						
						TransformModel(RainbowModel, RainbowModel:GetModelCFrame(), RainbowCFrame, true)
						Debris:AddItem(RainbowModel, 1)
						RainbowModel.Parent = Model
						
						if Model and not Model.Parent then
							Model.Parent = game:GetService("Workspace")
						end
						
						LastPlace = CurrentPlace
					end)
				elseif not LastPlace then
					LastPlace = CurrentPlace
				end
				
				wait(Rate)
			end
		end)
	elseif not Flying then
		Torso.Velocity = Vector3.new(0, 0, 0)
		Torso.RotVelocity = Vector3.new(0, 0, 0)
		
		for i, v in pairs({FlightSpin, FlightPower, FlightHold}) do
			if v and v.Parent then
				v:Destroy()
			end
		end
		spawn(function()
			Tool.Grip = Grips.Normal
			InvokeClient("StopAnimation", Animations.Sit)
		end)
	end
	
	wait(2)
	
	Tool.Enabled = true
end
function Equipped(Mouse)
	Character = Tool.Parent
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("HumanoidRootPart")
	Player = Players:GetPlayerFromCharacter(Character)
	if not CheckIfAlive() then
		return
	end
	if Humanoid then
		if Humanoid.RigType == Enum.HumanoidRigType.R15 then
			Animations = {
				Sit = {Animation = Tool:WaitForChild("SitR15"), FadeTime = nil, Weight = nil, Speed = nil, Duration = nil},
			}
		else
			Animations = {
				Sit = {Animation = Tool:WaitForChild("Sit"), FadeTime = nil, Weight = nil, Speed = nil, Duration = nil},
			}
		end
	end
	Tool.Grip = Grips.Normal
	ToolEquipped = true
end
function Unequipped()
	Flying = false
	for i, v in pairs({FlightSpin, FlightPower, FlightHold}) do
		if v and v.Parent then
			v:Destroy()
		end
	end
	CleanUp()
	Handle.Transparency = 0
	ToolEquipped = false
end
function OnServerInvoke(player, mode, value)
	if player ~= Player or not ToolEquipped or not value or not CheckIfAlive() then
		return
	end
end
function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end
CleanUp()
ServerControl.OnServerInvoke = OnServerInvoke
Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "RemovalMonitor" then
		source = [[--Made by Luckymaxer
Model = script.Parent
Debris = game:GetService("Debris")
Removing = false
function RemoveModel()
	if Removing then
		return
	end
	local Parts = {}
	for i, v in pairs(Model:GetChildren()) do
		if v:IsA("Model") then
			table.insert(Parts, v)
		end
	end
	if #Parts == 0 then
		Removing = true
		Model.Name = ""
		Debris:AddItem(Model, 1)
	end
end
Model.ChildRemoved:connect(function(Child)
	RemoveModel()
end)
RemoveModel()]]
	elseif v.Name == "Script" and v:FindFirstChild("Handle"):FindFirstChild("CoilSound") then
		source = [[--Rescripted by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
Sounds = {
	CoilSound = Handle:WaitForChild("CoilSound"),
}
Gravity = 196.20
JumpHeightPercentage = 0.25
ToolEquipped = false
function GetAllConnectedParts(Object)
	local Parts = {}
	local function GetConnectedParts(Object)
		for i, v in pairs(Object:GetConnectedParts()) do
			local Ignore = false
			for ii, vv in pairs(Parts) do
				if v == vv then
					Ignore = true
				end
			end
			if not Ignore then
				table.insert(Parts, v)
				GetConnectedParts(v)
			end
		end
	end
	GetConnectedParts(Object)
	return Parts
end
function SetGravityEffect()
	if not GravityEffect or not GravityEffect.Parent then
		GravityEffect = Instance.new("BodyForce")
		GravityEffect.Name = "GravityCoilEffect"
		GravityEffect.Parent = Torso
	end
	local TotalMass = 0
	local ConnectedParts = GetAllConnectedParts(Torso)
	for i, v in pairs(ConnectedParts) do
		if v:IsA("BasePart") then
			TotalMass = (TotalMass + v:GetMass())
		end
	end
	local TotalMass = (TotalMass * 196.20 * (1 - JumpHeightPercentage))
	GravityEffect.force = Vector3.new(0, TotalMass, 0)
end
function HandleGravityEffect(Enabled)
	if not CheckIfAlive() then
		return
	end
	for i, v in pairs(Torso:GetChildren()) do
		if v:IsA("BodyForce") then
			v:Destroy()
		end
	end
	for i, v in pairs({ToolUnequipped, DescendantAdded, DescendantRemoving}) do
		if v then
			v:disconnect()
		end
	end
	if Enabled then
		CurrentlyEquipped = true
		ToolUnequipped = Tool.Unequipped:connect(function()
			CurrentlyEquipped = false
		end)
		SetGravityEffect()
		DescendantAdded = Character.DescendantAdded:connect(function()
			wait()
			if not CurrentlyEquipped or not CheckIfAlive() then
				return
			end
			SetGravityEffect()
		end)
		DescendantRemoving = Character.DescendantRemoving:connect(function()
			wait()
			if not CurrentlyEquipped or not CheckIfAlive() then
				return
			end
			SetGravityEffect()
		end)
	end
end
function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent and Player and Player.Parent) and true) or false)
end
function Equipped(Mouse)
	Character = Tool.Parent
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
	Player = Players:GetPlayerFromCharacter(Character)
	if not CheckIfAlive() then
		return
	end
	if HumanoidDied then
		HumanoidDied:disconnect()
	end
	HumanoidDied = Humanoid.Died:connect(function()
		if GravityEffect and GravityEffect.Parent then
			GravityEffect:Destroy()
		end
	end)
	Sounds.CoilSound:Play()
	HandleGravityEffect(true)
	ToolEquipped = true
end
function Unequipped()
	if HumanoidDied then
		HumanoidDied:disconnect()
	end
	HandleGravityEffect(false)
	ToolEquipped = false
end
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v.Parent:FindFirstChild("SwapWith") then
		source = [[local Tool = script.Parent
Tool.Enabled = true
local Players = game:GetService'Players'
function BuildCharacterRig(Character, AppearanceModel, IsR15)
	local Humanoid,FF = Character:FindFirstChildOfClass("Humanoid"),Character:FindFirstChildOfClass("ForceField")
	if not Humanoid and Humanoid.Health > 0 or FF then return end 	
	local AnimateScript = Character:FindFirstChild("Animate")
	if not AnimateScript then return end 
	
	for _, Object in next, Character:GetChildren() do
		if Object:IsA("Accessory") then
			Object:Destroy()
		elseif Object.Name == "Head" then
			local Face = Object:FindFirstChild("face")
			if Face then
				Face.Texture = "rbxasset://textures/face.png"
			end
		elseif Object:IsA("Shirt") or Object:IsA("Pants") or Object:IsA("ShirtGraphic") or Object:IsA("BodyColors") then
			Object:Destroy()
		end
	end
	
	if IsR15 then		
		for _, Object in next, AppearanceModel:GetChildren() do
			if Object.Name == "R15" and Object:IsA("Folder") then
				for _, Part in next, Object:GetChildren() do
					if Part:IsA("BasePart") then
						local HasLimb = Character:FindFirstChild(Part.Name)
						if HasLimb then
							HasLimb:Destroy()
						end
						Part.Parent = Character
						Humanoid:BuildRigFromAttachments()
					end
				end
			elseif Object.Name == "R15Anim" and Object:IsA("Folder") then
				for _, AnimationObject in next, Object:GetChildren() do
					local HasAnimObject = AnimateScript:FindFirstChild(AnimationObject.Name)
					if HasAnimObject then
						HasAnimObject:Destroy()
					end
					
					AnimationObject.Parent = AnimateScript
				end
			elseif Object:IsA("Accessory") then
				Humanoid:AddAccessory(Object)
			elseif Object:IsA("Pants") or Object:IsA("Shirt") or Object:IsA("ShirtGraphic") or Object:IsA("BodyColors") then
				Object.Parent = Character
			elseif Object.Name == "face" then
				local Head = Character:FindFirstChild("Head")
				if Head then
					local Face = Head:FindFirstChild("face")
					if Face then
						Face.Texture = Object.Texture
					else
						Object.Parent = Head
					end
				end
			elseif Object.Name == "BodyDepthScale" or Object.Name == "BodyHeightScale" or Object.Name == "BodyWidthScale" or Object.Name == "HeadScale" then
				local ValueObject = Humanoid:FindFirstChild(Object.Name)
				if ValueObject then
					ValueObject.Value = Object.Value
				else
					Object.Parent = Humanoid
				end
			end
		end				
	else
		for _, Object in next, AppearanceModel:GetChildren() do
			if Object:IsA("Accessory") then
				Humanoid:AddAccessory(Object)
			elseif Object:IsA("Pants") or Object:IsA("Shirt") or Object:IsA("ShirtGraphic") or Object:IsA("BodyColors") then
				Object.Parent = Character
			elseif Object.Name == "face" then
				Object.Parent = Character:FindFirstChild("Head")				
			end
		end
	end
end
Tool.SwapWith.OnServerEvent:Connect(function(client, character)
	if client == Players:GetPlayerFromCharacter(Tool.Parent) and client.Character and Tool.Enabled then
		local otherPlayer = Players:GetPlayerFromCharacter(character)
		if not otherPlayer then return end -- Remove to make it work with NPCs
		
		local clienttorso,targettorso = client.Character:FindFirstChild("Torso") or client.Character:FindFirstChild("UpperTorso"),character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
		if not clienttorso or not targettorso or (targettorso.Position-clienttorso.Position).Magnitude > 50 then return end
		
		local ClientCharacterAppearance = Players:GetCharacterAppearanceAsync(client.UserId)		
		local OtherCharacterAppearance = Players:GetCharacterAppearanceAsync(otherPlayer.UserId)
		
		
		local ClientHumanoid = client.Character:FindFirstChildOfClass("Humanoid")
		local OtherHumanoid = character:FindFirstChildOfClass("Humanoid")
		if ClientHumanoid and OtherHumanoid then
			BuildCharacterRig(client.Character, OtherCharacterAppearance, ClientHumanoid.RigType == Enum.HumanoidRigType.R15)
			BuildCharacterRig(character, ClientCharacterAppearance, OtherHumanoid.RigType == Enum.HumanoidRigType.R15)
		end
		
		ClientCharacterAppearance:Destroy()
		OtherCharacterAppearance:Destroy()
		if otherPlayer and client.Character:FindFirstChild'HumanoidRootPart' and character:FindFirstChild'HumanoidRootPart' and client.Character.HumanoidRootPart.Anchored == false and character.HumanoidRootPart.Anchored == false then
			local posA, posB = client.Character.HumanoidRootPart.CFrame, character.HumanoidRootPart.CFrame
			client.Character.HumanoidRootPart.CFrame = posB
			character.HumanoidRootPart.CFrame = posA
		end
		Tool.Enabled = false
		delay(5,function()
			Tool.Enabled = true
		end)
	end 
end)]]
	elseif v.Parent:FindFirstChild("HitFade") then
		source = [[--Rescripted by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
Speed = 100
Duration = 1
NozzleOffset = Vector3.new(0, 0.4, -1.1)
Sounds = {
	Fire = Handle:WaitForChild("Fire"),
	Reload = Handle:WaitForChild("Reload"),
	HitFade = Handle:WaitForChild("HitFade")
}
PointLight = Handle:WaitForChild("PointLight")
ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool
ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool
ServerControl.OnServerInvoke = (function(player, Mode, Value, arg)
	if player ~= Player or Humanoid.Health == 0 or not Tool.Enabled then
		return
	end
	if Mode == "Click" and Value then
		Activated(arg)
	end
end)
function InvokeClient(Mode, Value)
	pcall(function()
		ClientControl:InvokeClient(Player, Mode, Value)
	end)
end
function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end
function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end
function FindCharacterAncestor(Parent)
	if Parent and Parent ~= game:GetService("Workspace") then
		local humanoid = Parent:FindFirstChild("Humanoid")
		if humanoid then
			return Parent, humanoid
		else
			return FindCharacterAncestor(Parent.Parent)
		end
	end
	return nil
end
function GetTransparentsRecursive(Parent, PartsTable)
	local PartsTable = (PartsTable or {})
	for i, v in pairs(Parent:GetChildren()) do
		local TransparencyExists = false
		pcall(function()
			local Transparency = v["Transparency"]
			if Transparency then
				TransparencyExists = true
			end
		end)
		if TransparencyExists then
			table.insert(PartsTable, v)
		end
		GetTransparentsRecursive(v, PartsTable)
	end
	return PartsTable
end
function SelectionBoxify(Object)
	local SelectionBox = Instance.new("SelectionBox")
	SelectionBox.Adornee = Object
	SelectionBox.Color = BrickColor.new("Really red")
	SelectionBox.Parent = Object
	return SelectionBox
end
local function Light(Object)
	local Light = PointLight:Clone()
	Light.Range = (Light.Range + 2)
	Light.Parent = Object
end
function FadeOutObjects(Objects, FadeIncrement)
	repeat
		local LastObject = nil
		for i, v in pairs(Objects) do
			v.Transparency = (v.Transparency + FadeIncrement)
			LastObject = v
		end
		wait()
	until LastObject.Transparency >= 1 or not LastObject
end
function Dematerialize(character, humanoid, FirstPart)
	if not character or not humanoid then
		return
	end
	
	humanoid.WalkSpeed = 0
	local Parts = {}
	
	for i, v in pairs(character:GetChildren()) do
		if v:IsA("BasePart") then
			v.Anchored = true
			table.insert(Parts, v)
		elseif v:IsA("LocalScript") or v:IsA("Script") then
			v:Destroy()
		end
	end
	local SelectionBoxes = {}
	local FirstSelectionBox = SelectionBoxify(FirstPart)
	Light(FirstPart)
	wait(0.05)
	for i, v in pairs(Parts) do
		if v ~= FirstPart then
			table.insert(SelectionBoxes, SelectionBoxify(v))
			Light(v)
		end
	end
	local ObjectsWithTransparency = GetTransparentsRecursive(character)
	FadeOutObjects(ObjectsWithTransparency, 0.1)
	wait(0.5)
	character:BreakJoints()
	humanoid.Health = 0
	
	Debris:AddItem(character, 2)
	local FadeIncrement = 0.05
	Delay(0.2, function()
		FadeOutObjects({FirstSelectionBox}, FadeIncrement)
		if character and character.Parent then
			character:Destroy()
		end
	end)
	FadeOutObjects(SelectionBoxes, FadeIncrement)
end
function Touched(Projectile, Hit)
	if not Hit or not Hit.Parent then
		return
	end
	local character, humanoid = FindCharacterAncestor(Hit)
	if character and humanoid and character ~= Character then
		local ForceFieldExists = false
		for i, v in pairs(character:GetChildren()) do
			if v:IsA("ForceField") then
				ForceFieldExists = true
			end
		end
		if not ForceFieldExists then
			if Projectile then
				local HitFadeSound = Projectile:FindFirstChild(Sounds.HitFade.Name)
				local torso = humanoid.Torso
				if HitFadeSound and torso then
					HitFadeSound.Parent = torso
					HitFadeSound:Play()
				end
			end
			Dematerialize(character, humanoid, Hit)
		end
		if Projectile and Projectile.Parent then
			Projectile:Destroy()
		end
	end
end
function Equipped()
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	if not Player or not Humanoid or Humanoid.Health == 0 then
		return
	end
end
function Activated(target)
	if Tool.Enabled and Humanoid.Health > 0 then
		Tool.Enabled = false
		InvokeClient("PlaySound", Sounds.Fire)
		local HandleCFrame = Handle.CFrame
		local FiringPoint = HandleCFrame.p + HandleCFrame:vectorToWorldSpace(NozzleOffset)
		local ShotCFrame = CFrame.new(FiringPoint, target)
		local LaserShotClone = BaseShot:Clone()
		LaserShotClone.CFrame = ShotCFrame + (ShotCFrame.lookVector * (BaseShot.Size.Z / 2))
		local BodyVelocity = Instance.new("BodyVelocity")
		BodyVelocity.velocity = ShotCFrame.lookVector * Speed
		BodyVelocity.Parent = LaserShotClone
		LaserShotClone.Touched:connect(function(Hit)
			if not Hit or not Hit.Parent then
				return
			end
			Touched(LaserShotClone, Hit)
		end)
		Debris:AddItem(LaserShotClone, Duration)
		LaserShotClone.Parent = game:GetService("Workspace")
		wait(0.6) -- FireSound length
		InvokeClient("PlaySound", Sounds.Reload)
		
		wait(0.75) -- ReloadSound length
		Tool.Enabled = true
	end
end
function Unequipped()
	
end
BaseShot = Instance.new("Part")
BaseShot.Name = "Effect"
BaseShot.BrickColor = BrickColor.new("Really red")
BaseShot.Material = Enum.Material.Plastic
BaseShot.Shape = Enum.PartType.Block
BaseShot.TopSurface = Enum.SurfaceType.Smooth
BaseShot.BottomSurface = Enum.SurfaceType.Smooth
BaseShot.FormFactor = Enum.FormFactor.Custom
BaseShot.Size = Vector3.new(0.2, 0.2, 3)
BaseShot.CanCollide = false
BaseShot.Locked = true
SelectionBoxify(BaseShot)
Light(BaseShot)
BaseShotSound = Sounds.HitFade:Clone()
BaseShotSound.Parent = BaseShot
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v:FindFirstChild("AIScript") then
		source = [[--Made by Luckymaxer
--Updated for R15 avatar by StarWars
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
InsertService = game:GetService("InsertService")
AIScript = script:WaitForChild("AIScript")
Remover = script:WaitForChild("Remover")
NPCModel = InsertService:LoadAsset(257489726)
NPC = NPCModel:GetChildren()[1]:Clone()
if NPCModel and NPCModel.Parent then
	NPCModel:Destroy()
end
ReloadTime = 5
NPCSpawned = false
ToolEquipped = false
ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool
ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool
Handle.Transparency = 0
Tool.Enabled = true
function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end
function MakeNPC()
	if PlayerNPC and PlayerNPC.Parent then
		PlayerNPC:Destroy()
	end
	PlayerNPC = NPC:Clone()
	NPCHumanoid = PlayerNPC:FindFirstChild("Humanoid")
	NPCTorso = PlayerNPC:FindFirstChild("Torso")
	if not NPCHumanoid or not NPCTorso then
		return
	end
	NPCHumanoid.WalkSpeed = 18
	NPCHumanoid.MaxHealth = 200
	NPCHumanoid.Health = NPCHumanoid.MaxHealth
	local Values = {
		{Name = "Creator", Class = "ObjectValue", Value = Player},
		{Name = "Tool", Class = "ObjectValue", Value = Tool},
		{Name = "Mode", Class = "StringValue", Value = "Follow"},
		{Name = "MaxDistance", Class = "NumberValue", Value = 50},
		{Name = "Follow", Class = "ObjectValue", Value = Player},
		{Name = "Offset", Class = "Vector3Value", Value = Vector3.new(-3, 0, -0.5)},
		{Name = "Target", Class = "ObjectValue", Value = nil},
		{Name = "TargetPos", Class = "Vector3Value", Value = Vector3.new(0, 0, 0)},
		{Name = "Damage", Class = "NumberValue", Value = 0},
	}
	for i, v in pairs(Values) do
		local Value = Instance.new(v.Class)
		Value.Name = v.Name
		Value.Value = v.Value
		Value.Parent = PlayerNPC
	end
	for i, v in pairs({AIScript, Remover}) do
		local ScriptClone = v:Clone()
		ScriptClone.Disabled = false
		ScriptClone.Parent = PlayerNPC
	end
	NPCHumanoid.Died:connect(function()
		Debris:AddItem(PlayerNPC, 3)
	end)
	PlayerNPC.Changed:connect(function(Property)
		if Property == "Parent" and not PlayerNPC.Parent and NPCSpawned then
			Tool.Enabled = false
			NPCSpawned = false
			wait(ReloadTime)
			Tool.Enabled = true
		end
	end)
	NPCTorso.CFrame = (Torso.CFrame * CFrame.new(PlayerNPC.Offset.Value))
	PlayerNPC.Parent = game:GetService("Workspace")
	NPCHumanoid:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
	NPCSpawned = true
end
function SetTarget(Data)
	if not PlayerNPC or not PlayerNPC.Parent then
		return
	end
	local MousePosition = Data.MousePosition
	local Target = Data.Target
	local TargetValue = PlayerNPC:FindFirstChild("Target")
	local TargetPosValue = PlayerNPC:FindFirstChild("TargetPos")
	local ModeValue = PlayerNPC:FindFirstChild("Mode")
	local OffsetValue = PlayerNPC:FindFirstChild("Offset")
	if not TargetValue or not TargetPosValue or not ModeValue then
		return
	end
	if Target and Target.Parent then
		local character = Target.Parent
		if character:IsA("Hat") then
			character = character.Parent
		end
		local player = Players:GetPlayerFromCharacter(character)
		if player and IsTeamMate(player, Player) then
			return
		end
		local creator = character:FindFirstChild("Creator")
		local humanoid = character:FindFirstChild("Humanoid")
		if creator and (creator.Value == Player or IsTeamMate(Player, creator.Value)) then
			return
		end
		if humanoid and humanoid.Health > 0 then
			if TargetValue then
				TargetValue.Value = character
				ModeValue.Value = "Attack"
				return
			end
		else
			TargetPosValue.Value = MousePosition
			TargetValue.Value = nil
			ModeValue.Value = "MoveTo"
		end
	else
		ModeValue.Value = "Follow"
	end
end
function Activated()
	if not ToolEquipped or not CheckIfAlive() then
		return
	end
	if Tool.Enabled and (not PlayerNPC or not PlayerNPC.Parent) then
		Handle.Transparency = 1
		--MakeNPC()
	else
		local MouseData = InvokeClient("MousePosition")
		if not MouseData then
			return
		end
		local MousePosition = MouseData.Position
		local Target = MouseData.Target
		SetTarget({MousePosition = MousePosition, Target = Target})
	end
end
function CheckIfAlive()
	return (((Player and Player.Parent and Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent) and true) or false)
end
function Equipped()
	Handle.Transparency = 1
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
	if not CheckIfAlive() then
		return
	end
	ToolEquipped = true
end
function Unequipped()
	--[[NPCSpawned = false
	if PlayerNPC then
		for i, v in pairs({PlayerNPC}) do
			if v and v.Parent then
				v:Destroy()
			end
		end
		PlayerNPC = nil
	end]
		ToolEquipped = false
	end
	function InvokeClient(Mode, Value)
		local ClientReturn = nil
		pcall(function()
			ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
		end)
		return ClientReturn
	end
	ServerControl.OnServerInvoke = (function(player, Mode, Value)
		if player ~= Player or not ToolEquipped or not CheckIfAlive() or not Mode or not Value then
			return
		end
	end)
	Tool.Changed:connect(function(Property)
		if not Tool.Parent then
			return
		end
		if Tool.Enabled and not NPCSpawned and ToolEquipped and CheckIfAlive() then
			MakeNPC()
		end
		Handle.Transparency = (((Tool.Parent:IsA("Backpack") or Players:GetPlayerFromCharacter(Tool.Parent) and (((not NPCSpawned and Tool.Enabled) and 0) or 1)) or 0))
	end)
	Tool.Activated:connect(Activated)
	Tool.Equipped:connect(Equipped)
	Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "AIScript" and v.Parent:FindFirstChild("Remover") then
		source = [[--Made by Luckymaxer
--Updated for R15 avatar by StarWars
Figure = script.Parent
Players = game:GetService("Players")
Debris = game:GetService("Debris")
RunService = game:GetService("RunService")
Functions = require(script:WaitForChild("Functions"))
DogeModule = require(191816425)
LastMove = 0
Rate = (1 / 60)
local function Create_PrivImpl(objectType)
	if type(objectType) ~= 'string' then
		error("Argument of Create must be a string", 2)
	end
	--return the proxy function that gives us the nice Create'string'{data} syntax
	--The first function call is a function call using Lua's single-string-argument syntax
	--The second function call is using Lua's single-table-argument syntax
	--Both can be chained together for the nice effect.
	return function(dat)
		--default to nothing, to handle the no argument given case
		dat = dat or {}
		--make the object to mutate
		local obj = Instance.new(objectType)
		local parent = nil
		--stored constructor function to be called after other initialization
		local ctor = nil
		for k, v in pairs(dat) do
			--add property
			if type(k) == 'string' then
				if k == 'Parent' then
					-- Parent should always be set last, setting the Parent of a new object
					-- immediately makes performance worse for all subsequent property updates.
					parent = v
				else
					obj[k] = v
				end
			--add child
			elseif type(k) == 'number' then
				if type(v) ~= 'userdata' then
					error("Bad entry in Create body: Numeric keys must be paired with children, got a: "..type(v), 2)
				end
				v.Parent = obj
			--event connect
			elseif type(k) == 'table' and k.__eventname then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create.E\'"..k.__eventname.."\']` must have a function value\
							got: "..tostring(v), 2)
				end
				obj[k.__eventname]:connect(v)
			--define constructor function
			elseif k == t.Create then
				if type(v) ~= 'function' then
					error("Bad entry in Create body: Key `[Create]` should be paired with a constructor function, \
							got: "..tostring(v), 2)
				elseif ctor then
					--ctor already exists, only one allowed
					error("Bad entry in Create body: Only one constructor function is allowed", 2)
				end
				ctor = v
			else
				error("Bad entry ("..tostring(k).." => "..tostring(v)..") in Create body", 2)
			end
		end
		--apply constructor function if it exists
		if ctor then
			ctor(obj)
		end
		if parent then
			obj.Parent = parent
		end
		--return the completed object
		return obj
	end
end
--now, create the functor:
Create = setmetatable({}, {__call = function(tb, ...) return Create_PrivImpl(...) end})
--and create the "Event.E" syntax stub. Really it's just a stub to construct a table which our Create
--function can recognize as special.
Create.E = function(eventName)
	return {__eventname = eventName}
end
BasePart = Create("Part"){
	Shape = Enum.PartType.Block,
	Material = Enum.Material.Plastic,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
	FormFactor = Enum.FormFactor.Custom,
	Size = Vector3.new(0.2, 0.2, 0.2),
	CanCollide = true,
	Locked = true,
	Anchored = false,
}
Figures = {}
function IncludeFigure(Child)
	if not Child or not Child.Parent then
		return
	end
	local Player = Players:GetPlayerFromCharacter(Child)
	if Player then
		return
	end
	for i, v in pairs(Figures) do
		if v.Figure == Child then
			return
		end
	end
	local Figure = {Figure = Child, TouchDebounce = false, Connections = {}}
	local Humanoid = Child:FindFirstChild("Humanoid")
	local Head = Child:FindFirstChild("Head")
	local Torso = Child:FindFirstChild("Torso")
	if not Humanoid or not Humanoid:IsA("Humanoid") or Humanoid.Health == 0 or not Head or not Torso then
		return
	end
	local Neck = Torso:FindFirstChild("Neck")
	if not Neck then
		return
	end
	for i, v in pairs({Humanoid, Head, Torso, Neck}) do
		Figure[v.Name] = v
	end
	local Values = {"Creator", "Mode", "Follow", "Target", "TargetPos", "Offset", "Damage", "MaxDistance"}
	for i, v in pairs(Values) do
		local Value = Child:FindFirstChild(v)
		if not Value then
			return
		end
		Figure[v] = Value
	end
	local Sounds = {}
	for i, v in pairs(Head:GetChildren()) do
		if v:IsA("Sound") then
			Sounds[v.Name] = v
		end
	end
	local ModuleData = DogeModule.GetTable({Key = "Doge", Player = ((Figure.Creator and Figure.Creator.Value) or nil)})
	local DogeData = ModuleData.GetData({Character = Child})
	Spawn(function()
		DogeData.StartText()
	end)
	local Variables = {
		Bark = {LastBark = 0, Paused = false, TimeOut = 0.75},
		DogeData = DogeData,
	}
	for i, v in pairs(Variables) do
		Figure[i] = v
	end
	Figure.Sounds = Sounds
	local HumanoidChanged = Humanoid.Changed:connect(function(Property)
		if Property == "Sit" and Humanoid.Sit then
			Humanoid.Sit = false
			Humanoid.Jump = true
		end
	end)
	local FigureRemoved = Child.Changed:connect(function(Property)
		if Property == "Parent" and not Child.Parent then
			for i, v in pairs(Figures) do
				if v == Figure then
					for ii, vv in pairs(v.Connections) do
						if vv then
							vv:disconnect()
						end
					end
					table.remove(Figures, i)
				end
			end
		end
	end)
	for i ,v in pairs({HumanoidChanged, FigureRemoved}) do
		table.insert(Figure.Connections, v)
	end
	for i, v in pairs(Child:GetChildren()) do
		if v:IsA("BasePart") then
			local TouchedConnection
			TouchedConnection = v.Touched:connect(function(Hit)
				if not Hit or not Hit.Parent or Figure.TouchDebounce then
					return
				end
				local Connected = false
				local ConnectedParts = v:GetConnectedParts()
				if #ConnectedParts <= 1 then
					return
				end
				for i, v in pairs(ConnectedParts) do
					if v == Torso then
						Connected = true
					end
				end
				if not Connected then
					return
				end
				local character = Hit.Parent
				if character:IsA("Hat") then
					character = character.Parent
				end
				if character ~= Figure.Target.Value then
					return
				end
				local player = Players:GetPlayerFromCharacter(character)
				local CreatorValue = Figure.Creator.Value
				if not CreatorValue then
					return
				end
				local CreatorPlayer = ((CreatorValue:IsA("Player") and CreatorValue) or Players:GetPlayerFromCharacter(CreatorValue))
				if player then
					if player == CreatorPlayer then
						return
					end
					if player and CreatorPlayer and Functions.IsTeamMate(CreatorPlayer, player) then
						return
					end
				end
				local creator = character:FindFirstChild("Creator")
				if creator and creator:IsA("ObjectValue") and creator.Value == CreatorValue then
					return
				end
				local humanoid = character:FindFirstChild("Humanoid")
				if not humanoid or not humanoid:IsA("Humanoid") or humanoid.Health == 0 then
					return
				end
				Figure.TouchDebounce = true
				Functions.UntagHumanoid(humanoid)
				Functions.TagHumanoid(humanoid, CreatorPlayer)
				humanoid:TakeDamage(Figure.Damage.Value)
				wait(0.25)
				Figure.TouchDebounce = false
			end)
			table.insert(Figure.Connections, TouchedConnection)
		end
	end
	Figure.Sounds.Wow:Play()
	table.insert(Figures, Figure)
end
function SecureJump(Table)
	local Humanoid = Table.Humanoid
	local Torso = Table.Torso
	if not Humanoid or Humanoid.Jump or not Torso then
		return
	end
	local TargetPoint = Torso.Velocity.Unit
	local Blockage, BlockagePos = Functions.CastRay((Torso.CFrame + CFrame.new(Torso.Position, Vector3.new(TargetPoint.X, Torso.Position.Y, TargetPoint.Z)).lookVector * (Torso.Size.Z / 2)).p, Torso.CFrame.lookVector, (Torso.Size.Z * 2.5), {Figure, (((Creator and Creator.Value and Creator.Value:IsA("Player") and Creator.Value.Character) and Creator.Value.Character) or nil)}, false)
	local Jumpable = false
	if Blockage then
		Jumpable = true
		if Blockage:IsA("Terrain") then
			local CellPos = Blockage:WorldToCellPreferSolid((BlockagePos - Vector3.new(0, 2, 0)))
			local CellMaterial, CellShape, CellOrientation = Blockage:GetCell(CellPos.X, CellPos.Y, CellPos.Z)
			if CellMaterial == Enum.CellMaterial.Water then
				Jumpable = false
			end
		elseif Blockage.Parent:FindFirstChild("Humanoid") then
			Jumpable = false
		end
	end
	if Jumpable then
		Humanoid.Jump = true
	end
end
RunService.Stepped:connect(function()
	_, Time = wait(0.05)
	for i, v in pairs(Figures) do
		Spawn(function()
			pcall(function()
				if v and v.Figure and v.Figure.Parent then
					Spawn(function()
						SecureJump(v)
					end)
					local Disabled = v.Figure:FindFirstChild("Disabled")
					if not Disabled then
						local CreatorValue = v.Creator.Value
						if CreatorValue then
							local CreatorPlayer = ((CreatorValue:IsA("Player") and CreatorValue) or Players:GetPlayerFromCharacter(v.Creator.Value))
							if CreatorPlayer then
								local CreatorCharacter = CreatorPlayer.Character
								if CreatorCharacter and CreatorCharacter.Parent then
									local CreatorTorso = CreatorCharacter:FindFirstChild("Torso") or CreatorCharacter:FindFirstChild("UpperTorso")
									if CreatorTorso then
										local DistanceApart = (CreatorTorso.Position - v.Torso.Position).magnitude
										if DistanceApart > v.MaxDistance.Value then
											v.Mode.Value = "Follow"
										end
									end
								end
							end
						end
						if v.Mode.Value == "Follow" then
							local FollowValue = v.Follow.Value
							if FollowValue then
								if FollowValue:IsA("Player") and FollowValue.Character and FollowValue.Character.Parent then
									FollowValue = FollowValue.Character
								end
								local FollowHumanoid = FollowValue:FindFirstChild("Humanoid")
								local FollowTorso = FollowValue:FindFirstChild("Torso") or FollowValue:FindFirstChild("UpperTorso")
								if FollowHumanoid and FollowHumanoid.Health > 0 and FollowTorso then
									--if (v.Torso.Position - FollowTorso.Position).magnitude > 5 then
										v.Humanoid:MoveTo((FollowTorso.CFrame * CFrame.new(v.Offset.Value)).p)
									--end
								end
							end
						elseif v.Mode.Value == "MoveTo" then
							v.Humanoid:MoveTo(v.TargetPos.Value)
							LastMove = Time
							v.Mode.Value = "Nothing"
						elseif v.Mode.Value == "Attack" then
							local TargetCharacter = v.Target.Value
							local TargetDisabled = v.Target:FindFirstChild("Disabled")
							local NotFound = false
							if not TargetDisabled or not TargetDisabled.Value then
								if TargetCharacter and TargetCharacter.Parent then
									local TargetHumanoid = TargetCharacter:FindFirstChild("Humanoid")
									local TargetTorso = TargetCharacter:FindFirstChild("Torso") or TargetCharacter:FindFirstChild("UpperTorso")
									local creator = TargetCharacter:FindFirstChild("Creator")
									if TargetHumanoid and TargetHumanoid.Health > 0 and TargetTorso and (not creator or (creator and v.Creator.Value ~= creator.Value and not Functions.IsTeamMate(v.Creator.Value, creator.Value))) then
										local Direction = CFrame.new(v.Torso.Position, Vector3.new(TargetTorso.Position.X, v.Torso.Position.Y, TargetTorso.Position.Z))
										local ChaseOffset = 8
										local ChasePosition = (CFrame.new(TargetTorso.Position) - Direction.lookVector * ChaseOffset).p
										local Time = tick()
										local Distance = (v.Torso.Position - TargetTorso.Position).Magnitude
										if Distance <= (ChaseOffset + 1) and not v.Bark.Paused and (Time - v.Bark.LastBark) > v.Bark.TimeOut then
											v.Bark.Paused = true
											Spawn(function()
												for i = 1, math.random(1, 3) do
													local Sound = v.Sounds.Bark:Clone()
													Sound.Pitch = (math.random(900, 1150) * 0.001)
													Debris:AddItem(Sound, 1.5)
													Sound.Parent = v.Head
													v.Sounds.Bark:Play()
													wait(0.15)
												end
												v.Bark.TimeOut = (math.random(250, 750) * 0.001)
												v.Bark.LastBark = tick()
												v.Bark.Paused = false
											end)
											local TargetPlayer = Players:GetPlayerFromCharacter(TargetCharacter)
											if TargetPlayer then
												v.DogeData.ObscureScreen(TargetPlayer)
											end
  										end
										local BodyGyro = Create("BodyGyro"){
											maxTorque = Vector3.new(math.huge, math.huge, math.huge),
											cframe = Direction,
										}
										Debris:AddItem(BodyGyro, Rate)
										BodyGyro.Parent = v.Torso
										v.Humanoid:MoveTo(ChasePosition)
									else
										NotFound = true
									end
								else
									NotFound = true
								end
							end
							if NotFound then
								v.Target.Value = nil
								v.Mode.Value = "Follow"
							end
						elseif v.Mode.Value == "Nothing" then
							if (Time - LastMove) >= 30 then
								v.Mode.Value = "Follow"
							end
						end
					end
				end
			end)
		end)
	end
end)
IncludeFigure(Figure)]]
	elseif v.Name == "Remover" and v.Parent:FindFirstChild("AIScript") then
		source = [[--Made by Luckymaxer
Model = script.Parent
Humanoid = Model:FindFirstChild("Humanoid")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
Creator = Model:FindFirstChild("Creator")
Tool = Model:FindFirstChild("Tool")
function DestroyModel()
	Debris:AddItem(Model, 2)
end
if not Creator or not Creator.Value or not Creator.Value:IsA("Player") or not Creator.Value.Parent or not Tool or not Tool.Value or not Tool.Value.Parent then
	DestroyModel()
	return
end
Creator = Creator.Value
Tool = Tool.Value
Character = Creator.Character
if not Character then
	DestroyModel()
	return
end
Creator.Changed:connect(function(Property)
	if Property == "Parent" and not Creator.Parent then
		DestroyModel()
	end
end)
Character.Changed:connect(function(Property)
	if Property == "Parent" and not Character.Parent then
		DestroyModel()
	end
end)
Tool.Changed:connect(function(Property)
	if Property == "Parent" then
		local Player = ((Tool.Parent and ((Tool.Parent:IsA("Backpack") and Tool.Parent.Parent) or Players:GetPlayerFromCharacter(Tool.Parent))) or nil)
		if (not Player or (Player and Player ~= Creator)) then
			DestroyModel()
		end
	end
end)
if Humanoid then
	Humanoid.Died:connect(function()
		DestroyModel()
	end)
end]]
	elseif v.Name == "Server" and v:FindFirstChild("ShardContent") then
		source = [[--Rescripted by TakeoHonorable
--Revamped Periastrons: The Periastron of Rainbow Maelstrom
--The leader of the bunch, you know it well (get the reference?)
function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end
local Seed = Random.new(tick())
local Tool = script.Parent
Tool.Enabled = true
local Handle = Tool:WaitForChild("Handle",10)
local Region = require(script:WaitForChild("RegionModule",10))
local PointLight = Handle:WaitForChild("PointLight",10)
local Sparkles = Handle:FindFirstChildOfClass("Sparkles")
local Animations = Tool:WaitForChild("Animations",10)
local Deletables = {} --Send all deletables here
local Sounds = {
	LungeSound = Handle:WaitForChild("LungeSound",10),
	SlashSound = Handle:WaitForChild("SlashSound",10),
}
local PeriastronNames = {
	"Azure",
	"Grimgold",
	"Crimson",
	"Chartreuse",
	"Amethyst",
	"Ivory",
	"Noir",
}
local PeriastronNamesAlt = {
	"Azure",
	"Grimgold",
	"Crimson",
	"Chartreuse",
	"Amethyst",
	"Ivory",
	"Noir",
	"Hazel",
	"Fuchsia"
}
local AttackAnims
local Services = {
	Players = (game:FindService("Players") or game:GetService("Players")),
	TweenService = (game:FindService("TweenService") or game:GetService("TweenService")),
	RunService = (game:FindService("RunService") or game:GetService("RunService")),
	Debris = (game:FindService("Debris") or game:GetService("Debris")),
	ServerScriptService = (game:FindService("ServerScriptService") or game:GetService("ServerScriptService"))
}
local Components = {
	PeriSparkle = Handle:WaitForChild("Sparkles",10),
	PeriTrail = Handle:WaitForChild("Trail",10),
	MouseInput = Tool:WaitForChild("MouseInput",10)
}
Components.PeriSparkle.Enabled = true
Components.PeriTrail.Enabled = false
PointLight.Enabled = true
local Player,Character,Humanoid,Root,Torso
local Properties = {
	BaseDamage = 40,
	SpecialCooldown = 90,
	GrimgoldRange = 40,
}
local Remote = (Tool:FindFirstChild("Remote") or Instance.new("RemoteEvent"));Remote.Name = "Remote";Remote.Parent = Tool
local Grips = {
	Normal = Tool:WaitForChild("NormalGrip").Value,
	--BackR6 = Tool:WaitForChild("BackGrip").Value,
	--BackR15 = Tool:WaitForChild("BackGrip").Value+Vector3.new(-.7,0,-.7)
}
Tool.Grip = Grips.Normal
local function Wait(para) -- bypasses the latency
	local Initial = tick()
	repeat
		Services.RunService.Heartbeat:Wait()
	until tick()-Initial >= para
end
function RayCast(Pos, Dir, Max, IgnoreList)
	return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(Pos, Dir.unit * (Max or 999.999)), IgnoreList) 
end
function IsInTable(Table,Value)
	for _,v in pairs(Table) do
		if v == Value then
			return true
		end
	end
	return false
end
local function HasPeri(PeriName)
	return (Player:FindFirstChild("Backpack") and Player:FindFirstChild("Backpack"):FindFirstChild(PeriName.."Periastron")) or false
end
local function HasFullSet()
	for _,names in pairs(PeriastronNames) do
		if not HasPeri(names) then
			return false
		end
	end
	return true
end
function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end
function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Services.Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end
local function VisualizeRay(ray,RayLength)
	local RayCast = Create("Part"){
		Material = Enum.Material.Neon,
		Color = Color3.new(0,1,0),
		Size = Vector3.new(0.3,0.3,(RayLength or 5)),
		CFrame = CFrame.new(ray.Origin, ray.Origin+ray.Direction) * CFrame.new(0, 0, -(RayLength or 5) / 2),
		Anchored = true,
		CanCollide = false,
		Parent = workspace
	}
	game:GetService("Debris"):AddItem(RayCast,5)
end
function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end
function GetHumanoidsInRange(Range)
	local RecordedHumanoids = {}
	for _,parts in pairs(Region.new(Root.CFrame,Vector3.new(1,1,1)*Range):Cast(Character)) do
		if parts and parts.Parent and string.find(string.lower(parts.Name),"torso") or string.find(string.lower(parts.Name),"root") and (parts.CFrame.p-Root.CFrame.p).magnitude <= Range then
			local Hum = parts.Parent:FindFirstChildOfClass("Humanoid")
			if Hum and Hum.Health ~= 0 and not IsInTable(RecordedHumanoids,Hum) then
				RecordedHumanoids[#RecordedHumanoids+1] = Hum
			end
		end
	end
	return RecordedHumanoids
end
local function GetNearestTorso(MarkedPosition,TorsoPopulationTable)
	local ClosestDistance = math.huge
	local ClosestTorso
	for i=1,#TorsoPopulationTable do
		local distance = (TorsoPopulationTable[i].CFrame.p-MarkedPosition).magnitude
		if TorsoPopulationTable[i] and  distance < ClosestDistance then
			ClosestDistance = distance
			ClosestTorso = TorsoPopulationTable[i]
		end
	end
	--warn("The Closest Person is: "..ClosestTorso.Parent.Name)
	return ClosestTorso
end
local RedPillar = Create("Part"){
	Shape = Enum.PartType.Cylinder,
	Material = Enum.Material.Neon,
	Name = "CrimsonPillar",
	BrickColor = BrickColor.new("Crimson"),
	Size = Vector3.new(100,5,5),
	CanCollide = false,
	Anchored = true,
	Transparency = 0.3,
	Locked = true,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth
}
local Surfaces = {"Front","Back","Left","Right","Top","Bottom"}
local PillarLighting = Create("SurfaceLight"){
	Color = Color3.fromRGB(151, 0, 0),
	Angle = 180,
	Enabled = true,
	Range = 10,
	Shadows = true
}
for _,surfaces in pairs(Surfaces) do
	local Lighting = PillarLighting:Clone()
	Lighting.Face = Enum.NormalId[surfaces]
	Lighting.Parent = RedPillar
end
local CurrentTime,LastTime = tick(),tick()
function Activated()
	if not Tool.Enabled then return end
	Tool.Enabled = false
	CurrentTime = tick()
	if (CurrentTime-LastTime) <= 0.2 then
		--print("Lunge")
		Sounds.LungeSound:Play()
		Components.PeriTrail.Enabled = true
		local sucess,MousePosition = pcall(function() return Components.MouseInput:InvokeClient(Player) end)
		MousePosition = (sucess and MousePosition) or Vector3.new(0,0,0)
		
		local Direction = CFrame.new(Root.Position, Vector3.new(MousePosition.X, Root.Position.Y, MousePosition.Z))
		local BodyVelocity = Instance.new("BodyVelocity")
		BodyVelocity.MaxForce = Vector3.new(math.huge, 0, math.huge)
		BodyVelocity.Velocity = Direction.lookVector * ((HasPeri("Fuchsia") and 200) or 100)
		Services.Debris:AddItem(BodyVelocity, 0.5)
		BodyVelocity.Parent = Root
		delay(.5,function()
			Components.PeriTrail.Enabled = false
		end)
		Root.CFrame = CFrame.new(Root.CFrame.p,Root.CFrame.p+Direction.lookVector)
		wait(1.5)
	else
		local SwingAnims = {AttackAnims.Slash,AttackAnims.SlashAnim,AttackAnims.RightSlash}
		local AttackAnim = SwingAnims[Seed:NextInteger(1,#SwingAnims)]
		spawn(function()
			if AttackAnim ~= AttackAnims.SlashAnim then
				Sounds.SlashSound:Play()
				else
				Sounds.SlashSound:Play()
				wait(.5)
				Sounds.SlashSound:Play()
			end	
		end)
		AttackAnim:Play()
	--wait(.4)
	end
	LastTime = CurrentTime
	Tool.Enabled = true
end
local Touch
local EquippedPassives = {}
local IvoryDebounce,GrimgoldDebounce,CrimsonDebounce = false,false,false
function Equipped(Mouse)
	Character = Tool.Parent
	Root = Character:FindFirstChild("HumanoidRootPart")
	Player = Services.Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChildOfClass("Humanoid")
	AttackAnims = {
		Slash = Animations:WaitForChild(Humanoid.RigType.Name,10):WaitForChild("Slash",10),
		RightSlash = Animations:WaitForChild(Humanoid.RigType.Name,10):WaitForChild("RightSlash",10),
		SlashAnim = Animations:WaitForChild(Humanoid.RigType.Name,10):WaitForChild("SlashAnim",10),
	}
	for i,v in pairs(AttackAnims) do
		AttackAnims[i] = Humanoid:LoadAnimation(v)
	end
	Touch = Handle.Touched:Connect(function(hit)
		Damage(hit,Properties.BaseDamage,false)
	end)
	
	
	local IgnoreHealthChange = false
		local CurrentHealth = Humanoid.Health
		EquippedPassives[#EquippedPassives+1] = Humanoid.Changed:Connect(function(Property) -- Based on Azure Periastron
			local NewHealth = Humanoid.Health
			if not IgnoreHealthChange and NewHealth ~= Humanoid.MaxHealth then
				if NewHealth < CurrentHealth then
					local DamageDealt = (CurrentHealth - NewHealth)
					IgnoreHealthChange = true
					Humanoid.Health = Humanoid.Health + (DamageDealt * ((HasFullSet() and .5) or .33))
					--print((HasPeri("Azure") and "Has Azure") or "Does not have Azure")
					IgnoreHealthChange = false
				end
			end
			CurrentHealth = NewHealth
		end)
		
	if HasPeri("Grimgold") then
		EquippedPassives[#EquippedPassives+1] = Services.RunService.Heartbeat:Connect(function()
			if GrimgoldDebounce or not Tool:IsDescendantOf(Character) then return end
			repeat
				
				GrimgoldDebounce = true
				local TaggedHumanoids = {}
					for _,Hum in pairs(GetHumanoidsInRange((HasFullSet() and Properties.GrimgoldRange*1.5) or Properties.GrimgoldRange)) do
						if not IsInTable(TaggedHumanoids,Hum) and not IsTeamMate(Player,Services.Players:GetPlayerFromCharacter(Hum.Parent)) and not Hum.Parent:FindFirstChild("RevealRainbow")then
							TaggedHumanoids[#TaggedHumanoids+1] = Hum
							spawn(function()
								local RevealScript = script:WaitForChild("RevealRainbow",10):Clone()
								RevealScript:WaitForChild("Range").Value = (HasFullSet() and Properties.GrimgoldRange*1.5) or Properties.GrimgoldRange
								RevealScript:WaitForChild("Creator").Value = Character
								RevealScript:WaitForChild("Tool").Value = Tool
								RevealScript.Parent = Hum.Parent
								RevealScript.Disabled = false
							end)
							Hum.WalkSpeed = (HasFullSet() and 4) or 12
						end
					end
				wait(1/10)
				GrimgoldDebounce = false
				--Services.RunService.Heartbeat:Wait()
			until not Tool:IsDescendantOf(Character) or Humanoid.Health <= 0
		end)
	end
	
	if HasPeri("Crimson") then
		EquippedPassives[#EquippedPassives+1] = Services.RunService.Heartbeat:Connect(function()
			if CrimsonDebounce or not Tool:IsDescendantOf(Character) then return end
			repeat
				CrimsonDebounce = true
				Wait((HasFullSet() and Seed:NextNumber(.2,1)) or Seed:NextNumber(1,3))
				local NearbyPlayers = {}
				for _,player in pairs(Services.Players:GetPlayers()) do
					if player ~= Player and player.Character and player.Character.PrimaryPart then
						local Hum = player.Character:FindFirstChildOfClass("Humanoid")
						if Hum and Hum.Health <= 0 and Hum.Health ~= 0 and (player.Character.PrimaryPart.CFrame.p-Root.CFrame.p).Magnitude <=30 then
							NearbyPlayers[#NearbyPlayers+1] = player.Character.PrimaryPart
						end
					end
				end
				if #NearbyPlayers == 0 then
					local SpawnPos = (Root.CFrame*CFrame.new(Seed:NextInteger(-40,40),100,Seed:NextInteger(-40,40))).p
					local hit,pos = RayCast(SpawnPos,(SpawnPos-Vector3.new(0,1,0))-SpawnPos,150,{Character})
					if hit then
						local PillarClone = RedPillar:Clone()
						local PillarScript = script:WaitForChild("CrimsonPillar",5):Clone()
						PillarScript:WaitForChild("Creator",5).Value = Player
						PillarScript.Parent = PillarClone
						PillarClone.CFrame = CFrame.new(pos+Vector3.new(0,PillarClone.Size.X/2,0))*CFrame.Angles(0,0,math.rad(90))
						PillarClone.Parent = workspace
						PillarScript.Disabled = false
					end
				else
					local ChosenPlayer = NearbyPlayers[Seed:NextInteger(1,#NearbyPlayers)]
					if ChosenPlayer then
						local PillarClone = RedPillar:Clone()
						local PillarScript = script:WaitForChild("CrimsonPillar",5):Clone()
						PillarScript:WaitForChild("Creator",5).Value = Player
						PillarScript.Parent = PillarClone
						PillarClone.CFrame = CFrame.new(ChosenPlayer.CFrame.p+Vector3.new(0,(PillarClone.Size.X/2)-2.5,0))*CFrame.Angles(0,0,math.rad(90))
						PillarClone.Parent = workspace
						PillarScript.Disabled = false
					end
				end
				
				Services.RunService.Heartbeat:Wait()
				CrimsonDebounce = false
			until not Tool:IsDescendantOf(Character) or Humanoid.Health <= 0
		end)
	end
	
	if HasPeri("Ivory") then
		
		local ShardContent = script:WaitForChild("ShardContent",10):GetChildren()	
		
		local Shard = Create("Part"){
						Material = Enum.Material.Neon,
						Size = Vector3.new(1,1,1)*.5,
						Anchored = false,
						CanCollide = false,
						Name = "StarShard",
						Locked = true,
						Transparency = 0,
						Shape = Enum.PartType.Ball,
						CFrame = Handle.CFrame,
					}
					local TopAttachment = Create("Attachment"){
						Position = Vector3.new(0,Shard.Size.y/2,0),
						Name = "TopAttachment",
						Parent = Shard
					}
					local BottomAttachment = Create("Attachment"){
						Position = Vector3.new(0,-Shard.Size.y/2,0),
						Name = "BottomAttachment",
						Parent = Shard
					}
					for _,stuff in pairs(ShardContent) do
						if stuff:IsA("ParticleEmitter") then
							local particle = stuff:Clone()
							particle.Parent = Shard
						elseif stuff:IsA("Trail") then
							local trail = stuff:Clone()
							trail.Attachment0 = TopAttachment;
							trail.Attachment1 = BottomAttachment;
							trail.Parent = Shard
							trail.Enabled = true
						end
					end
		EquippedPassives[#EquippedPassives+1] = Services.RunService.Heartbeat:Connect(function()
	
				if IvoryDebounce or not Tool:IsDescendantOf(Character) then return end
				
				
				repeat
					--wait(Seed:NextNumber(.1,.5))
					IvoryDebounce = true
					local Proj = Shard:Clone()
					for _,v in pairs(Proj:GetChildren()) do
						if v:IsA("ParticleEmitter") then
							v.Enabled = true
						end
					end
					local SparkleClone = script:WaitForChild("Sparkle",5):Clone()
					SparkleClone.Parent = Proj
					SparkleClone:Play()
					local ShardScript = script:WaitForChild("StarShard",10):Clone()
					ShardScript:WaitForChild("Creator").Value = Player
					ShardScript.Parent = Proj
					ShardScript.Disabled = false
					--Services.Debris:AddItem(Proj,7)
					Proj.CFrame = Handle.CFrame
					Proj.Parent = workspace
					Proj:SetNetworkOwner(nil)
					Proj.Velocity = CFrame.new(Handle.CFrame.p,Handle.CFrame.p+Vector3.new(Seed:NextNumber(-1,1),Seed:NextNumber(-1,1),Seed:NextNumber(-1,1))).lookVector*Seed:NextNumber(50,70)
					Wait((HasFullSet() and 1/3) or 1/2)
					IvoryDebounce = false
					--Services.RunService.Heartbeat:Wait()
				until not Tool:IsDescendantOf(Character) or Humanoid.Health <= 0
		end)
	end
	
end
function Unequipped()
	if Touch then Touch:Disconnect();Touch = nil end
	for i,v in pairs(AttackAnims) do
		v:Stop()
	end
	for index,passive in pairs(EquippedPassives) do
		if passive then 
			passive:Disconnect();EquippedPassives[index] = nil
		end 
	end
end
local HitHumanoids = {}
function Damage(hit,TotalDamage)
	if not hit or not hit.Parent then return end
	local Hum = hit.Parent:FindFirstChildOfClass("Humanoid")
	local ForceField = hit.Parent:FindFirstChildOfClass("ForceField")
	if not Hum or Hum.Health <=0 or Hum == Humanoid or ForceField then return end
	
	if IsTeamMate(Player,Services.Players:GetPlayerFromCharacter(Hum.Parent)) then return end
	
	if IsInTable(HitHumanoids,Hum) then return end
	
	spawn(function()
		UntagHumanoid(Hum)
		TagHumanoid(Hum,Player)
		HitHumanoids[#HitHumanoids+1]=Hum
		Hum:TakeDamage(TotalDamage)
		Humanoid.Health = math.clamp(Humanoid.Health + (TotalDamage * ((HasFullSet() and .3) or .2)),0,Humanoid.MaxHealth)--Noir life-steal
		--wait(.5)
		for i,v in pairs(HitHumanoids) do
			if v == Hum then
				HitHumanoids[i] = nil
			end
		end
	end)
end
Tool.Activated:Connect(Activated)
Tool.Equipped:Connect(Equipped)
Tool.Unequipped:Connect(Unequipped)
function SummonRainBeam()
	if not Sparkles.Enabled then return end
	Sparkles.Enabled = false
	local RainBeamScript = script:WaitForChild("RainBeam",5):Clone()
	RainBeamScript:WaitForChild("Creator",5).Value = Player
	RainBeamScript:WaitForChild("Tool",5).Value = Tool
	RainBeamScript.Parent = Services.ServerScriptService
	local PeriFormation = RainBeamScript:WaitForChild("PeriFormation",5)
	for _,name in pairs(PeriastronNamesAlt) do
		local Peri = HasPeri(name)
		if Peri then
			local PeriHandle = Peri:FindFirstChild("Handle",true)
			
			if PeriHandle then
				local PeriLight = PeriHandle:FindFirstChildOfClass("PointLight")
				local PeriMesh = PeriHandle:FindFirstChildOfClass("SpecialMesh")
				if PeriMesh and PeriLight then
					local PeriTag = Create("Color3Value"){
						Name = PeriMesh.TextureId,
						Value = PeriLight.Color,
						Parent = PeriFormation
					}
				end
			end
		
		end
	end
	RainBeamScript.Disabled = false
	
	repeat
		Services.RunService.Heartbeat:Wait()
	until not RainBeamScript or not RainBeamScript:IsDescendantOf(Services.ServerScriptService)
	
	wait((HasFullSet() and Properties.SpecialCooldown/2) or Properties.SpecialCooldown)
	Sparkles.Enabled = true
end
local ChartreuseReady,AmethystReady,HazelReady = true,true,true -- debounces for each one
function ShieldPulse()
	if not ChartreuseReady then return end
	ChartreuseReady = false
	--print("Shield Pulse")
	local ShieldScript = script:WaitForChild("ShieldScript",5):Clone()
	ShieldScript.Parent = Character
	ShieldScript.Disabled = false
	
	repeat
		Services.RunService.Heartbeat:Wait()
	until not ShieldScript or not ShieldScript.Parent
	
	delay((HasFullSet() and 7) or 7*2,function()
		ChartreuseReady = true
	end)
end
function Singularity()
	if not AmethystReady then return end
	AmethystReady = false
	--print("Singularity")
	
local Centre = Create("Part"){
	Size = Vector3.new(1,1,1)*1,
	CFrame = Root.CFrame,
	Transparency = 1,
	Anchored = true,
	Locked = true,
	CanCollide = false,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth	
}
Centre.Parent = workspace
local BlackHoleScript = script:WaitForChild("BlackHole"):Clone()
BlackHoleScript:WaitForChild("Creator",5).Value = Player
BlackHoleScript.Parent = Centre
BlackHoleScript.Disabled = false
	delay((HasFullSet() and 12) or 12*2,function()
		AmethystReady = true
	end)
end
function RockLift()
	if not HazelReady then return end
	HazelReady = false
	--print("Rock Lift")
	local hit,pos,mat = RayCast(Root.CFrame.p,(Root.CFrame.p+Vector3.new(0,-1,0))-Root.CFrame.p,10,{Character})
	
	local Rock = Create("Part"){
		Size = Vector3.new(1,1,1)*15,
		Material = Enum.Material.Slate,
		Anchored = true,
		Name = "Rock",
		Locked = true,
		CanCollide = true,
		Color = ((hit and hit.Color) or Color3.fromRGB(102, 51, 0)),
		CFrame = CFrame.new(Root.CFrame.p-Vector3.new(0,2,0))*CFrame.Angles(math.rad(Seed:NextInteger(0,360)),math.rad(Seed:NextInteger(0,360)),math.rad(Seed:NextInteger(0,360))),
		Parent = workspace
	}
	
	local RockSummon = script:WaitForChild("RockSummon",5):Clone()
	RockSummon:WaitForChild("Creator",5).Value = Player
	RockSummon.Parent = Rock
	RockSummon.Disabled = false
	
	local JumpForce = Create("BodyVelocity"){
		MaxForce = Vector3.new(1,1,1) * math.huge,
		Name = "JumpForce",
		Velocity = ((Root.CFrame.p + Vector3.new(0,1,0))-Root.CFrame.p).Unit*150,
		Parent = Root
	}
	Services.Debris:AddItem(JumpForce,.1)
	
	delay((HasFullSet() and 6) or 6*2,function()
		HazelReady = true
	end)
end
Remote.OnServerEvent:Connect(function(Client,Key)
	if not Player or not Client or Client ~= Player or not Key or not Tool.Enabled or Humanoid.Health <= 0 then return end
	if Key == Enum.KeyCode.Q then
		SummonRainBeam()
	elseif Key == Enum.KeyCode.E and HasPeri("Chartreuse") then
		ShieldPulse()
	elseif Key == Enum.KeyCode.X and HasPeri("Amethyst") then
		Singularity()	
	elseif Key == Enum.KeyCode.R and HasPeri("Hazel") then
		RockLift()
	end
end)]]
	elseif v.Name == "BlackHole" and v.Parent:FindFirstChild("ShardContent") then
		source = [[function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end
function IsInTable(Table,Value)
	for _,v in pairs(Table) do
		if v == Value then
			return true
		end
	end
	return false
end
function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end
local Black_Hole = script.Parent
local Creator = script:WaitForChild("Creator",5)
local ParticleFolder = script:WaitForChild("Particles",5)
local CenterAttachment = Create("Attachment"){
	Position = Vector3.new(0,0,0),
	Parent = Black_Hole
}
local Radius = 50
local Services = {
	Players = (game:FindService("Players") or game:GetService("Players")),
	TweenService = (game:FindService("TweenService") or game:GetService("TweenService")),
	RunService = (game:FindService("RunService") or game:GetService("RunService")),
	Debris = (game:FindService("Debris") or game:GetService("Debris")),
	ServerScriptService = (game:FindService("ServerScriptService") or game:GetService("ServerScriptService"))
}
local function Wait(para) -- bypasses the latency
	local Initial = tick()
	repeat
		Services.RunService.Heartbeat:Wait()
	until tick()-Initial >= para
end
for _,particles in pairs(ParticleFolder:GetChildren()) do
	if particles:IsA("ParticleEmitter") then
		particles.Parent = CenterAttachment
		particles.Enabled = true
	end
end
local EffectSound = script:WaitForChild("Effect")
EffectSound.Parent = Black_Hole
EffectSound:Play()
local VeloForces = {}
local AffectedParts = {}
local Pulling = true
delay(5,function()
	Pulling = false
	for _,forces in pairs(VeloForces) do
		if forces then
			forces:Destroy()
		end
	end
	Black_Hole:Destroy()
end)
while Black_Hole and Black_Hole:IsDescendantOf(workspace) and Pulling do
	--spawn(function()
		local NegativeRegion = (Black_Hole.Position - Vector3.new(Radius,Radius,Radius))
		local PositiveRegion = (Black_Hole.Position + Vector3.new(Radius,Radius,Radius))
		local Region = Region3.new(NegativeRegion, PositiveRegion)
		local Parts = workspace:FindPartsInRegion3WithIgnoreList(Region,{Creator.Value.Character,Black_Hole},math.huge)
		for _,hit in pairs(Parts) do
			if hit and hit.Parent and not hit.Anchored and (hit.CFrame.p-Black_Hole.CFrame.p).Magnitude <= Radius and not IsInTable(AffectedParts,hit) and not hit:FindFirstAncestorWhichIsA("Tool") and not hit:FindFirstAncestorWhichIsA("Accoutrement") and not hit.Parent:FindFirstChildOfClass("ForceField") and not IsTeamMate(Creator.Value,Services.Players:GetPlayerFromCharacter(hit.Parent)) then
				AffectedParts[#AffectedParts+1] = hit
				local Pull = Create("BodyVelocity"){
					MaxForce = Vector3.new(1,1,1)*math.huge,
					Velocity = ((Black_Hole.CFrame.p-hit.CFrame.p).Unit*25),
					Name = "Pull",
					Parent = hit
				}
				VeloForces[#VeloForces+1] = Pull
				delay(.5,function()
				
						for index,v in pairs(VeloForces) do
							if v == Pull then
								table.remove(AffectedParts,index)
								if Pull then
									Pull:Destroy()
								end
							end
						end
						for index,v in pairs(AffectedParts) do
							if v == hit then
								table.remove(AffectedParts,index)
							end
						end
					
				end)
				--Services.Debris:AddItem(Pull,.5)
			end
		end
	--end)
	Wait(1/30)
	--Services.RunService.Heartbeat:Wait()
end]]
	elseif v.Name == "CrimsonPillar" then
		source = [[local Pillar = script.Parent
local Creator = script:WaitForChild("Creator",5).Value
local Services = {
	Players = (game:FindService("Players") or game:GetService("Players")),
	TweenService = (game:FindService("TweenService") or game:GetService("TweenService")),
	RunService = (game:FindService("RunService") or game:GetService("RunService")),
	Debris = (game:FindService("Debris") or game:GetService("Debris")),
	TweenService = (game:FindService("TweenService") or game:GetService("TweenService"))
}
function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end
function IsInTable(Table,Value)
	for _,v in pairs(Table) do
		if v == Value then
			return true
		end
	end
	return false
end
function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Services.Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end
function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end
local LaserSound = script:WaitForChild("Laser",5)
LaserSound.Parent = Pillar
wait(.5)
local PillarTween = Services.TweenService:Create(Pillar,TweenInfo.new(.5,Enum.EasingStyle.Linear,Enum.EasingDirection.Out,0,false,0),{Transparency = 1,Size = Vector3.new(Pillar.Size.X,30,30),Color = Color3.fromRGB(255, 0, 255)})
local SoundTween = Services.TweenService:Create(LaserSound,TweenInfo.new(.5,Enum.EasingStyle.Linear,Enum.EasingDirection.Out,0,false,0),{Volume = 0})
for _,light in pairs(Pillar:GetChildren()) do
	if light:IsA("Light") then
		local LightTween = Services.TweenService:Create(light,TweenInfo.new(.5,Enum.EasingStyle.Linear,Enum.EasingDirection.Out,0,false,0),{Color = Color3.fromRGB(255, 0, 255)})
		LightTween:Play()
	end
end
LaserSound:Play()
PillarTween:Play()
SoundTween:Play()
local TaggedHumanoids = {}
Pillar.Touched:Connect(function(hit)
	if not hit or not hit.Parent then return end
	local Humanoid = hit.Parent:FindFirstChildOfClass("Humanoid")
	if not Humanoid then return end
	if Creator == Services.Players:GetPlayerFromCharacter(Humanoid.Parent) or IsTeamMate(Creator,Services.Players:GetPlayerFromCharacter(Humanoid.Parent)) or IsInTable(TaggedHumanoids,Humanoid) then return end
	TaggedHumanoids[#TaggedHumanoids+1]=Humanoid
	UntagHumanoid(Humanoid)
	TagHumanoid(Humanoid,Creator)
	Humanoid:TakeDamage(40)
end)
SoundTween.Completed:Wait()
Pillar:Destroy()]]
	elseif v.Name == "RainBeam" then
		source = [[local Creator = script:WaitForChild("Creator",5)
local Tool = script:WaitForChild("Tool",5).Value
local PeriFormation = script:WaitForChild("PeriFormation",5):GetChildren()
if not Creator then script:Destroy() return end
local Humanoid,Root = Creator.Value.Character:FindFirstChildOfClass("Humanoid"),Creator.Value.Character:WaitForChild("HumanoidRootPart",5)
if not Humanoid or not Root then script:Destroy() return end
function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end
local Services = {
	Players = (game:FindService("Players") or game:GetService("Players")),
	TweenService = (game:FindService("TweenService") or game:GetService("TweenService")),
	RunService = (game:FindService("RunService") or game:GetService("RunService")),
	Debris = (game:FindService("Debris") or game:GetService("Debris")),
	TweenService = (game:FindService("TweenService") or game:GetService("TweenService"))
}
local Properties = {
BaseUrl = "rbxassetid://"
}
local Deleteables = {}
local Periastron = Create("Part"){
	Locked = true,
	CanCollide = false,
	Anchored = true,
	Size = Vector3.new(1, 0.6, 5.2)*10,
	Material = Enum.Material.Neon,
	Color = Color3.new(1,1,1)
}
local PeriastronMesh = Create("SpecialMesh"){
	MeshType = Enum.MeshType.FileMesh,
	MeshId = Properties.BaseUrl.."80557857",
	Scale = Vector3.new(1,1,1)*10,
	Parent = Periastron
}
--[[local Surfaces = {"Front","Back","Left","Right","Top","Bottom"}
local BeamLighting = Create("SurfaceLight"){
	Color = Color3.fromRGB(1, 1, 1),
	Angle = 180,
	Enabled = true,
	Range = 100,
	Shadows = false
}
local SurfaceLights = {}]
		local rad = math.rad
		local info = TweenInfo.new(0.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0)
		local Charging = true
		local Animation = script:WaitForChild("Animations",5):WaitForChild(Humanoid.RigType.Name,10):WaitForChild("Release")
		function IsTeamMate(Player1, Player2)
			return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
		end
		function TagHumanoid(humanoid, player)
			local Creator_Tag = Instance.new("ObjectValue")
			Creator_Tag.Name = "creator"
			Creator_Tag.Value = player
			Services.Debris:AddItem(Creator_Tag, 2)
			Creator_Tag.Parent = humanoid
		end
		function UntagHumanoid(humanoid)
			for i, v in pairs(humanoid:GetChildren()) do
				if v:IsA("ObjectValue") and v.Name == "creator" then
					v:Destroy()
				end
			end
		end
		local ReleaseAnim = Humanoid:LoadAnimation(Animation)
		ReleaseAnim:Play(nil,nil,2)
		local RainPeri = Periastron:Clone();RainPeri.Name = "RainbowPeriastron";RainPeri.Size = RainPeri.Size/10
		RainPeri:FindFirstChildOfClass("SpecialMesh").TextureId = Properties.BaseUrl .."157345185"
		RainPeri.CanCollide = false
		RainPeri.CFrame = CFrame.new(Tool:WaitForChild("Handle",5).CFrame.p)*CFrame.Angles(rad(90),0,0);RainPeri.Parent = workspace
		RainPeri.Anchored = true

		local Loc = Root.CFrame.p+Vector3.new(0,55,0)
		local Orientation = Loc + (Creator.Value.Character.PrimaryPart.CFrame.lookVector*-2)
		local PartSizeTween = Services.TweenService:Create(RainPeri,info,{Size = RainPeri.Size,CFrame = CFrame.new(Loc,Orientation)})
		local MeshSizeTween = Services.TweenService:Create(RainPeri:FindFirstChildOfClass("SpecialMesh"),info,{Scale = Vector3.new(1,1,1)*10})
		MeshSizeTween:Play()
		PartSizeTween:Play()PartSizeTween.Completed:Wait()
		local PeriRangers = {} --GO GO PERI RANGERS!!!!
		local FormationModel = Create("Model"){
			Name = "PeriRangers",
			Parent = workspace
		}
		Humanoid.Died:Connect(function()--remove the Giant Peri Formation if you happen to die
			FormationModel:Destroy()
			RainPeri:Destroy()
			for _,deletable in pairs(Deleteables) do
				deletable:Destroy()
			end
			script:Destroy()
			return
		end)
		local CenterPiece = Create("Part"){
			Anchored = true,
			CanCollide = false,
			Transparency = 1,
			Size = Vector3.new(1,1,1)*2,
			CFrame = RainPeri.CFrame*CFrame.new(0,0,-RainPeri.Size.z/2),
			Parent = FormationModel
		}
		FormationModel.PrimaryPart = CenterPiece 
		local spin = 0
		local amount = 10
		spawn(function()
			repeat
				RainPeri.CFrame = CFrame.new(Loc,Loc + (Root.CFrame.lookVector*-2))
				FormationModel:SetPrimaryPartCFrame((RainPeri.CFrame*CFrame.new(0,0,-RainPeri.Size.z/2))*CFrame.Angles(0,0,rad(spin)))
				Services.RunService.Stepped:Wait()
				spin = spin+amount
			until not Charging or not FormationModel or not FormationModel.PrimaryPart
		end)
		RainPeri.Touched:Connect(function(hit)--Spinning blades also kill!
			local Hum = hit.Parent:FindFirstChildOfClass("Humanoid")
			if not Hum then return end
			if Hum == Humanoid or IsTeamMate(Creator.Value,Services.Players:GetPlayerFromCharacter(Hum.Parent)) then return end
			UntagHumanoid(Hum)
			TagHumanoid(Hum,Creator.Value)
			Hum:TakeDamage(Hum.Health)
		end)
		for _,Val in pairs(PeriFormation) do
			local PeriClone = RainPeri:Clone();
			--[[for i,v in pairs(PeriClone:GetChildren()) do
				v:Destroy()
			end]
			PeriClone.Size = PeriClone.Size*10
			local Mesh = PeriClone:FindFirstChildOfClass("SpecialMesh")
			PeriClone.Color = Val.Value
			Mesh.TextureId = Val.Name;
			--Mesh.Scale = Mesh.Scale*10
			PeriClone.Name = "Periastron";
			PeriClone.Parent = FormationModel
			PeriRangers[#PeriRangers+1] = PeriClone
			PeriClone.Touched:Connect(function(hit)--Spinning blades also kill!
				local Hum = hit.Parent:FindFirstChildOfClass("Humanoid")
				if not Hum or Hum == Humanoid or IsTeamMate(Creator.Value,Services.Players:GetPlayerFromCharacter(Hum.Parent)) then return end
				Hum:TakeDamage(Hum.Health)
			end)
		end
		for i,v in pairs(PeriRangers) do
			local pos = (RainPeri.CFrame*CFrame.Angles(rad(90),i*rad(360/#PeriRangers),0))
			v.Anchored = true
			v.CFrame = pos*CFrame.new(0,-v.Size.Z/2,v.Size.Z/2)
		end
		local ChargeSound = script:WaitForChild("ChargeSound",5)
		ChargeSound.Parent = CenterPiece
		ChargeSound:Play()
		local Seed = Random.new(tick())
		local alottedTime = tick()
		--[[workspace.DescendantRemoving:Connect(function(d)
			if d == Tool then
			FormationModel:Destroy()
			RainPeri:Destroy()
			end
		end)]
		spawn(function()
			repeat
				wait(Seed:NextNumber(.05,.2))
				local Index = Seed:NextInteger(1,#PeriRangers)
				local Energy = Create("Part"){
					Material = Enum.Material.Neon,
					CanCollide = false,
					Size = Vector3.new(1,1,1)*Seed:NextInteger(3,10),
					CFrame = (RainPeri.CFrame*CFrame.Angles(rad(Seed:NextInteger(0,360)),rad(Seed:NextInteger(0,360)),rad(Seed:NextInteger(0,360))))*CFrame.new(0,0,Seed:NextInteger(20,50)),
					Color = (PeriRangers[Index] and PeriRangers[Index].Color) or Color3.new(Seed:NextNumber(0,1),Seed:NextNumber(0,1),Seed:NextNumber(0,1)),
					Shape = Enum.PartType.Ball,
					Transparency = 0.5,
					Parent = workspace,
				}
				Deleteables[#Deleteables+1] = Energy
				Energy:SetNetworkOwner(nil)-- So it wouldn't be so laggy looking :P
				local Aim = Create("RocketPropulsion"){
					Target = RainPeri,
					TargetRadius = 4,
					MaxThrust = 10^5,
					TurnD = 10,
					TurnP = 100,
					MaxSpeed = 100,
					CartoonFactor = .8,
					Parent = Energy	
				}
				Aim:Fire()
				spawn(function()
					Aim.ReachedTarget:Wait()
					Energy:Destroy()
				end)
				delay(2,function()--safety catch
					Energy:Destroy()
				end)
			until tick()-alottedTime >= ChargeSound.TimeLength-(.15*#PeriFormation)

			Charging = false
			spawn(function()
				repeat
					FormationModel:SetPrimaryPartCFrame(FormationModel.PrimaryPart.CFrame*CFrame.Angles(0,0,rad(amount)))
					Services.RunService.Stepped:Wait()
				until not FormationModel or not FormationModel.PrimaryPart
			end)

			ChargeSound:Stop()
			wait(1)
			--warn("FIRE!!!!!")

			local RainBeamEnd = Create("Part"){
				Material = Enum.Material.Neon,
				Anchored = true,
				CanCollide = false,
				Transparency = .2,
				Size = Vector3.new(1,1,1)*150,
				CFrame = (RainPeri.CFrame*CFrame.Angles(0,rad(90),0))*CFrame.new((-150/3)+(RainPeri.Size.Z/2),0,0),
				Shape = Enum.PartType.Ball,
				Parent = workspace
			}
			local RainBeam = Create("Part"){
				Material = Enum.Material.Neon,
				Anchored = true,
				CanCollide = false,
				Transparency = .2,
				Size = Vector3.new(0,150,150),
				CFrame = RainBeamEnd.CFrame * CFrame.new(0,0,0),
				Shape = Enum.PartType.Cylinder,
				Parent = workspace
			}

		--[[for _,surfaces in pairs(Surfaces) do
			local Lighting = BeamLighting:Clone()
			Lighting.Face = Enum.NormalId[surfaces]
			Lighting.Parent = RainBeamEnd
			SurfaceLights[#SurfaceLights+1]=Lighting
		end
		for _,surfaces in pairs(Surfaces) do
			local Lighting = BeamLighting:Clone()
			Lighting.Face = Enum.NormalId[surfaces]
			Lighting.Parent = RainBeam
			SurfaceLights[#SurfaceLights+1]=Lighting
		end]

			Deleteables[#Deleteables+1]=RainBeamEnd
			Deleteables[#Deleteables+1]=RainBeam
			RainBeam.Touched:Connect(function(hit)
				if not hit or not hit.Parent then return end
				local Hum = hit.Parent:FindFirstChildOfClass("Humanoid")
				local ForceField = hit.Parent:FindFirstChildOfClass("ForceField")
				if not Hum or ForceField then return end
				if Hum == Humanoid or IsTeamMate(Creator.Value,Services.Players:GetPlayerFromCharacter(Hum.Parent)) then return end
				UntagHumanoid(Hum)
				TagHumanoid(Hum,Creator.Value)
				Hum:TakeDamage(Hum.Health)
				hit:Destroy()
			end)
			RainBeamEnd.Touched:Connect(function(hit)
				if not hit or not hit.Parent then return end
				local Hum = hit.Parent:FindFirstChildOfClass("Humanoid")
				local ForceField = hit.Parent:FindFirstChildOfClass("ForceField")
				if not Hum or ForceField then return end
				if Hum == Humanoid or IsTeamMate(Creator.Value,Services.Players:GetPlayerFromCharacter(Hum.Parent)) then return end
				UntagHumanoid(Hum)
				TagHumanoid(Hum,Creator.Value)
				Hum:TakeDamage(Hum.Health)
				hit:Destroy()
			end)
			spawn(function()


				while RainBeam and RainBeamEnd do
					--RainBeamEnd.Color = PeriRangers[Seed:NextInteger(1,#PeriRangers)].Color
					--RainBeam.Color = RainBeamEnd.Color
					for _,PeriProperty in pairs(PeriFormation) do
						if PeriProperty.Value then
							local Tween = Services.TweenService:Create(RainBeam,TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0),{Color = PeriProperty.Value})
							local Tween2 = Services.TweenService:Create(RainBeamEnd,TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0),{Color = PeriProperty.Value})

						--[[for _,lights in pairs(SurfaceLights) do
							for _,PeriProperty in pairs(PeriFormation) do
								if PeriProperty.Value then
									local LightTween = Services.TweenService:Create(lights,TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0),{Color = PeriProperty.Value})
									LightTween:Play()	
								end
							end
						end]

							Tween:Play();Tween2:Play()
							Tween2.Completed:Wait()
						end
					end
					Services.RunService.Stepped:Wait()
				end
			end)
			local FireSound = script:WaitForChild("FireSound",5)
			FireSound.Parent = CenterPiece
			local LoopSound = script:WaitForChild("LoopSound",5)
			LoopSound.Parent = CenterPiece
			FireSound:Play()
			LoopSound:Play()
		--[[local Velo = Create("BodyVelocity"){
			Velocity = -RainPeri.CFrame.lookVector*100,
			MaxForce = Vector3.new(1,1,1)*math.huge,
			Parent = RainBeam,
		}]
			local BeamInfo = TweenInfo.new(5, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0)
			local SizeTween = Services.TweenService:Create(RainBeam,BeamInfo,{Size = Vector3.new(500,RainBeam.Size.Y,RainBeam.Size.Z),CFrame = (RainBeamEnd.CFrame*CFrame.new(-500/2,0,0))})
			SizeTween:Play();SizeTween.Completed:Wait()
			--RainBeam.Anchored = false
			local CoolDownSound = Create("Sound"){
				SoundId = "rbxassetid://1899277236",
				Volume = 2,
				Looped = false,
				Parent = CenterPiece
			}
			local AlphaTween = Services.TweenService:Create(RainBeam,TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0),{Transparency = 1})
			AlphaTween:Play()
			local AlphaTween2 = Services.TweenService:Create(RainBeamEnd,TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.In, 0, false, 0),{Transparency = 1})
			AlphaTween2:Play();
			AlphaTween2.Completed:Wait()
			FireSound:Destroy()
			LoopSound:Destroy()
			CoolDownSound:Play()
			spawn(function()
				repeat
					amount = math.clamp(amount-0.05,0,10)
					Services.RunService.Stepped:Wait()
				until not FormationModel
			end)
			RainBeamEnd:Destroy()
			RainBeam:Destroy()
			CoolDownSound.Ended:Wait()
			delay(1,function()
				RainPeri:Destroy()
				FormationModel:Destroy()
				script:Destroy()
			end)

		end)
		]]
	elseif v.Name == "RevealRainbow" then
		source = [[function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end
local Character = script.Parent
local Hum = Character:FindFirstChildOfClass("Humanoid")
local Center = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso") or Character:FindFirstChild("HumanoidRootPart")
if not Center then script:Destroy() end
local Creator = script:WaitForChild("Creator",5)
local Tool = script:WaitForChild("Tool",5)
local Range = script:WaitForChild("Range",5)
if not Creator or not Tool or not Range then script:Destroy() return end
Creator = Creator.Value
Tool = Tool.Value
Range = Range.Value
local CreatorTorso = Creator:FindFirstChild("HumanoidRootPart") or Creator:FindFirstChild("Torso") or Creator:FindFirstChild("UpperTorso")
local Services = {
	RunService = (game:FindService("RunService") or game:GetService("RunService")),
	Debris = (game:FindService("Debris") or game:GetService("Debris"))
}
local SONARPeri = Create("Part"){
	Name = "SONARPeri",
	Size = Vector3.new(1,0.6,5.2),
	Locked = true,
	Anchored = false,
	CanCollide = false,
	Material = Enum.Material.Plastic
}
local BaseUrl = "http://www.roblox.com/asset/?id="
local SONARPeriMesh = Create("SpecialMesh"){
	MeshType = Enum.MeshType.FileMesh,
	Offset = Vector3.new(0,0,0),
	Scale = Vector3.new(1,1,1),
	VertexColor = Vector3.new(1,1,1),
	MeshId = BaseUrl.."80557857",
	TextureId = BaseUrl.."73816926",
	Parent = SONARPeri
}
local Pos = Create("BodyPosition"){
	MaxForce = Vector3.new(1,1,1)*math.huge,
	Position = (Center.CFrame * CFrame .new(0,0,-3)).p,
	D = 1250,
	P = 10^4,
	Parent = SONARPeri
}
local Beep = script:WaitForChild("SONARBeep",5)
Beep.Parent = Center
Beep:Play()
SONARPeri.CFrame = CFrame.new(Center.CFrame.p+Vector3.new(0,10,0))*CFrame.Angles(math.rad(90),0,0)
Pos.Position = Center.CFrame.p + Vector3.new(0,10,0)
SONARPeri.Parent = Character
local Speed = Hum.WalkSpeed
for i=25,0,-1 do
	SONARPeri.Transparency = (i/60)
	Services.RunService.Heartbeat:Wait()
end
repeat
Pos.Position = Center.CFrame.p + Vector3.new(0,10,0)
Services.RunService.Heartbeat:Wait()
--print(Center)
until (Center.CFrame.p-CreatorTorso.CFrame.p).Magnitude > Range or not Tool:IsDescendantOf(Creator) or not Tool:IsDescendantOf(workspace) or Hum.WalkSpeed ~= Speed or Hum.Health <= 0 or not Center or not Center:IsDescendantOf(workspace) or not Character or not Character:IsDescendantOf(workspace)
for i=0,25,1 do
	SONARPeri.Transparency = (i/60)
	Services.RunService.Heartbeat:Wait()
end
SONARPeri:Destroy()
script:Destroy()]]
	elseif v.Name == "RockSummon" then
		source = [[function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end
local function VisualizeRay(ray,RayLength)
	local RayCast = Create("Part"){
		Material = Enum.Material.Neon,
		Color = Color3.new(0,1,0),
		Size = Vector3.new(0.3,0.3,(RayLength or 5)),
		CFrame = CFrame.new(ray.Origin, ray.Origin+ray.Direction) * CFrame.new(0, 0, -(RayLength or 5) / 2),
		Anchored = true,
		CanCollide = false,
		Parent = workspace
	}
	game:GetService("Debris"):AddItem(RayCast,5)
end
local Rock = script.Parent
local Seed = Random.new(tick())
local Creator = script:WaitForChild("Creator",5).Value
local RockCollection = {Rock}
function RayCast(Pos, Dir, Max, IgnoreList)
	return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(Pos, Dir.unit * (Max or 999.999)), IgnoreList) 
end
local RockTemplate = Rock:Clone()
RockTemplate:ClearAllChildren()
local SurroundingRockCount = 30
for i=1,SurroundingRockCount,1 do
	local Position = ((CFrame.new(Rock.CFrame.p+Vector3.new(0,5,0))*CFrame.Angles(0,math.rad((i*(360/SurroundingRockCount))),0))*CFrame.new(0,0,15)).p
	local hit,pos = RayCast(Position,((Position + Vector3.new(0,-1,0))-Position).Unit,10,RockCollection)
	--VisualizeRay(Ray.new(Position,((Position + Vector3.new(0,-1,0))-Position).Unit),10)
	--print(hit)
	if hit then
		local RockBase = RockTemplate:Clone()
		RockCollection[#RockCollection+1] = RockBase
		RockBase.Size = Vector3.new(1,1,1)*Seed:NextNumber(7,9)
		RockBase.Color = hit.Color
		RockBase.CFrame = CFrame.new(pos)*CFrame.Angles(math.rad(Seed:NextInteger(0,360)),math.rad(Seed:NextInteger(0,360)),math.rad(Seed:NextInteger(0,360)))
		RockBase.Parent = workspace
	end
end
local Smoke = script:WaitForChild("SmashSmoke",5)
Smoke.Color = ColorSequence.new(Rock.Color)
Smoke.Parent = Rock
Smoke:Emit(Smoke.Rate)
local ExplosionSound = script:WaitForChild("Explosion",5)
ExplosionSound.Parent = Rock
ExplosionSound:Play()
local CrumnbleSound = script:WaitForChild("Crumble",5)
CrumnbleSound.Parent = Rock
CrumnbleSound:Play()
delay(4,function()
	for _,rocks in pairs(RockCollection) do
		rocks:Destroy()
	end
	Rock:Destroy()
end)]]
	elseif v.Name == "ShieldScript" then
		source = [[local Character = script.Parent
local Services = {
	Players = (game:FindService("Players") or game:GetService("Players")),
	TweenService = (game:FindService("TweenService") or game:GetService("TweenService")),
	RunService = (game:FindService("RunService") or game:GetService("RunService")),
	Debris = (game:FindService("Debris") or game:GetService("Debris"))
}
function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end
function Create(ty)
	return function(data)
		local obj = Instance.new(ty)
		for k, v in pairs(data) do
			if type(k) == 'number' then
				v.Parent = obj
			else
				obj[k] = v
			end
		end
		return obj
	end
end
local BaseUrl = "http://www.roblox.com/asset/?id="
local Properties = {
	CurrentRadius = 20
}
local Center = (Character:FindFirstChild("HumanoidRootPart"))
if not Center then script:Destroy() end
local Shield = Create("Part"){
	Transparency = 0.5,
	Shape = Enum.PartType.Ball,
	Material = Enum.Material.Neon,
	Locked = true,
	CanCollide = false,
	Anchored = false,
	Size = Vector3.new(1,1,1)*1,
	CFrame = Center.CFrame,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
	Color = Color3.fromRGB(0,128,0),
}
local ShieldMesh = Create("SpecialMesh"){
	MeshType = Enum.MeshType.Sphere,
	Offset = Vector3.new(0,0,0),
	Scale = Vector3.new(0,0,0),
	VertexColor = Vector3.new(0,1,0)*10^5,
	--TextureId = BaseUrl.."883311537",
	Parent = Shield
}
local WeldConstraint = Create("WeldConstraint"){
	Part0 = Center,
	Part1 = Shield,
	Parent = Shield
}
Shield.CFrame = Center.CFrame
Shield.Parent = Character
delay(2,function()
	Shield:Destroy()
	script:Destroy()
end)
spawn(function()
	repeat
	spawn(function()
		local NegativeRegion = (Center.Position - Vector3.new(ShieldMesh.Scale.X, ShieldMesh.Scale.Y, ShieldMesh.Scale.Z))
		local PositiveRegion = (Center.Position + Vector3.new(ShieldMesh.Scale.X, ShieldMesh.Scale.Y, ShieldMesh.Scale.Z))
		local Region = Region3.new(NegativeRegion, PositiveRegion)
		local Parts = workspace:FindPartsInRegion3WithIgnoreList(Region,{Character,Shield},math.huge)
		for _,hit in pairs(Parts) do
			if hit and hit.Parent and not hit.Anchored and (hit.CFrame.p-Shield.CFrame.p).Magnitude <= Properties.CurrentRadius then
				local Knockback = Create("BodyVelocity"){
					MaxForce = Vector3.new(1,1,1)*math.huge,
					Velocity = ((hit.CFrame.p-Shield.CFrame.p).Unit*100)+Vector3.new(0,50,0),
					Name = "Knockback",
					Parent = hit
				}
				Services.Debris:AddItem(Knockback,.1)
			end
		end
	end)
	Services.RunService.Stepped:Wait()
	--Services.RunService.Heartbeat:Wait()
	until not Shield or not Shield.Parent
end)
local CharacterHumanoid = Character:FindFirstChildOfClass("Humanoid")
--[[spawn(function()
	repeat
		CharacterHumanoid.Health = CharacterHumanoid.Health + .5
		Services.RunService.Heartbeat:Wait()
	until not Shield or not Shield.Parent or not CharacterHumanoid or not CharacterHumanoid.Parent
end)]
		for i=1,20,1 do
			if Shield and Shield.Parent and Center and Center.Parent then
				ShieldMesh.Scale = Vector3.new(0,0,0):Lerp(Vector3.new(1,1,1)*Properties.CurrentRadius,i/30)
				Services.RunService.Heartbeat:Wait()	
			end
		end]]
	elseif v.Name == "StarShard" then
		source = [[local Shard = script.Parent
delay(2,function()
	Shard:Destroy()
end)
local Creator = script:WaitForChild("Creator",10)
local CreatorHumanoid = Creator.Value.Character:FindFirstChildOfClass("Humanoid")
local Services = {
	Players = (game:FindService("Players") or game:GetService("Players")),
	TweenService = (game:FindService("TweenService") or game:GetService("TweenService")),
	RunService = (game:FindService("RunService") or game:GetService("RunService")),
	Debris = (game:FindService("Debris") or game:GetService("Debris"))
}
local Properties = {
	CurrentRadius = 7.5
}
function IsInTable(Table,Value)
	for _,v in pairs(Table) do
		if v == Value then
			return true
		end
	end
	return false
end
function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end
function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Services.Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end
function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end
local function GetNearestTorso(MarkedPosition,TorsoPopulationTable)
	local ClosestDistance = math.huge
	local ClosestTorso
	for i=1,#TorsoPopulationTable do
		local distance = (TorsoPopulationTable[i].CFrame.p-MarkedPosition).magnitude
		if TorsoPopulationTable[i] and  distance < ClosestDistance then
			ClosestDistance = distance
			ClosestTorso = TorsoPopulationTable[i]
		end
	end
	--warn("The Closest Person is: "..ClosestTorso.Parent.Name)
	return ClosestTorso
end
local function TrackCharacters(Center,Range)
	local Characters = {}
	local Players = {}
	local NegativeRegion = (Center.Position - Vector3.new(Range, Range, Range))
	local PositiveRegion = (Center.Position + Vector3.new(Range, Range, Range))
	local Region = Region3.new(NegativeRegion, PositiveRegion)
	local Parts = workspace:FindPartsInRegion3(Region,Creator.Value.Character,math.huge)
	local TaggedHumanoids = {}
		for _,hit in pairs(Parts) do
			if string.find(string.lower(hit.Name),"torso") then
				local ForceField = hit.Parent:FindFirstChildOfClass("ForceField")
				local Hum = hit.Parent:FindFirstChildOfClass("Humanoid")
				if Hum and Hum.Parent and Hum.Health > 0 and Creator.Value.Character and Hum ~= Creator.Value.Character:FindFirstChildOfClass("Humanoid") and not IsInTable(TaggedHumanoids,Hum) and not IsTeamMate(Creator.Value,Services.Players:GetPlayerFromCharacter(Hum.Parent)) and not ForceField then
					TaggedHumanoids[#TaggedHumanoids+1] = Hum
					if Services.Players:GetPlayerFromCharacter(Hum.Parent) then
						--print("Is a Player")
						Players[#Players+1] = hit
					else
						--print("Is an NPC")
						Characters[#Characters+1] = hit
					end
				end
			end
		end
	return Characters,Players
end
local Rocket = Instance.new("RocketPropulsion")
Rocket.CartoonFactor = 0.05
Rocket.TargetRadius = 4
Rocket.TargetOffset = Vector3.new(0,0,0)
Rocket.MaxThrust = 10^2
Rocket.ThrustP = 10^1
Rocket.TurnP = 10
Rocket.MaxSpeed = 20
Rocket.Parent = Shard
local Touch
function Damage(hit,TotalDamage)
	if not hit or not hit.Parent then return end
	local Hum = hit.Parent:FindFirstChildOfClass("Humanoid")
	local ForceField = hit.Parent:FindFirstChildOfClass("ForceField")
	if not Hum or Hum.Health <=0 or Hum:IsDescendantOf(Creator.Value.Character) then return end
	
	if IsTeamMate(Creator.Value,Services.Players:GetPlayerFromCharacter(Hum.Parent)) then return end
	local Player = Services.Players:GetPlayerFromCharacter(Hum.Parent)
	spawn(function()
		UntagHumanoid(Hum)
		TagHumanoid(Hum,Creator.Value)
		Hum:TakeDamage(TotalDamage)
		--Hum:UnequipTools()
		Touch:Disconnect()
		Shard:Destroy()
		--wait(.5)
	end)
end
Touch = Shard.Touched:Connect(function(hit)
	Damage(hit,10)
end)
repeat
	local NPCs,Players = TrackCharacters(Shard,Properties.CurrentRadius)
	
	local PriorityTable = ((#Players > 0 and Players) or NPCs)-- Players before NPCs
	local PriorityTorso = GetNearestTorso(Shard.CFrame.p,PriorityTable)
	
	if PriorityTorso and Rocket.Target ~= PriorityTorso then
		--Track Target
		Rocket:Abort()
		Rocket.Target = PriorityTorso
		Rocket:Fire()
	end
	wait(1/10)
	--Services.RunService.Heartbeat:Wait()
until not Shard or not Shard.Parent]]
	elseif v.Name == "LightFade" then
		source = [[local Light = script.Parent
local TweenService = (game:FindService("TweenService") or game:GetService("TweenService"))
local LightFade = TweenInfo.new(1,Enum.EasingStyle.Linear,Enum.EasingDirection.In,0,false,.5)
local ColorCycle = {}
ColorCycle[#ColorCycle+1] = Color3.fromRGB(0,0,0)
ColorCycle[#ColorCycle+1] = Color3.fromRGB(255,255,255)
ColorCycle[#ColorCycle+1] = Color3.fromRGB(255,0,0)
ColorCycle[#ColorCycle+1] = Color3.fromRGB(255,176,0)
ColorCycle[#ColorCycle+1] = Color3.fromRGB(0,255,0)
ColorCycle[#ColorCycle+1] = Color3.fromRGB(0,0,255)
ColorCycle[#ColorCycle+1] = Color3.fromRGB(102, 51, 0)
ColorCycle[#ColorCycle+1] = Color3.fromRGB(170,0,170)
ColorCycle[#ColorCycle+1] = Color3.fromRGB(255, 85, 255)
while Light do
	for _,Colors in pairs(ColorCycle) do
		local Tween = TweenService:Create(Light,LightFade,{Color = Colors})
		Tween:Play()
		Tween.Completed:Wait()
	end
end]]
	elseif v.Name == "SubspaceMine" then
		source = [[Mine = script.Parent
DunDun = Instance.new("Sound")
DunDun.SoundId = "http://www.roblox.com/asset/?id=11984254"
DunDun.Parent = Mine
SubspaceExplosion = Instance.new("Sound")
SubspaceExplosion.SoundId = "http://www.roblox.com/asset/?id=11984351"
SubspaceExplosion.Parent = Mine
Calibrate = Instance.new("Sound")
Calibrate.SoundId = "http://www.roblox.com/asset/?id=11956590"
Calibrate.Looped = true
Calibrate.Parent = Mine
Calibrate:Play()
local calibration_time = 2 -- needs to be still/untouched for this long before calibrating
local cur_time = 0
local max_life = 120 -- these things last for 2 minutes on their own, once activated
local calibrated = false
local connection = nil
function activateMine()
	for i=0,1,.1 do
		Mine.Transparency = i
		wait(.05)
	end
	calibrated = true
	Calibrate:Stop()
end
function pulse()
	DunDun:Play()
	for i=.9,.5,-.1 do
		Mine.Transparency = i
		wait(.05)
	end
	for i=.5,1,.1 do
		Mine.Transparency = i
		wait(.05)
	end
end
function explode()
	connection:disconnect()
	for i=1,0,-.2 do
		Mine.Transparency = i
		wait(.05)
	end
	SubspaceExplosion:Play()
	local e = Instance.new("Explosion")
	e.BlastRadius = 16
	e.BlastPressure = 1000000
	e.Position = Mine.Position
	e.Parent = Mine
	local creator = script.Parent:findFirstChild("creator")
	e.Hit:connect(function(part, distance)  onPlayerBlownUp(part, distance, creator) end)
	for i=0,1,.2 do
		Mine.Transparency = i
		wait(.05)
	end
	wait(4)
	Mine:Remove()
end
function update()
	if (calibrated == false) then
		if (Mine.Velocity.magnitude > .05) then
			cur_time = 0
		end
		if (cur_time > calibration_time) then
			activateMine()
		end
	else
		-- calibrated mine
		if (math.random(1,20) == 2) then
			pulse()
		end
		if (cur_time > max_life) then pulse() Mine:Remove() end
	end
end
function OnTouch(part)
	if (calibrated == false) then
		cur_time = 0
	else
		explode()
	end
end
function onPlayerBlownUp(part, distance, creator)
	if (part:getMass() < 300) then
		part.BrickColor = BrickColor.new(1032)
		local s = Instance.new("Sparkles")
		s.Parent = part
		game.Debris:AddItem(s, 5)
	end
	
	if creator ~= nil and part.Name == "Head" then
		local humanoid = part.Parent.Humanoid
		tagHumanoid(humanoid, creator)
	end
end
function tagHumanoid(humanoid, creator)
	-- tag does not need to expire iff all explosions lethal
	
	if creator ~= nil then
		local new_tag = creator:clone()
		new_tag.Parent = humanoid
	end
end
function untagHumanoid(humanoid)
	if humanoid ~= nil then
		local tag = humanoid:findFirstChild("creator")
		if tag ~= nil then
			tag.Parent = nil
		end
	end
end
connection = Mine.Touched:connect(OnTouch)
while true do
	update()
	local e,g = wait(.5)
	cur_time = cur_time + e
end]]
	elseif v.Name == "SandwichScript" then
		source = [[local Tool = script.Parent;
enabled = true
function onActivated()
	if not enabled  then
		return
	end
	enabled = false
	Tool.GripForward = Vector3.new(0.675, -0.675, -0.3)
	Tool.GripPos = Vector3.new(0.4, -0.9, 0.9)
	Tool.GripRight = Vector3.new(0.212, -0.212, 0.954)
	Tool.GripUp = Vector3.new(0.707, 0.707, 0)
	Tool.Handle.DrinkSound:Play()
	wait(.8)
	
	local h = Tool.Parent:FindFirstChild("Humanoid")
	if (h ~= nil) then
		if (h.MaxHealth > h.Health + 1.6) then
			h.Health = h.Health + 1.6
		else	
			h.Health = h.MaxHealth
		end
	end
	Tool.GripForward = Vector3.new(-1, 0, 0)
	Tool.GripPos = Vector3.new(.2, 0, 0)
	Tool.GripRight = Vector3.new(0, 0, -1)
	Tool.GripUp = Vector3.new(0,1,0)
	enabled = true
end
function onEquipped()
	Tool.Handle.OpenSound:play()
end
script.Parent.Activated:connect(onActivated)
script.Parent.Equipped:connect(onEquipped)]]
	elseif v.Name == "SlateskinPotionScript" then
		source = [[--Rescripted by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
GlassScript = script:WaitForChild("GlassScript")
Sounds = {
	GlassBreak = Handle:WaitForChild("GlassBreak"),
	Drink = Handle:WaitForChild("Drink"),
	Slateskin = Handle:WaitForChild("Slateskin"),
}
Grips = {
	Normal = CFrame.new(0.1, 0, 0.1, 0.217036337, 0, 0.976163626, 0, 1, -0, -0.976163507, 0, 0.217036366),
	Drinking = CFrame.new(1.5, -0.35, 0.1, 1, 0, -0, -0, 0.651038408, 0.759044766, 0, -0.759044766, 0.651038408),
}
ToolEquipped = false
ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool
ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool
Tool.Grip = Grips.Normal
Tool.Enabled = true
function Transform(character)
end
function SlateMe(character)
	for i, v in pairs(character:GetChildren()) do
		if v:IsA("Clothing") then
			v:Destroy()
		elseif v:IsA("BasePart") then
			v.Material = Enum.Material.Slate
			v.BrickColor = BrickColor.new("Dark stone grey")
		elseif v:IsA("Humanoid") then
			v.WalkSpeed = (16 * 0.9)
			v.MaxHealth = 150
			v.Health = v.MaxHealth
		end
	end
end
function Activated()
	if not Tool.Enabled or not CheckIfAlive() then
		return
	end
	
	if ToolUnequipped then
		ToolUnequipped:disconnect()
	end	
	
	local CurrentlyEquipped = true
	ToolUnequipped = Tool.Unequipped:connect(function()
		CurrentlyEquipped = false
	end)
	Tool.Enabled = false
	Tool.Grip = Grips.Drinking
	
	Sounds.Drink:Play()
	
	wait(3)
	
	if not CurrentlyEquipped then
		Tool.Grip = Grips.Normal
		Tool.Enabled = true
		return
	end
	
	Sounds.Slateskin:Play()
	
	SlateMe(Character)
	Tool.Grip = Grips.Normal
	wait(1)
	
	if CurrentlyEquipped then
		local Part = Handle:Clone()
		local GlassBreakSound = Sounds.GlassBreak:Clone()
		GlassBreakSound.Parent = Part
		Part.Transparency = 0
		local Direction = Head.CFrame.lookVector
		Part.Velocity = (Direction * 45) + Vector3.new(0, 45, 0)
		Part.CanCollide = true
		local GlassScriptClone = GlassScript:Clone()
		GlassScriptClone.Disabled = false
		GlassScriptClone.Parent = Part
		Debris:AddItem(Part, 30)
		Part.Parent = game:GetService("Workspace")
	end
	Debris:AddItem(Tool, 0)
	
end
function CheckIfAlive()
	return (((Player and Player.Parent and Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Head and Head.Parent) and true) or false)
end
function Equipped()
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Head = Character:FindFirstChild("Head")
	if not CheckIfAlive() then
		return
	end
	ToolEquipped = true
end
function Unequipped()
	if ToolUnequipped then
		ToolUnequipped:disconnect()
	end
	for i, v in pairs(Sounds) do
		v:Stop()
	end
	ToolEquipped = false
end
Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "GlassScript" then
		source = [[--Rescripted by Luckymaxer
Part = script.Parent
Debris = game:GetService("Debris")
Sounds = {
	GlassBreak = Part:WaitForChild("GlassBreak")
}
function Touched(Part)
	local PartTouched
	PartTouched = Part.Touched:connect(function(Hit)
		if not Hit or not Hit.Parent then
			return
		end
		Sounds.GlassBreak:Play()
		if PartTouched then
			PartTouched:disconnect()
		end
	end)
end
Touched(Part)
Debris:AddItem(Part, 30)]]
	elseif v.Name == "FireScript" and v.Parent:FindFirstChild("ThumbnailPose") then
		source = [[--Fixed by Luckymaxer
local fire = script.Parent:FindFirstChild("Fire")
local light = script.Parent:FindFirstChild("PointLight")
function largestSide(length,width,height)
	local large = 0
	if length > width then
		large = length
	else
		large = width
	end
	if large < height then
		large = height
	end
	if large > 30 then
		return 30
	end
	return large
end
local largestSize = largestSide(script.Parent.Size.x,script.Parent.Size.y,script.Parent.Size.z)
local interval = largestSize/15
while fire and light and fire.Size <= largestSize do
	fire.Size = fire.Size + interval
	light.Range=fire.Size*6
	wait(1)
	fire = script.Parent:FindFirstChild("Fire")
	light = script.Parent:FindFirstChild("PointLight")
end
wait(3)
fire = script.Parent:FindFirstChild("Fire")
light = script.Parent:FindFirstChild("PointLight")
while fire and light and fire.Size > 2 do
	fire.Size = fire.Size - interval
	light.Range=fire.Size*6
	wait(1)
	fire = script.Parent:FindFirstChild("Fire")
	light = script.Parent:FindFirstChild("PointLight")
end
if fire and light then
	fire.Enabled = false
	light.Enabled=false
end
wait(1)
script:remove()]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("FireScript") then
		source = [[local Tool = script.Parent
local debris = game:GetService("Debris")
local player = nil
Fire = Tool.Handle:WaitForChild("Fire")
Tool.Handle:WaitForChild("PointLight")
Tool.Handle:WaitForChild("Light")
Tool:WaitForChild("FireScript")
Fire.Enabled = false
Tool.Equipped:connect(function()
	player = Tool.Parent
end)
Tool.Handle.Touched:connect(function(part)
	if Tool.Handle.Fire.Enabled == false then
		return
	end
	local children = part:GetChildren()
	for i = 1, #children do
		if children[i].className == "Fire" then
			return
		end
	end
	if part.Parent == player then
		return
	end
	if part.Material ==  Enum.Material.Wood then
		local fire = Tool.Handle.Fire:clone()
		fire.Parent = part
		local light=Tool.Handle.PointLight:clone()
		light.Parent=part
		
		local fireScript = Tool.FireScript:clone()
		fireScript.Parent = part
		fireScript.Disabled = false
		debris:AddItem(fire,35)
		debris:AddItem(light,35)
	end
end)
Tool.Activated:connect(function()
	Tool.Handle.Fire.Enabled = not Tool.Handle.Fire.Enabled
	Tool.Handle.PointLight.Enabled = not Tool.Handle.PointLight.Enabled
	Tool.Handle.Light:Play()
end)]]
	elseif v.Name == "MoneyBagScript" then
		source = [[--Updated for R15 avatars by StarWars
local Tool = script.Parent;
debris = game:GetService("Debris")
enabled = true
local sounds = {Tool.Handle.MoneySound1, Tool.Handle.MoneySound2, Tool.Handle.MoneySound3}
local buck = nil
buck = Instance.new("Part")
buck.formFactor = 2
buck.Size = Vector3.new(2,.4,1)
buck.BrickColor = BrickColor.new(28)
buck.TopSurface = 0
buck.BottomSurface = 0
buck.Elasticity = .01 
local d = Instance.new("Decal")
d.Face = 4
d.Texture = "http://www.roblox.com/asset/?id=16658163"
d.Parent = buck
local d2 = d:Clone()
d2.Face = 1
d2.Parent = buck
function isTurbo(character)
	return character:FindFirstChild("Monopoly") ~= nil
end
function MakeABuck(pos)
	local limit = 5
	if (isTurbo(Tool.Parent) == true) then
		limit = 15 -- LOL!
	end
	for i=1,limit do
		local b = buck:Clone()
		local v = Vector3.new(math.random() - .5, math.random() - .5, math.random() - .5).unit
		b.CFrame = CFrame.new(pos + (v * 2) + Vector3.new(0,4,0), v)
		b.Parent = game.Workspace
		debris:AddItem(b, 60)
	end
end
function onActivated()
	if not enabled  then
		return
	end
	enabled = false
	local char = Tool.Parent
	sounds[math.random(3)]:Play()
	MakeABuck(Tool.Handle.Position)
	
	local Torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
	local RightArm = char:FindFirstChild("Right Arm") or char:FindFirstChild("RightUpperArm")
	local RightShoulder = Torso:FindFirstChild("Right Shoulder") or RightArm:FindFirstChild("RightShoulder")
	RightShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = 3
	wait(.2)
	RightShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = 3
	wait(.2)
	RightShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = 3
	wait(.2)
	RightShoulder.MaxVelocity = 0.5
	RightShoulder.DesiredAngle = 3
	wait(.2)
	RightShoulder.MaxVelocity = 1
--[[
	Tool.GripForward = Vector3.new(0,-1,0)
	Tool.GripPos = Vector3.new(0,0,2)
	Tool.GripRight = Vector3.new(1,0,0)
	Tool.GripUp = Vector3.new(0,0,-1)
]
		enabled = true
	end
	script.Parent.Activated:connect(onActivated)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("Handle"):FindFirstChild("Drop") then
		source = [[--Made by Luckymaxer
--Updated for R15 avatars by StarWars
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Mesh = Handle:WaitForChild("Mesh")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
RemoteControl = Tool:WaitForChild("RemoteControl")
ServerControl = (RemoteControl:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = RemoteControl
ClientControl = (RemoteControl:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = RemoteControl
SkateboardModule = require(199238756)
SkateboardFunctions = SkateboardModule.SkateboardFunctions
Functions = SkateboardModule.Functions
Skateboard = SkateboardFunctions.GetSkateboard("Segway")
SkateboardFunctions.CreateConfiguration(Tool, Skateboard)
SkateboardPlatform = SkateboardFunctions.GetSkateboardPlatform(Skateboard)
Grips = {
	Display = CFrame.new(1.5, 3.6, -1.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),
	Equipped = CFrame.new(0, -0.1, -0.2, 0, -1, 0, -1, -0, 0, 0, -0, -1),
}
Sounds = {
	Drop = Handle:WaitForChild("Drop")
}
ToolEquipped = false
ToolEnabled = true
Tool.Grip = Grips.Equipped
Tool.Enabled = true
ServerControl.OnServerInvoke = (function(player, Mode, Value)
end)
function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end
function DropSkateboard()
	
	local MousePosition = InvokeClient("MousePosition")
	
	local DesiredAngle = (math.acos((MousePosition - Handle.Position).unit:Dot(Torso.CFrame.lookVector)))
	if DesiredAngle > (math.pi / 2) then --Prevents spawning behind character.
		--return
	end
	
	local SkateboardSize = Skateboard:GetModelSize()	
	
	local Direction = CFrame.new(Torso.Position, Vector3.new(MousePosition.X, Torso.Position.Y, MousePosition.Z))
	local SkateboardCFrame = Direction + Direction.lookVector * (((Torso.Size.Z / 2) + (SkateboardSize.Z / 2)) * 1.5)
	local SkateboardAngle = CFrame.Angles(0, 0, 0)
	
	local RayOffset = Vector3.new(-1.5, 0, -1.5)
	
	local RayPoints = { --Border points and center of skateboard used for casting rays.
		Center = Functions.PositionPart(SkateboardCFrame, 0, 0, 0),
		BackLeft = Functions.PositionPart(SkateboardCFrame, -((SkateboardSize.X / 2) + RayOffset.X), RayOffset.Y, -((SkateboardSize.Z / 2) + RayOffset.Z)),
		BackRight = Functions.PositionPart(SkateboardCFrame, ((SkateboardSize.X / 2) + RayOffset.X), RayOffset.Y, -((SkateboardSize.Z / 2) + RayOffset.Z)),
		FrontLeft = Functions.PositionPart(SkateboardCFrame, -((SkateboardSize.X / 2) + RayOffset.X), RayOffset.Y, ((SkateboardSize.Z / 2) + RayOffset.Z)),
		FrontRight = Functions.PositionPart(SkateboardCFrame, ((SkateboardSize.X / 2) + RayOffset.X), RayOffset.Y, ((SkateboardSize.Z / 2) + RayOffset.Z)),
	}
	
	local RayData = {
		Area = { --Cast ray to determine if skateboard will spawn inside something.
			Offset = Vector3.new(0, (SkateboardSize.Y / 2), 0),
			Direction = Vector3.new(0, 1, 0),
			Distance = SkateboardSize.Y
		},
		Ground = { --Cast ray to determine if the skateboard can spawn on the ground.
			Direction = Vector3.new(0, -1, 0),
			Distance = (SkateboardSize.Y * 4)
		}
	}
	
	local Ignore = {Character, Skateboard}
	
	local HighestGroundRayHit, HighestGroundRayPos --Get the highest point of elevation to spawn the skateboard.
	for i, v in pairs(RayPoints) do
		local GroundRayHit, GroundRayPos = Functions.RayCast(v.p, RayData.Ground.Direction, RayData.Ground.Distance, Ignore)
		if not HighestGroundRayPos or GroundRayPos.Y > HighestGroundRayPos.Y then
			HighestGroundRayHit, HighestGroundRayPos = GroundRayHit, GroundRayPos
		end
	end	
	
	local FullAreaIsEmpty = true --Ensure entire area is empty.
	for i, v in pairs(RayPoints) do
		local AreaIsEmpty = Functions.RegionEmpty((v.p - RayData.Area.Offset), {Min = Vector3.new(0, 0, 0), Max = (RayData.Area.Direction * RayData.Area.Distance)}, Ignore)
		if not AreaIsEmpty then
			FullAreaIsEmpty = false
		end
	end
	
	if not FullAreaIsEmpty or not HighestGroundRayHit then
		return
	end
	
	ToolEnabled = false
	
	local PosX, PosY, PosZ, R00, R01, R02, R10, R11, R12, R20, R21, R22 = SkateboardCFrame:components()
	SkateboardCFrame = CFrame.new(PosX, (HighestGroundRayPos.Y + (SkateboardSize.Y / 2)), PosZ, R00, R01, R02, R10, R11, R12, R20, R21, R22)
	
	InvokeClient("PlaySound", Sounds.Drop)
	
	Tool.Parent = nil
	
	SkateboardFunctions.SpawnSkateboard(Skateboard, (SkateboardCFrame * SkateboardAngle))
	Debris:AddItem(Tool, 0)	
	Tool:Destroy()
	
end
function CheckIfAlive()
	return (((Player and Player.Parent and Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent) and true) or false)
end
function Activated()
	if not ToolEquipped or not ToolEnabled or not CheckIfAlive() then
		return
	end
	DropSkateboard()
end
function Equipped()
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
	if not CheckIfAlive() then
		return
	end
	ToolEquipped = true
end
function Unequipped()
	ToolEquipped = false
end
Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "SpeedBoostScript" then
		source = [[--Made by Stickmasterluke
sp = script.Parent
speedboost = 1		--100% speed bonus
speedforsmoke = 10	--smoke apears when character running >= 10 studs/second.
local tooltag = script:WaitForChild("ToolTag",2)
if tooltag~=nil then
	local tool=tooltag.Value
	local h=sp:FindFirstChild("Humanoid")
	if h~=nil then
		h.WalkSpeed=16+16*speedboost
		local hrp = sp:FindFirstChild("HumanoidRootPart")
		if hrp ~= nil then
			smokepart=Instance.new("Part")
			smokepart.FormFactor="Custom"
			smokepart.Size=Vector3.new(0,0,0)
			smokepart.TopSurface="Smooth"
			smokepart.BottomSurface="Smooth"
			smokepart.CanCollide=false
			smokepart.Transparency=1
			local weld=Instance.new("Weld")
			weld.Name="SmokePartWeld"
			weld.Part0 = hrp
			weld.Part1=smokepart
			weld.C0=CFrame.new(0,-3.5,0)*CFrame.Angles(math.pi/4,0,0)
			weld.Parent=smokepart
			smokepart.Parent=sp
			smoke=Instance.new("Smoke")
			smoke.Enabled = hrp.Velocity.magnitude>speedforsmoke
			smoke.RiseVelocity=2
			smoke.Opacity=.25
			smoke.Size=.5
			smoke.Parent=smokepart
			h.Running:connect(function(speed)
				if smoke and smoke~=nil then
					smoke.Enabled=speed>speedforsmoke
				end
			end)
		end
	end
	while tool~=nil and tool.Parent==sp and h~=nil do
		sp.ChildRemoved:wait()
	end
	local h=sp:FindFirstChild("Humanoid")
	if h~=nil then
		h.WalkSpeed=16
	end
end
if smokepart~=nil then
	smokepart:Destroy()
end
script:Destroy()]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("SpeedBoostScript") then
		source = [[--Made by Stickmasterluke
sp = script.Parent
local speedboostscript = sp:WaitForChild("SpeedBoostScript")
function Equipped()
	if sp.Parent:FindFirstChild("SpeedBoostScript") == nil then
		local s = speedboostscript:clone()
		local tooltag = Instance.new("ObjectValue")
		tooltag.Name = "ToolTag"
		tooltag.Value = sp
		tooltag.Parent = s
		s.Parent = sp.Parent
		s.Disabled = false
		local sound = sp.Handle:FindFirstChild("CoilSound")
		if sound ~= nil then
			sound:Play()
		end
	end
end
sp.Equipped:connect(Equipped)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("ClientInput") then
		source = [[--Rescripted by TakeoHonorable
local Tool = script.Parent
local Rate=1/30
local Debris = (game:FindService("Debris") or game:GetService("Debris"))
local equipped=false
local check=true
local Cooldown=12
local Range=100
Tool.Grip = CFrame.new(0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1)
local Handle = Tool:WaitForChild("Handle")
local Mesh = Handle:WaitForChild("Mesh")
local Remote = Tool:WaitForChild("ClientInput")
Remote.OnServerEvent:Connect(function(Player,MouseLoc)
	if not check then return end
	if not Player or not Player.Character then return end
	local PlayerHumanoid = Player.Character:FindFirstChildOfClass("Humanoid")
	if not PlayerHumanoid or PlayerHumanoid.Health == 0 then return end
	local Center = Player.Character:FindFirstChild("HumanoidRootPart")
	check = false
	Handle.Transparency = 1
	
	if (Center.Position-MouseLoc).magnitude>Range then
		MouseLoc = Center.Position+(((MouseLoc-Center.Position).unit)*Range)
	end
	
	local cloud = Handle:Clone()
	cloud.Size = Vector3.new(6,2,8)
	cloud.CFrame = Handle.CFrame
	cloud.Name = "EffectCloud"
	cloud.Transparency = 0
	cloud.CanCollide = false
	cloud.Anchored = false
	Debris:AddItem(cloud,30)
	
	local bp = Instance.new("BodyPosition")
	bp.D = 2000
	bp.P = 10000
	bp.MaxForce = Vector3.new(1,1,1)*math.huge--(10^5)
	bp.Position= MouseLoc + Vector3.new(0,20,0)
	bp.Parent = cloud
	cloud.CloudScript.Disabled = false
	
	local smoke = cloud:FindFirstChild("Smoke")
	if smoke then
		smoke.Enabled = true
	end
	cloud.Parent = workspace
	cloud:SetNetworkOwner(Player)
	wait(Cooldown)
	Handle.Transparency=0
	check=true
end)]]
	elseif v.Name == "CloudScript" then
		source = [[--Made by Stickmasterluke
sp=script.Parent
rate=1/30
local debris=game:GetService("Debris")
local mesh=sp:WaitForChild("Mesh")
function checkintangible(hit)
	if hit then
		if hit:IsDescendantOf(sp) or hit.Transparency>.8 or hit.Name=="Handle" or string.lower(string.sub(hit.Name,1,6))=="effect" or hit.Name=="Bullet" or hit.Name=="Laser" or string.lower(hit.Name)=="water" or hit.Name=="Rail" or hit.Name=="Arrow" then
			return true
		end
	end
	return false
end
function castray(startpos,vec,length,ignore)
	local hit,endpos2=game.Workspace:FindPartOnRay(Ray.new(startpos,vec*length),ignore)
	if hit~=nil then
		if checkintangible(hit) then
			hit,endpos2=castray(endpos2+(vec*.01),vec,length-((startpos-endpos2).magnitude),ignore)
		end
	end
	return hit,endpos2
end
frames=math.floor(3/rate)
for frame=1,frames do
	wait(rate)
	local percent=frame/frames
	mesh.Scale=Vector3.new(3,3,3)+(Vector3.new(1,1,1)*8*percent)
end
	
function grow(part,pos)
	if part and pos then
		local toobjectspace=part.CFrame:toObjectSpace(CFrame.new(pos+Vector3.new(0,-1,0))*CFrame.Angles(0,math.random()*math.pi*2,0))
		wait(5)
		spawn(function()
			if part and toobjectspace then
				local growrate=.1
				local growheight=.5+math.random()
				local p=Instance.new("Part")
				p.Name="EffectFrondescence"
				p.BrickColor=BrickColor.new("Bright green")
				p.Anchored=false
				p.CanCollide=false
				p.TopSurface="Smooth"
				p.BottomSurface="Smooth"
				p.FormFactor="Custom"
				p.Size=Vector3.new(.2,.2,.2)
				local m=Instance.new("SpecialMesh")
				if math.random()<=.5 then
					m.Scale=Vector3.new(1,3,1)
					m.MeshId="http://www.roblox.com/asset/?id=12212520"
					m.TextureId="http://www.roblox.com/asset/?id=12212536"
					m.VertexColor=Vector3.new(math.random(1,3)*.1,7.8,math.random(1,3)*.1)
				else
					growheight=1+(math.random()*.5)
					if math.random()<=.618 then
						m.MeshId="http://www.roblox.com/asset/?id=111797211"
						local rc=math.random(1,3)
						if rc==1 then
							m.VertexColor=Vector3.new(1,1,1)
						elseif rc==2 then
							m.VertexColor=Vector3.new(1,1,0)
						elseif rc==3 then
							m.VertexColor=Vector3.new(0,1,1)
						end
					else
						m.MeshId="http://www.roblox.com/asset/?id=111796999"
					end
					m.Scale=Vector3.new(.5,.5,.5)
					m.TextureId="http://www.roblox.com/asset/?id=111796880"
				end
				m.Parent=p
				local w=Instance.new("Motor")
				w.Part0=part
				w.Part1=p
				w.C0=toobjectspace
				w.Parent=p
				debris:AddItem(w,15+(math.random()*10))
				debris:AddItem(p,30)
				p.Parent=workspace
				local growframes=math.ceil(5/growrate)
				for i=1,growframes do
					if w then
						wait(growrate)
						w.C1=CFrame.new(0,-(i/growframes)*growheight,0)
					end
				end
			end
		end)
	end
end
function raincast(fallrate)
	local size=sp.Size
	local rainstart=(sp.CFrame*CFrame.new(size*(-.5))*CFrame.new(size.x*math.random(),0,size.z*math.random())).p
	local vec=Vector3.new(-1,-10,.5).unit
	local hit,hitpos=castray(rainstart,vec,50,sp)
	local hitpos=hitpos or vec*50
	local dist=(rainstart-hitpos).magnitude
	
	local p=Instance.new("Part")
	p.Name="EffectRain"
	p.BrickColor=(math.random(1,2)==1 and BrickColor.new("Bright blue")) or BrickColor.new("Deep blue")
	p.Anchored=true
	p.CanCollide=false
	p.FormFactor="Custom"
	p.TopSurface="Smooth"
	p.BottomSurface="Smooth"
	p.Transparency=.5
	local fallframes=math.ceil(dist/fallrate)
	p.Size=Vector3.new(.2,.2,(dist/fallframes)*1.618)
	debris:AddItem(p,3)
	spawn(function()
		if hit and math.random()<=.25 then
			grow(hit,hitpos)
		end	
	end)
	p.Parent=sp
	for i=1,fallframes do
		if p then
			p.CFrame=CFrame.new(rainstart,hitpos)*CFrame.new(0,0,-dist*((i-.5)/fallframes))
			wait()
		end
	end	
	if p then
		p:Destroy()
	end
end
local sound=sp:FindFirstChild("Sound")
if sound then
	sound:Play()
end
rains=90
for i=1,rains do
	wait(math.random()*.1)
	spawn(function()
		--raincast(math.random(1,4)/2+((1-(i/rains))*2))
		raincast(3+((1-(i/rains))*2))
	end)
end
if sound then
	sound:Stop()
end
wait(2)
frames=math.floor(2/rate)
for frame=1,frames do
	wait(rate)
	local percent=frame/frames
	sp.Transparency=percent
end
wait(5)
sp:Destroy()]]
	elseif v.Name == "SelfDestruct" then
		source = [[--Rescripted by Luckymaxer
Players = game:GetService("Players")
Debris = game:GetService("Debris")
Character = script.Parent
Humanoid = Character:FindFirstChild("Humanoid")
Torso = Character:FindFirstChild("Torso")
Creator = Character:FindFirstChild("Creator")
function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end
function TagHumanoid(humanoid, player)
	local CreatorTag = Instance.new("ObjectValue")
	CreatorTag.Name = "creator"
	CreatorTag.Value = player
	Debris:AddItem(CreatorTag, 2)
	CreatorTag.Parent = humanoid
end
function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end
function GetCreator()
	return (((Creator and Creator.Value and Creator.Value.Parent and Creator.Value:IsA("Player")) and Creator.Value) or nil)
end
function SelfDestruct()
	if not Humanoid or not Torso then
		return
	end
	local Explosion = Instance.new("Explosion")
	Explosion.ExplosionType = Enum.ExplosionType.NoCraters
	Explosion.BlastPressure = 15
	Explosion.BlastRadius = 15
	Explosion.DestroyJointRadiusPercent = 0
	Explosion.Position = Torso.Position
	Explosion.Hit:connect(function(Hit)
		local CreatorPlayer = GetCreator()
		local character = Hit.Parent
		if character:IsA("Hat") or character:IsA("Tool") then
			character = character.Parent
		end
		local humanoid = character:FindFirstChild("Humanoid")
		local CanBreak = false
		if humanoid then
			local player = Players:GetPlayerFromCharacter(character)
			if CreatorPlayer and (player ~= CreatorPlayer and IsTeamMate(CreatorPlayer, player)) then
				return
			end
			for i, v in pairs(character:GetChildren()) do
				if v:IsA("ForceField") then
					return
				end
			end
			UntagHumanoid(humanoid)
			TagHumanoid(humanoid, CreatorPlayer)
			CanBreak = true
		else
			CanBreak = true
		end
		Hit:BreakJoints()
		Hit.Velocity = (CFrame.new(Explosion.Position, Hit.Position).lookVector * Explosion.BlastPressure)
	end)
	Explosion.Parent = game:GetService("Workspace")
	Debris:AddItem(Character, 3)
end
if Humanoid then
	Humanoid.Died:connect(SelfDestruct)
end]]
	elseif v:FindFirstChild("SelfDestruct") then
		source = [[--Rescripted by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
NPCModule = require(191816425)
SelfDestruct = script:WaitForChild("SelfDestruct")
Animations = {
	Drink = {Animation = Tool:WaitForChild("Drink"), FadeTime = nil, Weight = nil, Speed = nil},
}
Sounds = {
	Drink = Handle:WaitForChild("Drink"),
}
ReloadTime = 30
ToolEquipped = false
ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool
ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool
Handle.Transparency = 0
Tool.Enabled = true
function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent and Player and Player.Parent) and true) or false)
end
function Equipped()
	Character = Tool.Parent
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso")
	Player = Players:GetPlayerFromCharacter(Character)
	if not CheckIfAlive() then
		return
	end
	local Data = NPCModule.GetTable({Key = "MakeNPC", Player = Player})
	if not Data then
		return
	end
	NPCData = Data.GetData({Player = Player, Tool = Tool})
	ToolEquipped = true
end
function Unequipped()
	ToolEquipped = false
end
function CreateDecoy()
	if not ToolEquipped or not CheckIfAlive() then
		return
	end
	local CurrentlyEquipped = true
	if ToolUnequipped then
		ToolUnequipped:disconnect()
	end
	ToolUnequipped = Tool.Unequipped:connect(function()
		CurrentlyEquipped = false
	end)
	Spawn(function()
		InvokeClient("PlayAnimation", Animations.Drink)
	end)
	wait(0.75)
	if ToolUnequipped then
		ToolUnequipped:disconnect()
	end
	if not ToolEquipped or not CurrentlyEquipped or not CheckIfAlive() then
		return
	end
	local Decoy = NPCData.MakeNPC({Appearance = Character})
	local DecoyTorso = Decoy:FindFirstChild("Torso")
	Decoy.Name = Player.Name
	local Creator = Instance.new("ObjectValue")
	Creator.Name = "Creator"
	Creator.Value = Player
	Creator.Parent = Decoy
	local SelfDestructCopy = SelfDestruct:Clone()
	SelfDestructCopy.Disabled = false
	SelfDestructCopy.Parent = Decoy
	Debris:AddItem(Decoy, math.random(60, 90))
	Decoy.Parent = game:GetService("Workspace")
	if DecoyTorso then
		DecoyTorso.CFrame = (Torso.CFrame + Torso.CFrame.lookVector * 10)
	end
end
function Activated()
	if not ToolEquipped or not CheckIfAlive() or not Tool.Enabled then
		return
	end
	Tool.Enabled = false
	Sounds.Drink:Play()
	CreateDecoy()
	wait(ReloadTime)
	Tool.Enabled = true
end
function OnServerInvoke(player, mode, value)
	if player ~= Player or not ToolEquipped or not value or not CheckIfAlive() then
		return
	end
end
function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end
ServerControl.OnServerInvoke = OnServerInvoke
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)
Tool.Activated:connect(Activated)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("PlantAnim") then
		source = [[--Rescripted by Luckymaxer
--[[alexnewtron 2014]
		Tool = script.Parent
		Handle = Tool:WaitForChild("Handle")
		Mesh = Handle:WaitForChild("Mesh")
		Players = game:GetService("Players")
		Debris = game:GetService("Debris")
		Tween = script:WaitForChild("Tween")
		Tween = require(Tween)
		Easing = script:WaitForChild("Easing")
		Easing = require(Easing)
		Animations = {
			PlantAnim = {Animation = Tool:WaitForChild("PlantAnim"), FadeTime = nil, Weight = nil, Speed = 0.5, Duration = nil}
		}
		Sounds = {
			PlaceUmbrella = Handle:WaitForChild("PlaceUmbrella")
		}
		ReloadTime = 25
		StandTime = (60 * 2)
		ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
		ClientControl.Name = "ClientControl"
		ClientControl.Parent = Tool
		ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
		ServerControl.Name = "ServerControl"
		ServerControl.Parent = Tool
		Handle.Transparency = 0
		Tool.Enabled = true
		function InvokeClient(Mode, Value)
			local ClientReturn = nil
			pcall(function()
				ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
			end)
			return ClientReturn
		end
		function CheckIntangible(hit)
			if hit and hit~=nil then
				if hit:IsDescendantOf(Character) or hit.Transparency>.8 or hit.Name=="Handle" or string.lower(string.sub(hit.Name,1,6))=="effect" or hit.Name=="Bullet" or hit.Name=="Laser" or string.lower(hit.Name)=="water" or hit.Name=="Rail" or hit.Name=="Arrow" then
					return true
				end
			end
			return false
		end
		function CastRay(startpos,vec,length,ignore)
			local hit,endpos2=game.Workspace:FindPartOnRayWithIgnoreList(Ray.new(startpos,vec*length),ignore)
			if hit~=nil then
				if CheckIntangible(hit) then
					hit,endpos2=CastRay(endpos2+(vec*.01),vec,length-((startpos-endpos2).magnitude),ignore)
				end
			end
			return hit,endpos2
		end
		function Activated()
			if not CheckIfAlive() or not Tool.Enabled then
				return
			end
			Tool.Enabled = false
			local CurrentlyEquipped = true
			if ToolUnequipped then
				ToolUnequipped:disconnect()
			end
			ToolUnequipped = Tool.Unequipped:connect(function()
				CurrentlyEquipped = false
			end)
			local MousePosition = InvokeClient("MousePosition")
			local IgnoreTable = {}
			for i, v in pairs(Players:GetChildren()) do
				if v:IsA("Player") and v.Character then
					table.insert(IgnoreTable, v.Character)
				end
			end
			local RayHit, RayPos = CastRay(Torso.Position, (Vector3.new(0, -0.5, 0) + (MousePosition - Torso.Position).unit).unit, 15, IgnoreTable)
			if RayHit then
				InvokeClient("PlayAnimation", Animations.PlantAnim)
				local Umbrella = Handle:clone()
				Umbrella.Name = "Beach Umbrella"
				Umbrella.Transparency = 1
				Umbrella.Size = Vector3.new(1, 10, 1)
				Umbrella.CanCollide = true
				Umbrella.Velocity = Vector3.new(0,0,0)
				Umbrella.RotVelocity = Vector3.new(0,0,0)
				Umbrella:WaitForChild("Mesh").Scale = Vector3.new(3, 4, 3)
				Umbrella.CFrame = CFrame.new(RayPos + Vector3.new(0, 5, 0)) * CFrame.Angles(0, (math.pi * 2 * math.random()), 0)
				local w = Instance.new("Weld")
				w.Part0 = RayHit
				w.Part1 = Umbrella
				w.C1 = Umbrella.CFrame:toObjectSpace(RayHit.CFrame)
				w.Parent = Umbrella

				local CreatorTag = Instance.new("ObjectValue")
				CreatorTag.Value = Player
				CreatorTag.Name = "creator"
				CreatorTag.Parent = Umbrella

				Debris:AddItem(Umbrella, StandTime)
				Umbrella.Parent = game:GetService("Workspace")
				Delay(1, function()
					if not CurrentlyEquipped then
						return
					end
					if Handle then
						Handle.Transparency = 1
					end
					if Umbrella then
						Umbrella.Transparency = 0
						Delay(3, function()
							if not CurrentlyEquipped then
								return
							end
							if Umbrella then
								Sounds.PlaceUmbrella:Play()
								local lounge = Instance.new("Seat")
								lounge.Friction = 1
								lounge.Elasticity = 0
								lounge.TopSurface = Enum.SurfaceType.Smooth
								lounge.BottomSurface = Enum.SurfaceType.Smooth
								lounge.FormFactor = Enum.FormFactor.Custom
								local m = Instance.new("SpecialMesh")
								m.MeshId = "http://www.roblox.com/asset/?id=162383507"
								m.TextureId = "http://www.roblox.com/asset/?id=162383599"
								m.Scale = Vector3.new(1.6,0.05,1.6)
								m.Parent = lounge
								lounge.Size = Vector3.new(3, 1, 5)
								lounge.CFrame = Umbrella.CFrame * CFrame.new(3, -2, 3) * CFrame.Angles(0, 0.4, 0)
								local bg = Instance.new("BodyGyro")
								Debris:AddItem(bg, 3)
								bg.Parent = lounge
								Debris:AddItem(lounge, StandTime)
								lounge.Parent = game:GetService("Workspace")
								local a=Tween("forward")a.add(1,{x=0.05},Easing.inOutQuad)a.add(1,{x=1.6},Easing.inOutBack)for x=1,200 do local b=a.getCurrentProperties()m.Scale=Vector3.new(1.6,b.x,1.6)a.update(0.025)wait(0.025)if b.x>=1.6 then break end end
								local c = Instance.new("Part")
								c.TopSurface=Enum.SurfaceType.Smooth
								c.BottomSurface=Enum.SurfaceType.Smooth
								c.FormFactor=Enum.FormFactor.Custom
								c.CanCollide = false
								c.Size = Vector3.new(4.25,1.59,7.72)
								c.Anchored = true							
								local cm = Instance.new("SpecialMesh")
								cm.MeshId = "http://www.roblox.com/asset/?id=162383569"
								cm.TextureId = "http://www.roblox.com/asset/?id=162383633"
								cm.Scale = Vector3.new(1, 0.05, 1)
								cm.Parent = c
								c.CFrame = Umbrella.CFrame * CFrame.new(-4, -4.1, 4) * CFrame.Angles(0, -0.4, 0)
								Debris:AddItem(c, StandTime)
								c.Parent=game:GetService("Workspace")
								local a=Tween("forward")a.add(1,{x=0.05},Easing.inOutQuad)a.add(1,{x=1},Easing.inOutBack)for x=1,200 do local b=a.getCurrentProperties()cm.Scale=Vector3.new(1,b.x,1)a.update(0.025)wait(0.025)if b.x>=1 then break end end
							end
						end)
					end
				end)
			end
			wait(ReloadTime)
			Handle.Transparency = 0
			Tool.Enabled = true
		end
		function CheckIfAlive()
			return (Player and Player.Parent and Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent)
		end
		function Equipped()
			Character = Tool.Parent
			Player = Players:GetPlayerFromCharacter(Character)
			Humanoid = Character:FindFirstChild("Humanoid")
			Torso = Character:FindFirstChild("Torso")
			if not CheckIfAlive() then
				return
			end
			if ToolUnequipped then
				ToolUnequipped:disconnect()
			end
		end
		function Unequipped()
			for i, v in pairs(Animations) do
				InvokeClient("StopAnimation", v)
			end
			if ToolUnequipped then
				ToolUnequipped:disconnect()
			end
			Handle.Transparency = 0
		end
		Tool.Activated:connect(Activated)
		Tool.Equipped:connect(Equipped)
		Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("Handle"):FindFirstChild("RopeAttachment") then
		source = [[--Rescripted by Luckymaxer
--Updated for R15 avatars by StarWars
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Mesh = Handle:WaitForChild("Mesh")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
RbxUtility = LoadLibrary("RbxUtility")
Create = RbxUtility.Create
BaseUrl = "http://www.roblox.com/asset/?id="
Meshes = {
	GrappleWithHook = 33393806,
	Grapple = 30308256,
	Hook = 30307623,
}
Animations = {
	Crouch = {Animation = Tool:WaitForChild("Crouch"), FadeTime = 0.25, Weight = nil, Speed = nil},
	R15Crouch = {Animation = Tool:WaitForChild("R15Crouch"), FadeTime = 0.25, Weight = nil, Speed = nil}
}
Sounds = {
	Fire = Handle:WaitForChild("Fire"),
	Connect = Handle:WaitForChild("Connect"),
	Hit = Handle:WaitForChild("Hit"),
}
for i, v in pairs(Meshes) do
	Meshes[i] = (BaseUrl .. v)
end
local BaseRopeConstraint = Instance.new("RopeConstraint")
BaseRopeConstraint.Thickness = 0.2
BaseRopeConstraint.Restitution = 1
BaseRopeConstraint.Color = BrickColor.new("Really black")
BasePart = Create("Part"){
	Material = Enum.Material.Plastic,
	Shape = Enum.PartType.Block,
	TopSurface = Enum.SurfaceType.Smooth,
	BottomSurface = Enum.SurfaceType.Smooth,
	Size = Vector3.new(0.2, 0.2, 0.2),
	CanCollide = true,
	Locked = true,
}
BaseRope = BasePart:Clone()
BaseRope.Name = "Effect"
BaseRope.BrickColor = BrickColor.new("Really black")
BaseRope.Anchored = true
BaseRope.CanCollide = false
Create("CylinderMesh"){
	Scale = Vector3.new(1, 1, 1),
	Parent = BaseRope,
}
BaseGrappleHook = BasePart:Clone()
BaseGrappleHook.Name = "Projectile"
BaseGrappleHook.Transparency = 0
BaseGrappleHook.Size = Vector3.new(1, 0.4, 1)
BaseGrappleHook.Anchored = false
BaseGrappleHook.CanCollide = true
Create("SpecialMesh"){
	MeshType = Enum.MeshType.FileMesh,
	MeshId = (BaseUrl .. "30307623"),
	TextureId = (BaseUrl .. "30307531"),
	Scale = Mesh.Scale,
	VertexColor = Vector3.new(1, 1, 1),
	Offset = Vector3.new(0, 0, 0),
	Parent = BaseGrappleHook,
}
local RopeAttachment = Instance.new("Attachment")
RopeAttachment.Name = "RopeAttachment"
RopeAttachment.Parent = BaseGrappleHook
Create("BodyGyro"){
	Parent = BaseGrappleHook,
}
for i, v in pairs({Sounds.Connect, Sounds.Hit}) do
	local Sound = v:Clone()
	Sound.Parent = BaseGrappleHook
end
Rate = (1 / 60)
MaxDistance = 200
CanFireWhileGrappling = true
Crouching = false
ToolEquipped = false
ServerControl = (Tool:FindFirstChild("ServerControl") or Create("RemoteFunction"){
	Name = "ServerControl",
	Parent = Tool,
})
ClientControl = (Tool:FindFirstChild("ClientControl") or Create("RemoteFunction"){
	Name = "ClientControl",
	Parent = Tool,
})
for i, v in pairs(Tool:GetChildren()) do
	if v:IsA("BasePart") and v ~= Handle then
		v:Destroy()
	end
end
Mesh.MeshId = Meshes.GrappleWithHook
Handle.Transparency = 0
Tool.Enabled = true
function CheckTableForString(Table, String)
	for i, v in pairs(Table) do
		if string.find(string.lower(String), string.lower(v)) then
			return true
		end
	end
	return false
end
function CheckIntangible(Hit)
	local ProjectileNames = {"Water", "Arrow", "Projectile", "Effect", "Rail", "Laser", "Bullet", "GrappleHook"}
	if Hit and Hit.Parent then
		if ((not Hit.CanCollide or CheckTableForString(ProjectileNames, Hit.Name)) and not Hit.Parent:FindFirstChild("Humanoid")) then
			return true
		end
	end
	return false
end
function CastRay(StartPos, Vec, Length, Ignore, DelayIfHit)
	local Ignore = ((type(Ignore) == "table" and Ignore) or {Ignore})
	local RayHit, RayPos, RayNormal = game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, Vec * Length), Ignore)
	if RayHit and CheckIntangible(RayHit) then
		if DelayIfHit then
			wait()
		end
		RayHit, RayPos, RayNormal = CastRay((RayPos + (Vec * 0.01)), Vec, (Length - ((StartPos - RayPos).magnitude)), Ignore, DelayIfHit)
	end
	return RayHit, RayPos, RayNormal
end
function AdjustRope()
	if not Rope or not Rope.Parent or not CheckIfGrappleHookAlive() then
		return
	end
	local StartPosition = Handle.RopeAttachment.WorldPosition
	local EndPosition = GrappleHook.RopeAttachment.WorldPosition
	local RopeLength = (StartPosition - EndPosition).Magnitude
	
	Rope.Size = Vector3.new(1, 1, 1)
	Rope.Mesh.Scale = Vector3.new(0.1, RopeLength, 0.1)
	Rope.CFrame = (CFrame.new(((StartPosition + EndPosition) / 2), EndPosition) * CFrame.Angles(-(math.pi / 2), 0, 0))
end
function DisconnectGrappleHook(KeepBodyObjects)
	for i, v in pairs({Rope, GrappleHook, GrappleHookChanged}) do
		if v then
			if tostring(v) == "Connection" then
				v:disconnect()
			elseif type(v) == "userdata" and v.Parent then
				v:Destroy()
			end
		end
	end
	if CheckIfAlive() and not KeepBodyObjects then
		for i, v in pairs(Torso:GetChildren()) do
			if string.find(string.lower(v.ClassName), string.lower("Body")) then
				v:Destroy()
			end
		end	
	end
	Connected = false
	Mesh.MeshId = Meshes.GrappleWithHook
end
function TryToConnect()
	if not ToolEquipped or not CheckIfAlive() or not CheckIfGrappleHookAlive() or Connected then
		DisconnectGrappleHook()
		return
	end
	local DistanceApart = (Torso.Position - GrappleHook.Position).Magnitude
	if DistanceApart > MaxDistance then
		DisconnectGrappleHook()
		return
	end
	local Directions = {Vector3.new(0, 1, 0), Vector3.new(0, -1, 0), Vector3.new(1, 0, 0), Vector3.new(-1, 0, 0), Vector3.new(0, 0, 1), Vector3.new(0, 0, -1)}
	local ClosestRay = {DistanceApart = math.huge}
	for i, v in pairs(Directions) do
		local Direction = CFrame.new(GrappleHook.Position, (GrappleHook.CFrame + v * 2).p).lookVector
		local RayHit, RayPos, RayNormal = CastRay((GrappleHook.Position + Vector3.new(0, 0, 0)), Direction, 2, {Character, GrappleHook, Rope}, false)
		if RayHit then
			local DistanceApart = (GrappleHook.Position - RayPos).Magnitude
			if DistanceApart < ClosestRay.DistanceApart then
				ClosestRay = {Hit = RayHit, Pos = RayPos, Normal = RayNormal, DistanceApart = DistanceApart}
			end
		end
	end
	if ClosestRay.Hit then
		Connected = true
		local GrappleCFrame = CFrame.new(ClosestRay.Pos, (CFrame.new(ClosestRay.Pos) + ClosestRay.Normal * 2).p) * CFrame.Angles((math.pi / 2), 0, 0)
		GrappleCFrame = (GrappleCFrame * CFrame.new(0, -(GrappleHook.Size.Y / 1.5), 0))
		GrappleCFrame = (CFrame.new(GrappleCFrame.p, Handle.Position) * CFrame.Angles(0, math.pi, 0))
		local Weld = Create("Motor6D"){
			Part0 = GrappleHook,
			Part1 = ClosestRay.Hit,
			C0 = GrappleCFrame:inverse(),
			C1 = ClosestRay.Hit.CFrame:inverse(),
			Parent = GrappleHook,
		}
		for i, v in pairs(GrappleHook:GetChildren()) do
			if string.find(string.lower(v.ClassName), string.lower("Body")) then
				v:Destroy()
			end
		end	
		local HitSound = GrappleHook:FindFirstChild("Hit")
		if HitSound then
			HitSound:Play()
		end
		local BackUpGrappleHook = GrappleHook
		wait(0.4)
		if not CheckIfGrappleHookAlive() or GrappleHook ~= BackUpGrappleHook then
			return
		end
		Sounds.Connect:Play()
		local ConnectSound = GrappleHook:FindFirstChild("Connect")
		if ConnectSound then
			ConnectSound:Play()
		end
		
		for i, v in pairs(Torso:GetChildren()) do
			if string.find(string.lower(v.ClassName), string.lower("Body")) then
				v:Destroy()
			end
		end	
		
		local TargetPosition = GrappleHook.Position
		local BackUpPosition = TargetPosition
		
		local BodyPos = Create("BodyPosition"){
			D = 1000,
			P = 3000,
			maxForce = Vector3.new(1000000, 1000000, 1000000),
			position = TargetPosition,
			Parent = Torso,
		}
		
		local BodyGyro = Create("BodyGyro"){
			maxTorque = Vector3.new(100000, 100000, 100000),
			cframe = CFrame.new(Torso.Position, Vector3.new(GrappleCFrame.p.X, Torso.Position.Y, GrappleCFrame.p.Z)),
			Parent = Torso,
		}
	
		Spawn(function()
			while TargetPosition == BackUpPosition and CheckIfGrappleHookAlive() and Connected and ToolEquipped and CheckIfAlive() do
				BodyPos.position = GrappleHook.Position
				wait()
			end
		end)
		
	end
end
function CheckIfGrappleHookAlive()
	return (((GrappleHook and GrappleHook.Parent --[[and Rope and Rope.Parent]) and true) or false)
		end
		function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent and Player and Player.Parent) and true) or false)
end
function Activated()
	if not Tool.Enabled or not ToolEquipped or not CheckIfAlive() then
		return
	end
	local MousePosition = InvokeClient("MousePosition")
	if not MousePosition then
		return
	end
	MousePosition = MousePosition.Position
	if CheckIfGrappleHookAlive() then
		if not CanFireWhileGrappling then
			return
		end
		if GrappleHookChanged then
			GrappleHookChanged:disconnect()
		end
		DisconnectGrappleHook(true)
	end
	if GrappleHookChanged then
		GrappleHookChanged:disconnect()
	end
	Tool.Enabled = false
	Sounds.Fire:Play()
	Mesh.MeshId = Meshes.Grapple
	GrappleHook = BaseGrappleHook:Clone()
	GrappleHook.CFrame = (CFrame.new((Handle.Position + (MousePosition - Handle.Position).Unit * 5), MousePosition) * CFrame.Angles(0, 0, 0))
	local Weight = 70
	GrappleHook.Velocity = (GrappleHook.CFrame.lookVector * Weight)
	local Force = Create("BodyForce"){
		force = Vector3.new(0, workspace.Gravity * 0.98 * GrappleHook:GetMass(), 0),
		Parent = GrappleHook,
	}
	GrappleHook.Parent = Tool
	GrappleHookChanged = GrappleHook.Changed:connect(function(Property)
		if Property == "Parent" then
			DisconnectGrappleHook()
		end
	end)
	Rope = BaseRope:Clone()
	Rope.Parent = Tool
	Spawn(function()
		while CheckIfGrappleHookAlive() and ToolEquipped and CheckIfAlive() do
			AdjustRope()
			Spawn(function()
				if not Connected then
					TryToConnect()
				end
			end)
			wait()
		end
	end)
	wait(2)
	Tool.Enabled = true
end
function Equipped(Mouse)
	Character = Tool.Parent
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
	Player = Players:GetPlayerFromCharacter(Character)
	if not CheckIfAlive() then
		return
	end
	Spawn(function()
		DisconnectGrappleHook()
		if HumanoidJumping then
			HumanoidJumping:disconnect()
		end
		HumanoidJumping = Humanoid.Jumping:connect(function()
			DisconnectGrappleHook()
		end)
	end)
	Crouching = false
	ToolEquipped = true
end
function Unequipped()
	if HumanoidJumping then
		HumanoidJumping:disconnect()
	end
	DisconnectGrappleHook()
	Crouching = false
	ToolEquipped = false
end
function OnServerInvoke(player, mode, value)
	if player ~= Player or not ToolEquipped or not value or not CheckIfAlive() then
		return
	end
	if mode == "KeyPress" then
		local Key = value.Key
		local Down = value.Down
		if Key == "q" and Down then
			DisconnectGrappleHook()
		elseif Key == "c" and Down then
			Crouching = not Crouching
			Spawn(function()
				local Animation = Animations.Crouch
				if Humanoid and Humanoid.RigType == Enum.HumanoidRigType.R15 then
					Animation = Animations.R15Crouch
				end 
				InvokeClient(((Crouching and "PlayAnimation") or "StopAnimation"), Animation)
			end)
		end
	end
end
function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end
ServerControl.OnServerInvoke = OnServerInvoke
Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("ArmMesh") then
		source = [[local Tool = script.Parent
local Remote = Tool:WaitForChild("Remote")
local Handle = Tool:WaitForChild("Handle")
local FriendlyFire = false
local ArmMesh
local HitAble = false
local HitWindup = 0.15
local HitWindow = 0.75
local HitDamage = 15
local HitVictims = {}
local SwingAble = true
local SwingRestTime = 1
--returns the wielding player of this tool
function getPlayer()
	local char = Tool.Parent
	return game:GetService("Players"):GetPlayerFromCharacter(char)
end
--helpfully checks a table for a specific value
function contains(t, v)
	for _, val in pairs(t) do
		if val == v then
			return true
		end
	end
	return false
end
--tags a human for the ROBLOX KO system
function tagHuman(human)
	local tag = Instance.new("ObjectValue")
	tag.Value = getPlayer()
	tag.Name = "creator"
	tag.Parent = human
	game:GetService("Debris"):AddItem(tag)
end
--used by checkTeams
function sameTeam(otherHuman)
	local player = getPlayer()
	local otherPlayer = game:GetService("Players"):GetPlayerFromCharacter(otherHuman.Parent)
	if player and otherPlayer then
		if player == otherPlayer then
			return true
		end
		if otherPlayer.Neutral then
			return false
		end
		return player.TeamColor == otherPlayer.TeamColor
	end
	return false
end
--use this to determine if you want this human to be harmed or not, returns boolean
function checkTeams(otherHuman)
	return not (sameTeam(otherHuman) and not FriendlyFire)
end
function onTouched(part)
	if part:IsDescendantOf(Tool.Parent) then return end
	if not HitAble then return end
	
	if part.Parent and part.Parent:FindFirstChild("Humanoid") then
		local human = part.Parent.Humanoid
		
		if contains(HitVictims, human) then return end
		
		local root = part.Parent:FindFirstChild("HumanoidRootPart")
		if root and not root.Anchored then
			local myRoot = Tool.Parent:FindFirstChild("HumanoidRootPart")
			if myRoot and checkTeams(human) then
				local delta = root.Position - myRoot.Position
				
				human.Sit = true
				tagHuman(human)
				human:TakeDamage(HitDamage)
				table.insert(HitVictims, human)
				
				local bv = Instance.new("BodyVelocity")
				bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
				bv.velocity = delta.unit * 128
				bv.Parent = root
				game:GetService("Debris"):AddItem(bv, 0.05)
				
				Handle.Smack.Pitch = math.random(90, 110)/100
				Handle.Smack.TimePosition = 0.15
				Handle.Smack:Play()
			end
		end
	end
end
function onEquip()
	--put in our right arm
	local char = Tool.Parent
	local arm = Tool.ArmMesh:Clone()
	arm.Parent = char:FindFirstChild("Right Arm")
	ArmMesh = arm
end
function onUnequip()
	if ArmMesh then
		ArmMesh:Destroy()
		ArmMesh = nil
	end
end
function onLeftDown()
	if not SwingAble then return end
	
	SwingAble = false
	delay(SwingRestTime, function()
		SwingAble = true
	end)
	
	delay(HitWindup, function()
		HitAble = true
		delay(HitWindow, function()
			HitAble = false
		end)
	end)
	
	HitVictims = {}
	
	Remote:FireClient(getPlayer(), "PlayAnimation", "Swing")
	
	wait(0.25)
	Handle.Boom.Pitch = math.random(80, 100)/100
	Handle.Boom:Play()
end
function onRemote(player, func, ...)
	if player ~= getPlayer() then return end
	
	if func == "LeftDown" then
		onLeftDown(...)
	end
end
Tool.Equipped:connect(onEquip)
Tool.Unequipped:connect(onUnequip)
Handle.Touched:connect(onTouched)
Remote.OnServerEvent:connect(onRemote)]]
	elseif v.Name == "BalloonScript" then
		source = [[local Tool = script.Parent
local upAndAway = false
local humanoid = nil
local head = nil
local upAndAwayForce = Instance.new("BodyForce")
local equalizingForce = 236 / 1.2 -- amount of force required to levitate a mass
local gravity = 1.05 -- things float at > 1
local height = nil
local maxRise =  150
function onTouched(part)
	local h = part.Parent:FindFirstChild("Humanoid")
	if h ~= nil then
		upAndAway = true
		Tool.Handle.Anchored = false
	end
end
function onEquipped()
	Tool.Handle.Mesh.MeshId = "http://www.roblox.com/asset/?id=146063878"
	Tool.Handle.Mesh.TextureId="http://www.roblox.com/asset/?id=146063910"
	upAndAway = true
	upAndAwayForce.Parent = Tool.Handle
	Tool.GripPos = Vector3.new(0,-1,0)
	Tool.GripForward = Vector3.new(0,1,0)
	Tool.GripRight = Vector3.new(0,0,-1)
	Tool.GripUp = Vector3.new(1,0,0)
	height = Tool.Parent.Torso.Position.y
	local lift = recursiveGetLift(Tool.Parent)
	float(lift)
end
function onUnequipped()
	upAndAway = false
	Tool.GripForward = Vector3.new(1,0,0)
	Tool.GripRight = Vector3.new(0,0,1)
	Tool.GripUp = Vector3.new(0,1,0)
	Tool.Handle.Mesh.Scale = Vector3.new(2,2,2)
end
Tool.Unequipped:connect(onUnequipped)
Tool.Equipped:connect(onEquipped)
Tool.Handle.Touched:connect(onTouched)
function recursiveGetLift(node)
	local m = 0
	local c = node:GetChildren()
	if (node:FindFirstChild("Head") ~= nil) then head = node:FindFirstChild("Head") end -- nasty hack to detect when your parts get blown off
	for i=1,#c do
		if c[i].className == "Part" then	
			if (head ~= nil and (c[i].Position - head.Position).magnitude < 10) then -- GROSS
				if c[i].Name == "Handle" then
					m = m + (c[i]:GetMass() * equalizingForce * 1) -- hack that makes hats weightless, so different hats don't change your jump height
				else
					m = m + (c[i]:GetMass() * equalizingForce * gravity)
				end
			end
		end
		m = m + recursiveGetLift(c[i])
	end
	return m
end
function updateBalloonSize()
	local range = (height + maxRise) - Tool.Handle.Position.y
	print(range)
	
	if range > 100 then
		Tool.Handle.Mesh.Scale = Vector3.new(2,2,2)
	elseif range < 100 and range > 50 then
		Tool.Handle.Mesh.Scale = Vector3.new(3,3,3)
	elseif range < 50 then
		Tool.Handle.Mesh.Scale = Vector3.new(4,4,4)
	end
end
function float(lift)
	while upAndAway do
		upAndAwayForce.force = Vector3.new(0,lift * 0.98,0)
		upAndAwayForce.Parent = Tool.Handle
		wait(3)
		upAndAwayForce.force = Vector3.new(0,lift * 0.92,0)
		wait(2)
		if Tool.Handle.Position.y > height + maxRise then
			upAndAway = false
			Tool.Handle.Pop:Play()
			Tool.GripPos = Vector3.new(0,-0.4,0)
			Tool.Handle.Mesh.MeshId = "http://www.roblox.com/asset/?id=26725510"
			Tool.Handle.Mesh.TextureId=""
			Tool.Handle.Mesh.Scale=Vector3.new(2.5,2.5,2.5)
			upAndAwayForce.Parent = nil
		end
		updateBalloonSize()
	end
end]]
	elseif v.Name == "WeldArm" then
		source = [[Tool = script.Parent;
local arms = nil
local torso = nil
local welds = {}
function Equip(mouse)
wait(0.01)
arms = {Tool.Parent:FindFirstChild("Left Arm"), Tool.Parent:FindFirstChild("Right Arm")}
torso = Tool.Parent:FindFirstChild("Torso")
if arms ~= nil and torso ~= nil then
local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
if sh ~= nil then
local yes = true
if yes then
yes = false
sh[1].Part1 = nil
sh[2].Part1 = nil
local weld1 = Instance.new("Weld")
weld1.Part0 = torso
weld1.Parent = torso
weld1.Part1 = arms[1]
weld1.C1 = CFrame.new(1.5,0, 0) 
welds[1] = weld1
local weld2 = Instance.new("Weld")
weld2.Part0 = torso
weld2.Parent = torso
weld2.Part1 = arms[2]
weld2.C1 = CFrame.new(-1.5,1.5,0) * CFrame.fromEulerAnglesXYZ(math.pi, 0, 0)
welds[2] = weld2
end
else
print("sh")
end
else
print("arms")
end
end
function Unequip(mouse)
if arms ~= nil and torso ~= nil then
local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
if sh ~= nil then
local yes = true
if yes then
yes = false
sh[1].Part1 = arms[1]
sh[2].Part1 = arms[2]
welds[1].Parent = nil
welds[2].Parent = nil
end
else
print("sh")
end
else
print("arms")
end
end
Tool.Equipped:connect(Equip)
Tool.Unequipped:connect(Unequip)]]
	elseif v.Parent.Name == "PaintBucket" then
		source = [[-- // Recreated by StarWars
local Tool = script.Parent
local GearService = require(1075123174)
local Gear = GearService:BindGear(Tool)
Gear:SetupRemoteFunctions()
local Remotes = Tool:WaitForChild("Remotes")
local ClientControls = Remotes:WaitForChild("ClientControls") 
local ServerControls = Remotes:WaitForChild("ServerControls")
ServerControls.OnServerInvoke = function(player, mode, value)
	if player ~= Gear.Player then return end 
	if not mode then return end
	
	if mode == "PaintPart" and value then
		if value.Part and value.Color then
			value.Part.Color = value.Color
		end
	end
end]]
	elseif v.Name == "PinataScript" then
		source = [[local pinata = script.Parent
local theWholeThing = pinata.Parent
local health = 100
local gears = {29100543, 10472779, 34399428, 20056642, 25695001, 16214845, 20056642, 12848902} --Fix implemented by Luckymaxer
local debris = game:GetService("Debris")
local scale = 1
local increment = 0.1
while scale < 1.6 do
	pinata.Mesh.Scale = Vector3.new(scale,scale,scale)
	scale = scale + increment
	wait()
end
function pinataPieces()
	for i = 1, 20 do
		local pinataPart = Instance.new("Part")
		pinataPart.Name = "Pinata Piece"
		pinataPart.formFactor  = 2
		pinataPart.Size = Vector3.new(1,0.4,1)
		local color = math.random(1,3)
		if color == 1 then pinataPart.BrickColor = BrickColor.new("Bright red")
		elseif color == 2 then pinataPart.BrickColor = BrickColor.new("Bright yellow")
		else pinataPart.BrickColor = BrickColor.new("Bright orange") end
		pinataPart.BottomSurface = 0
		pinataPart.TopSurface = 0
		pinataPart.Material = Enum.Material.Grass
		pinataPart.Position = Vector3.new(pinata.Position.x + math.random(-1,1),pinata.Position.y + math.random(-1,1),pinata.Position.z + math.random(-1,1))
		pinataPart.Parent = game.Workspace
		debris:AddItem(pinataPart,4)
	end
end
local breaking = false
function checkHealth()
	print(health)
	-- time to break out some gear!
	if health <= 0 then
		if breaking then return end
		breaking = true
		local gearInstances = {}
		for i = 1, #gears do
			--This call will cause a "wait" until the data comes back
			local root = game:GetService("InsertService"):LoadAsset(gears[i])
			local instances = root:GetChildren()
			if #instances == 0 then
				root:Remove()
				return
			end
			root = root:GetChildren()
			root[1].Handle.Position = Vector3.new(pinata.Position.x + math.random(-1,1),pinata.Position.y + math.random(-1,1),pinata.Position.z + math.random(-1,1))
			table.insert(gearInstances,root[1])
		end
		pinata.Transparency = 1
		pinata.CanCollide = false
		local co = coroutine.create(pinataPieces)
		coroutine.resume(co)
		for i = 1, #gearInstances do
			gearInstances[i].Parent = game.Workspace
		end
		
		pinata.BrokenSound:Play()
		theWholeThing:remove()
		breaking = false
	end
end
local touching = false
function onTouched(part)
	if touching then return end
	touching = true
	
	if part.CanCollide then
		health = health - part.Velocity.magnitude/50
		checkHealth()
		wait(0.1)
	end
	touching = false
end
pinata.Touched:connect(onTouched)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("PinataScript") then
		source = [[local Tool = script.Parent
local torso = nil
function onEquipped()
	torso = Tool.Parent:FindFirstChild("Torso") or Tool.Parent:FindFirstChild("UpperTorso")
end
Tool.Equipped:connect(onEquipped)
function onUnequipped()
	if Tool.Handle.Transparency == 1 then
		Tool.Parent = game.Players:GetPlayerFromCharacter(torso.Parent).Backpack
	end
end
Tool.Unequipped:connect(onUnequipped)
function pinataExists()
	return game.Workspace:FindFirstChild(torso.Parent.Name .. "'s Pinata")
end
local enabled = false
function onActivated()
	if pinataExists() == nil then
		enabled = false
	end
	if enabled then return end
	enabled = true
	local pinata = Tool.Handle:clone()
	pinata.Name = "Head"
	pinata.CanCollide = true
	pinata.Size = Vector3.new(3,3,1)
	pinata.Position = Vector3.new(torso.Position.x + (torso.CFrame.lookVector.unit.x * 8),torso.Position.y,torso.Position.z + (torso.CFrame.lookVector.unit.z * 8))
	local model = Instance.new("Model")
	model.Name = torso.Parent.Name .. "'s Pinata"
	pinata.Parent = model
	model.Parent = game.Workspace
	local sound = Instance.new("Sound")
	sound.Name = "BrokenSound"
	sound.SoundId = "http://www.roblox.com/asset/?id=34300463"
	sound.Parent = pinata
	local humanoid = Instance.new("Humanoid")
	humanoid.MaxHealth = 0
	humanoid.Parent = model
	Tool.Handle.Transparency = 1
	
	local script = Tool.PinataScript:clone()
	script.Parent = pinata
	script.Disabled = false
	
	local bodyPos = Instance.new("BodyPosition")
	bodyPos.position = Vector3.new(pinata.Position.x,torso.Position.y + 5, pinata.Position.z)
	bodyPos.P = 8000
	bodyPos.D = bodyPos.P
	bodyPos.maxForce = Vector3.new(bodyPos.P,bodyPos.P,bodyPos.P)
	bodyPos.Parent = pinata
	local bodyGyro = Instance.new("BodyGyro")
	bodyGyro.P = 50
	bodyGyro.D = bodyGyro.P
	bodyGyro.maxTorque = Vector3.new(bodyGyro.P,0,0)
	bodyGyro.cframe = pinata.CFrame
	bodyGyro.Parent = pinata
	Tool:Destroy()
	checkForTransparency()
end
Tool.Activated:connect(onActivated)
function checkForTransparency()
	while pinataExists() do wait(0.5) end
	Tool.Handle.Transparency = 0
end]]
	elseif v:FindFirstChild("Airstrike") then
		source = [[--Rescripted by StarWars
local Tool = script.Parent
local Airstrike = require(script.Airstrike)
local COOL_DOWN = 20
local LastStrike = 0
local OnMouseClickEvent = Instance.new("RemoteEvent")
OnMouseClickEvent.Name = "OnMouseClick"
OnMouseClickEvent.OnServerEvent:connect(function(player, location)
	if tick() - LastStrike > COOL_DOWN then
		LastStrike = tick()
		Airstrike:Spawn(player, location)
	end
end)
OnMouseClickEvent.Parent = Tool]]
	elseif v.Name == "Script" and v:FindFirstChild("SpeedEffect") then
		source = [[--Rescripted by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
BaseUrl = "http://www.roblox.com/asset/?id="
Sounds = {
	Drink = Handle:WaitForChild("Drink"),
}
Grips = {
	Normal = CFrame.new(0.200000003, -0.100000001, 0, 0.217036337, 0, 0.976163626, 0, 1, -0, -0.976163507, 0, 0.217036366),
	Active = CFrame.new(1.39999998, -0.400000006, 0.300000012, 0.995685041, 0.0927979201, -9.8362565e-005, -0.0508967601, 0.546987712, 0.835591972, 0.0775950029, -0.831981361, 0.54935056),
}
SpeedEffect = script:WaitForChild("SpeedEffect")
ToolEquipped = false
Handle.Transparency = 0
Tool.Enabled = true
function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Player and Player.Parent) and true) or false)
end
function Activated()
	if not ToolEquipped or not CheckIfAlive() or not Tool.Enabled then
		return
	end
	Tool.Enabled = false
	Tool.Grip = Grips.Active
	Sounds.Drink:Play()
	wait(3)
	if CheckIfAlive() then
		local EffectCopy = Character:FindFirstChild(SpeedEffect.Name)
		if not EffectCopy then
			EffectCopy = SpeedEffect:Clone()
			EffectCopy.Disabled = false
			EffectCopy.Parent = Character
		end
	end
	Tool.Grip = Grips.Normal
	wait(60)
	Tool.Enabled = true
end
function Equipped()
	Character = Tool.Parent
	Humanoid = Character:FindFirstChild("Humanoid")
	Player = Players:GetPlayerFromCharacter(Character)
	if not CheckIfAlive() then
		return
	end
	ToolEquipped = true
end
function Unequipped()
	ToolEquipped = false
end
Tool.Activated:connect(Activated)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "SpeedEffect" and v:FindFirstChild("Explosion") then
		source = [[--Rescripted by Luckymaxer
--Updated for R15 avatars by StarWars
Character = script.Parent
Humanoid = Character:FindFirstChild("Humanoid")
Head = Character:FindFirstChild("Head")
Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
Player = Players:GetPlayerFromCharacter(Character)
Sounds = {
	Explosion = script:WaitForChild("Explosion"),
}
function DestroyScript()
	Debris:AddItem(script, 0.5)
	script:Destroy()
end
if not Head or not Torso or not Humanoid or Humanoid.Health == 0 or not Player then
	DestroyScript()
	return
end
Duration = 30
Humanoid.WalkSpeed = (16 * 1.6)
Sparkles = Instance.new("Sparkles")
Sparkles.SparkleColor = Color3.new(0.8, 0, 0.8)
Sparkles.Enabled = true
Debris:AddItem(Sparkles, Duration)
Sparkles.Parent = Torso
Count = script:FindFirstChild("CoffeeCount")
if not Count then
	Count = Instance.new("IntValue")
	Count.Name = "CoffeeCount"
	Count.Value = 1
	Count.Parent = script
else
	if (Count.Value > 3) then
		if (math.random() > 0.5) then
			ExplosionSound = Sounds.Explosion:Clone()
			Debris:AddItem(ExplosionSound, 5)
			ExplosionSound.Parent = Head
			ExplosionSound:Play()
			local Explosion = Instance.new("Explosion")
			Explosion.ExplosionType = Enum.ExplosionType.NoCraters
			Explosion.BlastRadius = 2
			Explosion.BlastPressure = 1000000
			Explosion.Position = Torso.Position
			Explosion.Parent = game:GetService("Workspace")
			
		end
	end
	Count.Value = (Count.Value + 1)
end
wait(Duration)
Humanoid.WalkSpeed = 16
DestroyScript()]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("AnimationPlayerScript") then
		source = [[function FindAttachedHumanoid(part)
	local tpart = part
	while tpart.Parent do
		if tpart.Parent:FindFirstChild('Humanoid') then return tpart.Parent.Humanoid end
		tpart = tpart.Parent
	end
	return nil
end
function MakeValue(class,name,value,parent)
	local temp = Instance.new(class)
	temp.Name = name
	temp.Value = value
	temp.Parent = parent
	return temp
end	
local Tool = script.Parent
local Handle = Tool:WaitForChild('Handle')
local YellSound = Handle:WaitForChild('Sound')
local AniScript = Tool:WaitForChild('AnimationPlayerScript')
--http://www.roblox.com/Asset?ID=111898513'--http://www.roblox.com/Asset?ID=111880514'
local ThrowAnimation = 'http://www.roblox.com/Asset?ID=111898867'
local ThrowFace = 'http://www.roblox.com/asset?id=111882478'
local ThrowTable= Instance.new('Part')
do
	--ThrowTable.Shape = 'Ball'
	ThrowTable.FormFactor='Custom'
	ThrowTable.Size = Vector3.new(4.8, 2.43, 3.63)
	ThrowTable.CanCollide = true
	local tmesh = Instance.new('SpecialMesh')
	tmesh.MeshId = 'http://www.roblox.com/asset/?id=111868131'
	tmesh.TextureId = 'http://www.roblox.com/asset/?id=111867655'
	tmesh.Parent = ThrowTable
end
local LookGyro= Instance.new('BodyGyro')
LookGyro.maxTorque = Vector3.new(0,math.huge,0) 
local ActivateLock=false
Tool.Activated:connect(function()
	if ActivateLock then return end
	ActivateLock = true
	local character = Tool.Parent
	local humanoid = character:WaitForChild('Humanoid')
	local torso = character:WaitForChild('Torso')
	local head = character:WaitForChild('Head')
	local face = head:FindFirstChild('face')
	local oldFace =''
	if face then oldFace = face.Texture end
	humanoid.WalkSpeed = 0
	LookGyro.cframe = torso.CFrame - torso.CFrame.p
	LookGyro.Parent = torso
	
	local ntable =  ThrowTable:Clone()
	ntable.CFrame = torso.CFrame+(torso.CFrame.lookVector*3)
	ntable.Parent = Workspace	
	
	MakeValue('StringValue','aniId',ThrowAnimation,AniScript)	
	wait(.5)
	YellSound:play()
	wait(.5)	
	if face then	
		face.Texture=ThrowFace
	end
	
	
	
	local bAVel = Instance.new('BodyAngularVelocity')
	bAVel.maxTorque = Vector3.new(math.huge,math.huge,math.huge)
	bAVel.angularvelocity = ((torso.CFrame*CFrame.Angles(0,math.pi/2,0)).lookVector*10)
	bAVel.Parent = ntable
	
	local bVel = Instance.new('BodyVelocity')
	bVel.maxForce = Vector3.new(math.huge,0,math.huge)
	bVel.velocity = (torso.CFrame.lookVector*25)
	bVel.Parent = ntable
	ntable.Touched:connect(function(part)
		--print('GotTouched:' .. part.Name)
		Spawn(function()
			if part.Name == 'Terrain' then return end
			if part.Anchored then return end
			local hitHumanoid = FindAttachedHumanoid(part)
			if hitHumanoid then
				--print('HumanoidParent:'..hitHumanoid.Parent.Name)
				if hitHumanoid==humanoid then return end
				hitHumanoid.PlatformStand =true 
			end
			if part.Size.x*part.Size.y*part.Size.z<=5*9*5 then
				part.Velocity = (Vector3.new((math.random()-.5)*2,math.random(),(math.random()-.5)*2).unit)*150
			end
			wait(3)
			print('got past wait')
			if hitHumanoid then
				print('unplatformstanding')
				hitHumanoid.PlatformStand=false 
				hitHumanoid.Jump = true 
			end
		end)
	end)
	wait(6)
	LookGyro.Parent = nil
	humanoid.WalkSpeed = 16
	if face then	
		face.Texture=oldFace
	end
	ntable.CanCollide = false
	game.Debris:AddItem(ntable,5)
	ActivateLock = false
end)]]
	elseif v.Name == "BananaScript" then
		source = [[wait(0.5)
local banana = script.Parent
local touched = false
function onTouched(part)
	if touched then
		return
	end
	
	touched = true
	local humanoid = part.Parent:FindFirstChild("Humanoid")
	if humanoid ~= nil then
		banana.SlipSound:Play()
		humanoid.Jump = true
		humanoid.Sit = true
		wait(0.9)
		humanoid.Sit = false
	end
	touched = false
end
banana.Touched:connect(onTouched)]]
	elseif v.Name == "CompassEffect" then
		source = [[--Updated for R15 avatars by StarWars
--print("do compass")
debris = game:GetService("Debris")
-- create arrow
local p = Instance.new("Part")
p.formFactor = 2
p.Size = Vector3.new(1,.4,1)
p.Transparency = .5
p.BrickColor = BrickColor.new(119)
p.CanCollide = false
p.Locked = true
p.RotVelocity = Vector3.new(math.random(), math.random(), math.random()) * 10
local Torso = script.Parent:FindFirstChild("Torso") or script.Parent:FindFirstChild("UpperTorso")
local v = Vector3.new(Torso.CFrame.lookVector.x, 0, Torso.CFrame.lookVector.z)
p.CFrame = CFrame.new(Torso.CFrame.p + v * 8, v.unit)
local m = script.ArrowMesh:Clone() -- NASTY......... I agree
m.Parent = p
local b = Instance.new("BodyPosition")
b.position = p.Position
b.Parent = p
local g = Instance.new("BodyGyro")
g.cframe = CFrame.new(Vector3.new(0,0,0), Vector3.new(0,0,1)) -- point North
g.maxTorque = Vector3.new(7e7, 7e7, 7e7)
g.Parent = p
p.Parent = game.Workspace
debris:AddItem(p, 10)
wait(5)
script.Parent = nil]]
	elseif v.Name == "CompassScript" then
		source = [[local Tool = script.Parent;

enabled = true




function onActivated()
	if not enabled  then
		return
	end

	enabled = false


	Tool.Handle.OpenSound:play()
	
	local h = Tool.Parent:FindFirstChild("Humanoid")
	if (h ~= nil) then
		local s = script.Parent.CompassEffect:Clone()
		s.Disabled = false
		s.Parent = Tool.Parent			
	end


	wait(3)

	enabled = true

end

function onEquipped()
	Tool.Handle.OpenSound:play()
end

script.Parent.Activated:connect(onActivated)
script.Parent.Equipped:connect(onEquipped)
]]
	elseif v.Parent.Parent.Name == "Fake Bomb" then
		source = [[--Stickmasterluke
sp=script.Parent
timer=20
soundinterval=1
starttime=tick()
attached=false
debris=game:GetService("Debris")
function makeconfetti()
	local cp=Instance.new("Part")
	cp.Name="Effect"
	cp.FormFactor="Custom"
	cp.Size=Vector3.new(0,0,0)
	cp.CanCollide=false
	cp.Transparency=1
	cp.CFrame=sp.CFrame
	cp.Velocity=Vector3.new((math.random()-.5),math.random(),(math.random()-.5)).unit*20
	delay(.25+(math.random()*.2),function()
		if cp~=nil then
			cp.Velocity=cp.Velocity*.1
			wait(.5)
		end
		if cp~=nil then
			cp.Velocity=Vector3.new(0,-1,0)
			wait(1)
		end
		if cp~=nil then
			cp.Velocity=Vector3.new(0,-2,0)
		end
	end)
	local cbbg=Instance.new("BillboardGui")
	cbbg.Adornee=cp
	cbbg.Size=UDim2.new(7,0,4,0)
	local cil=Instance.new("ImageLabel")
	cil.BackgroundTransparency=1
	cil.BorderSizePixel=0
	cil.Size=UDim2.new(1,0,1,0)
	cil.Image="http://www.roblox.com/asset/?id=104606998"
	cil.Parent=cbbg
	cbbg.Parent=cp
	local bf=Instance.new("BodyForce")
	bf.force=Vector3.new(0,cp:GetMass()*196.2,0)
	bf.Parent=cp
	debris:AddItem(cp,7+math.random())
	cp.Parent=game.Workspace
end
sp.Touched:connect(function(hit)
	if (not attached) and hit and hit~=nil and sp~=nil then
		local ct=sp:FindFirstChild("creator")
		if ct.Value~=nil and ct.Value.Character~=nil then
			if hit.Parent~=ct.Value.Character and hit.Name~="Handle" and hit.Name~="Effect" then
				local h=hit.Parent:FindFirstChild("Humanoid")
				local t=hit.Parent:FindFirstChild("Torso")
				if h~=nil and t~=nil and h.Health>0 then
					attached=true
					local w=Instance.new("Weld")
					w.Part0=t
					w.Part1=sp
					w.C0=CFrame.new(0,0,.8)*CFrame.Angles(math.pi/2,3.5,0)
					w.Parent=sp
				end
			end
		end
	end
end)
while true do
	local percent=(tick()-starttime)/timer
	t1,t2=wait(((1-percent)*soundinterval))
	local beep=sp:FindFirstChild("Beep")
	if beep~=nil then
		beep:Play()
	end
	local bbg=sp:FindFirstChild("BillboardGui")
	if bbg~=nil then
		bbg.Adornee=sp
		li=bbg:FindFirstChild("LightImage")
		if li~=nil then
			li.Visible=true
		end
	end
	if percent>1 then
		break
	end
	wait(.1)
	if li then
		li.Visible=false
	end
end
wait(.5)
local smoke=sp:FindFirstChild("Smoke")
if smoke then
	smoke.Enabled=true
end
wait(.5)
local fusesound=sp:FindFirstChild("Fuse")
if fusesound~=nil then
	fusesound:Play()
end
local bbg=sp:FindFirstChild("BillboardGui")
if bbg~=nil then
	bbg.Adornee=sp
	li=bbg:FindFirstChild("LightImage")
	if li~=nil then
		li.Visible=false
	end
end
local partysound=sp:FindFirstChild("PleaseNo")
if partysound~=nil then
	partysound:Play()
end
for i=1,7 do
	makeconfetti()
end
wait(.5)
if smoke then
	smoke.Enabled=false
end
wait(2.5)
sp:remove()]]
	elseif v.Name == "ToolDropped" then
		source = [[--Made by Luckymaxer
Tool = script.Parent
Players = game:GetService("Players")
CurrentUFO = Tool:WaitForChild("CurrentUFO")
Tool.Changed:connect(function(Property)
	if Property == "Parent" then
		local Player = Players:GetPlayerFromCharacter(Tool.Parent)
		if not Tool.Parent:IsA("Backpack") and not Player and CurrentUFO and CurrentUFO.Value and CurrentUFO.Value.Parent then
			CurrentUFO.Value:Destroy()
		end
	end
end)]]
	elseif v.Name == "ToolDisplay" then
		source = [[--Made by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Mesh = Handle:WaitForChild("Mesh")
ToolDisplays = {
	Normal = {
		Grip = CFrame.new(0, -0.75, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		MeshScale = Vector3.new(0.25, 0.25, 0.25)
	},
	Display = {
		Grip = CFrame.new(1.5, 2.54999995, -1.5, 1, 0, 0, 0, 1, 0, 0, 0, 1),
		MeshScale = Vector3.new(3, 3, 3)
	}
}
Tool.Grip = ToolDisplays.Normal.Grip
Mesh.Scale = ToolDisplays.Normal.MeshScale]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("ToolDropped") then
		source = [[--Made by Luckymaxer
--[[
	Fixed by ArceusInator
	2/23 - The UFO now replicates properly
--]
		Tool = script.Parent
		Handle = Tool:WaitForChild("Handle")
		Players = game:GetService("Players")
		Debris = game:GetService("Debris")
		InsertService = game:GetService("InsertService")
		UFOModel = InsertService:LoadAsset(162741606)
		UFO = UFOModel:GetChildren()[1]:Clone()
		UFOModel:Destroy()
		CurrentUFO = Tool:WaitForChild("CurrentUFO")
		SpawnUFO = Tool:WaitForChild("SpawnUFO")
		RemoverScript = script:WaitForChild("Remover")
		Grips = {
			NormalGrip = CFrame.new(0, -0.75, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1),
			SummoningGrip = CFrame.new(0.25, -0.75, 0, 1.12500096e-007, 1, -0, -0.99999994, 1.12500111e-007, 0, 0, 0, 1),
		}
		Equipped = false
		ReloadTime = 15
		function TransformModel(Parent, NewCFrame)
			local Origins = {}
			for i, v in pairs(Parent:GetChildren()) do
				if v:IsA("BasePart") then
					Origins[v] = Parent:GetModelCFrame():toObjectSpace(v.CFrame)
				end
			end
			for i, v in pairs(Origins) do
				i.CFrame = NewCFrame:toWorldSpace(v)
			end
		end
		function onMouse1Down()
			if Tool.Enabled and Humanoid and Humanoid.Parent and Humanoid.Health > 0 then
				Tool.Enabled = false
				SpawnUFOAnim = Humanoid:LoadAnimation(SpawnUFO)
				if SpawnUFOAnim then
					SpawnUFOAnim:Play()
					wait(0.1)
					Tool.Grip = Grips.SummoningGrip
					wait(0.25)
					if Equipped then
						local TorsoCFrame = Torso.CFrame
						Handle.Transparency = 1
						UFODeploy = Handle:Clone()
						UFODeploy.Name = "MiniUFO"
						UFODeploy.Transparency = 0
						UFODeploy.CanCollide = true
						UFODeploy.CFrame = CFrame.new(Handle.Position)
						local UFOCloneY = UFODeploy:Clone()
						UFOCloneY.CFrame = UFOCloneY.CFrame * CFrame.Angles(math.rad(90), 0, 0)
						local BodyVelocity = Instance.new("BodyVelocity")
						BodyVelocity.maxForce = Vector3.new((UFODeploy:GetMass() * 196.20), (UFODeploy:GetMass() * 196.20) * 2, (UFODeploy:GetMass() * 196.20))
						BodyVelocity.velocity = UFOCloneY.CFrame.lookVector * 1.25
						BodyVelocity.Parent = UFODeploy
						local BodyGyro = Instance.new("BodyGyro")
						BodyGyro.maxTorque = Vector3.new(math.huge, math.huge, math.huge)
						BodyGyro.cframe = UFODeploy.CFrame
						BodyGyro.Parent = UFODeploy
						Debris:AddItem(UFODeploy, 20)
						UFODeploy.Parent = game:GetService("Workspace")
						UFODeploy.CFrame = CFrame.new(Handle.Position) + Vector3.new(0, 0.1, 0)
						Delay(3, function()
							if UFODeploy and UFODeploy.Parent and BodyVelocity and BodyVelocity.Parent then
								BodyVelocity.velocity = TorsoCFrame.lookVector * 2.5
								wait(5)
								UFODeploy.Anchored = true
								UFODeploy.CanCollide = false
								Spawn(function()
									while UFODeploy and UFODeploy.Parent and UFODeploy.Mesh.Scale.Y < 3 do
										local NewScale = (UFODeploy.Mesh.Scale.Y + 0.05)
										UFODeploy.Mesh.Scale = Vector3.new(NewScale, NewScale, NewScale)
										wait()
									end
									if UFODeploy and UFODeploy.Parent then
										local UFOVehicle = UFO:Clone()
										local Creator = Instance.new("ObjectValue")
										Creator.Name = "Creator"
										Creator.Value = Player
										Creator.Parent = UFOVehicle
										local RemoverScriptClone = RemoverScript:Clone()
										RemoverScriptClone.Disabled = false
										RemoverScriptClone.Parent = UFOVehicle
										CurrentUFO.Value = UFOVehicle
										UFOVehicle.Parent = game:GetService("Workspace")
										UFOVehicle.Changed:connect(function(Property)
											if Property == "Parent" and not UFOVehicle.Parent then
												wait(ReloadTime)
												Handle.Transparency = 0
												Tool.Enabled = true
											end
										end)
										TransformModel(UFOVehicle, CFrame.new(UFODeploy.CFrame.p))
										if UFOVehicle.Engine.Position.Y < UFOVehicle.BeamPart.Position.Y then
											TransformModel(UFOVehicle, UFOVehicle:GetModelCFrame() * CFrame.Angles(0, math.pi, 0))
										end
										UFODeploy:Destroy()
									end
								end)
							end
						end)
						wait(2)
						Tool.Grip = Grips.NormalGrip
					end
				end
			end		
		end
		function onKeyDown(key)
			if key == "x" then
				if CurrentUFO.Value then
					CurrentUFO.Value:Destroy()
				end
			end
		end
		Tool.Input.OnServerEvent:connect(function(client, action, ...)
			if client.Character == Tool.Parent then
				if action == 'Mouse1Down' then
					onMouse1Down()
				elseif action == 'KeyDown' then
					onKeyDown(...)
				end
			end
		end)
		function Equipped()
			Character = Tool.Parent
			Player = Players:GetPlayerFromCharacter(Character)
			Humanoid = Character:FindFirstChild("Humanoid")
			Torso = Character:FindFirstChild("Torso")
			if not Player or not Humanoid and Humanoid.Health == 0 or not Torso then
				return
			end
			if not Tool.Enabled and not CurrentUFO.Value then
				wait(ReloadTime)
				Tool.Enabled = true
			end
			Equipped = true
			Tool.Grip = Grips.NormalGrip
		end
		function Unequipped()
			Equipped = false
			if SpawnUFOAnim then
				SpawnUFOAnim:Stop()
			end
			if UFODeploy and UFODeploy.Parent then
				UFODeploy:Destroy()
			end
			Handle.Transparency = 0
		end
		Tool.Equipped:connect(Equipped)
		Tool.Unequipped:connect(Unequipped)]]
	elseif v.Parent:FindFirstChild("DrumGui") then
		source = [[--Rescripted by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Head = Character:FindFirstChild("Head")
	if not Player or not Humanoid or Humanoid.Health == 0 or not Head then
		return
	end
	Head.Anchored = true
	ForceSit = Humanoid.Changed:connect(function(Property)
		if Property == "Sit" and not Humanoid[Property] then
			Humanoid[Property] = true
		end
	end)
	Humanoid.Sit = true
end
function Unequipped()
	if ForceSit then
		ForceSit:disconnect()
	end
	if Humanoid and Humanoid.Parent then
		Humanoid.Sit = false
	end
	if Head and Head.Parent then
		Head.Anchored = false
	end
end
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("DisplayModel") then
		source = [[--Made by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
Assets = require(Tool:WaitForChild("Assets"))
Data = Assets.Data
ColorValue = Tool:WaitForChild("CurrentColor")
BaseUrl = Assets.BaseUrl
BasePart = Instance.new("Part")
BasePart.Material = Enum.Material.Plastic
BasePart.Shape = Enum.PartType.Block
BasePart.TopSurface = Enum.SurfaceType.Smooth
BasePart.BottomSurface = Enum.SurfaceType.Smooth
BasePart.FormFactor = Enum.FormFactor.Custom
BasePart.Size = Vector3.new(0.2, 0.2, 0.2)
BasePart.Anchored = false
BasePart.CanCollide = true
BasePart.Locked = true
Colors = {
	{Texture = 212640675, Color = BrickColor.new("Bright red")}, --Red
	{Texture = 212640593, Color = BrickColor.new("Bright orange")}, --Orange
	{Texture = 204410898, Color = BrickColor.new("Bright green")}, --Green
	{Texture = 212640633, Color = BrickColor.new("Bright blue")}, --Blue
	{Texture = 212640526, Color = BrickColor.new("Light blue")}, --Light Blue
	{Texture = 212640552, Color = BrickColor.new("Magenta")}, --Magenta
}
CurrentColor = 0
CycleTick = 0
CycleTime = 1
Animations = {
	Hold = {Animation = Tool:WaitForChild("Hold"), FadeTime = nil, Weight = nil, Speed = nil}
}
Sounds = {
	Honk = Handle:WaitForChild("Honk"),
	Engine = Handle:WaitForChild("Running")
}
Controls = {
	Forward = {Key = "w", ByteKey = 17, Mode = false},
	Backward = {Key = "s", ByteKey = 18, Mode = false},
	Left = {Key = "a", ByteKey = 20, Mode = false},
	Right = {Key = "d", ByteKey = 19, Mode = false}
}
	
Rate = (1 / 60)
	
Gravity = 196.20
	
PoseOffset = CFrame.new(0, -2, 0.5) * CFrame.Angles(0, 0, 0) --The offset your character is from the center of the vehicle.
SpeedBoost = {
	Allowed = false,
	Active = false,
	Enabled = true,
	Duration = 10,
	ReloadTime = 30
}
Special = {
	Allowed = false,
	Enabled = true,
	Active = false,
	Duration = 0,
	ReloadTime = 60
}
Speed = {
	Acceleration = {
		Normal = 40,
		Boost = 40
	},
	Deceleration = {
		Normal = 40,
		Boost = 40
	},
	MovementSpeed = {
		Normal = {Min = 20, Max = 70},
		Boost = {Min = 20, Max = 70}
	},
	TurnSpeed = {
		Speed = {Min = 5, Max = 5},
		TurnAlpha = 0.30,
		AlphaDampening = 0.2
	},
}
MaxSpeed = { --Maximum speed which the vehicle can move and turn at.
	Movement = Speed.MovementSpeed.Normal,
	Turn = Speed.TurnSpeed.Speed,
	Acceleration = Speed.Acceleration.Normal,
	Deceleration = Speed.Deceleration.Normal
}
CurrentSpeed = { --The speed which the vehicle is moving and turning at.
	Movement = 0,
	Turn = 0
}
Honk = {
	Honking = false,
	LastHonk = 0,
	ReloadTime = 1
}
Jump = {
	Jumping = false,
	LastJump = 0,
	ReloadTime = 1.9,
	JumpForce = 30
}
ToolEquipped = false
DisplayModel = Tool:FindFirstChild("DisplayModel")
if DisplayModel then
	DisplayModel:Destroy()
end
ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool
ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool
Tool.Enabled = true
function RayCast(Position, Direction, MaxDistance, IgnoreList)
	local IgnoreList = ((type(IgnoreList) == "table" and IgnoreList) or {IgnoreList})
	return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(Position, Direction.unit * (MaxDistance or 999.999)), IgnoreList)
end
function GetAllConnectedParts(Object)
	local Parts = {}
	local function GetConnectedParts(Object)
		for i, v in pairs(Object:GetConnectedParts()) do
			local Ignore = false
			for ii, vv in pairs(Parts) do
				if v == vv then
					Ignore = true
				end
			end
			if not Ignore then
				table.insert(Parts, v)
				GetConnectedParts(v)
			end
		end
	end
	GetConnectedParts(Object)
	return Parts
end
function EnableFirstPersonView()
	if not CheckIfAlive() or not ToolEquipped then
		return
	end
	local Limbs = {"Left Arm", "Right Arm"}
	for i, v in pairs(Limbs) do
		local Limb = Character:FindFirstChild(v)
		if Limb:IsA("BasePart") then
			Spawn(function()
				InvokeClient("SetLocalTransparencyModifier", {Object = Limb, Transparency = 0, AutoUpdate = false})
			end)
		end
	end
end
function ThrustUpdater()
	
	for i, v in pairs(CurrentSpeed) do
		CurrentSpeed[i] = 0
	end
	for i, v in pairs(Controls) do
		Controls[i].Mode = false
	end
	while ToolEquipped and Body and Body.Parent and CheckIfAlive() and RotationForce and RotationForce.Parent and ThrustForce and ThrustForce.Parent and TurnGyro and TurnGyro.Parent do
		
		RotationForce.angularvelocity = Vector3.new(0, CurrentSpeed.Turn, 0)
		if math.abs(CurrentSpeed.Turn) > Speed.TurnSpeed.AlphaDampening then
			CurrentSpeed.Turn = (CurrentSpeed.Turn - (Speed.TurnSpeed.AlphaDampening * (math.abs(CurrentSpeed.Turn) / CurrentSpeed.Turn)))
		else 
			CurrentSpeed.Turn = 0		
		end
				
		if not Controls.Forward.Mode or Controls.Backward.Mode then --Slow down if not controlling.
			CurrentSpeed.Movement = (CurrentSpeed.Movement * 0.99)
		end
		
		local MySpeed = Vector3.new(Body.Velocity.X, 0, Body.Velocity.Z).magnitude
		local VelocityDifference = math.abs((MySpeed - (ThrustForce.velocity.magnitude)))
		if MySpeed > 3 and ThrustForce.velocity.magnitude > 3 and VelocityDifference > (0.7 * ThrustForce.velocity.magnitude) then
			CurrentSpeed.Movement = (CurrentSpeed.Movement * 0.9)
		end
		
		if Controls.Forward.Mode then --Handle acceleration
			CurrentSpeed.Movement = math.min(MaxSpeed.Movement.Max, (CurrentSpeed.Movement + (MaxSpeed.Acceleration * Rate)))
		end
		if Controls.Backward.Mode then --Handle deceleration, if speed is more than 0, decrease quicker.
			CurrentSpeed.Movement = math.max(-MaxSpeed.Movement.Min, (CurrentSpeed.Movement - (MaxSpeed.Deceleration * ((CurrentSpeed.Movement > 0 and 2.8) or 1) * Rate)))
		end
		
		if Controls.Left.Mode then --Handle left turn speed
			CurrentSpeed.Turn = math.min(Speed.TurnSpeed.Speed.Max, (CurrentSpeed.Turn + (Speed.TurnSpeed.TurnAlpha)))
		end
		if Controls.Right.Mode then --Handle right turn speed
			CurrentSpeed.Turn = math.max(-Speed.TurnSpeed.Speed.Min, (CurrentSpeed.Turn - (Speed.TurnSpeed.TurnAlpha)))
		end
		
		local Direction = Torso.CFrame.lookVector
		Direction = Vector3.new(Direction.x, 0, Direction.z).unit
		
		local Velocity = (Direction * CurrentSpeed.Movement) --The thrust force which you move.
		ThrustForce.velocity = Vector3.new(Velocity.X, ThrustForce.velocity.Y, Velocity.Z)
		
		local LeanAmount = (-CurrentSpeed.Turn * (math.pi / 6) / 4) --Amount your character leans over.
		local XZAngle = math.atan2(Torso.CFrame.lookVector.z, 0, Torso.CFrame.lookVector.x) --Handle rotation
		TurnGyro.cframe = CFrame.Angles((LeanAmount * Direction.x), 0, (LeanAmount * Direction.z))
		
		--Wheel animation
		local DesiredAngle = (999999999 * (-CurrentSpeed.Movement / math.abs(CurrentSpeed.Movement)))
		local MaxVelocity = (CurrentSpeed.Movement / 250)
		for i, v in pairs({FrontMotor, BackMotor, LeftMotor, RightMotor}) do
			if v and v.Parent then
				v.DesiredAngle = DesiredAngle
				v.MaxVelocity = MaxVelocity
			end
		end
		
		--Smoke exhaust from vehicle running.
		for i, v in pairs(ExhaustSmoke) do
			if v and v.Parent then
				v.Opacity = ((math.min(math.abs(CurrentSpeed.Movement), 10) / 10) * 0.5)
			end
		end
		
		--Engine running sound which pitch changes while in motion.
		Sounds.Engine.Pitch = (1 + (math.abs(CurrentSpeed.Movement / MaxSpeed.Movement.Max) * 1))
		
		if (tick() - CycleTick) >= CycleTime then
			CycleTick = tick()
			CurrentColor = (CurrentColor + 1)
			CurrentColor = ((CurrentColor > #Colors and 1) or CurrentColor)
			local ColorTable = Colors[CurrentColor]
			ColorValue.Value = ColorTable.Color.Color
			local Parts = {Body}
			for i, v in pairs(Body:GetChildren()) do
				if v:IsA("BasePart") then
					table.insert(Parts, v)
				end
			end
			for i, v in pairs(Parts) do
				if v ~= Body then
					v.BrickColor = ColorTable.Color
				end
				for ii, vv in pairs(v:GetChildren()) do
					if vv:IsA("FileMesh") then
						vv.TextureId = (BaseUrl .. ColorTable.Texture)
					elseif vv:IsA("Light") then
						vv.Color = ColorTable.Color.Color
					elseif vv:IsA("BasePart") then
					end
				end
			end
		end
		
		wait(Rate)
		
	end
end
function SpawnVehicle()
	
	Handle.Transparency = 1
	
	Spawn(function()
		InvokeClient("PlaySound", Sounds.Engine)
		InvokeClient("PlayAnimation", Animations.Hold)
	end)	
	
	Humanoid.PlatformStand = true
	
	CurrentColor = math.random(1, #Colors)
	ColorValue.Value = Colors[CurrentColor].Color.Color
	
	local OrigCF = Torso.CFrame
	
	local VehicleData = Assets.CreateVehicle()
	Body = VehicleData.Vehicle
	local ParticleTable = VehicleData.Tables
	
	FrontMotor = Body.FrontMotor
	BackMotor = Body.BackMotor
	LeftMotor = Body.LeftMotor
	RightMotor = Body.RightMotor
	
	Seat = Body.Seat
	Seat.ChildAdded:connect(function(Child)
		if Child:IsA("Weld") and Child.Name == "SeatWeld" then
			Child.C1 = (CFrame.new(0, 0.75, -1) * CFrame.Angles(Child.C1:toEulerAnglesXYZ()))
		end
	end)
	
	ExhaustSmoke = ParticleTable.ExhaustSmoke
	Lights = ParticleTable.Lights
	Sparkles = ParticleTable.Sparkles
	
	if SpeedBoost.Active then
		for i, v in pairs(Sparkles) do
			if v and v.Parent then
				v.Enabled = true
			end
		end
	end
	
	local TorsoWeld = Instance.new("Weld")
	TorsoWeld.C0 = PoseOffset
	TorsoWeld.Part0 = Torso
	TorsoWeld.Part1 = Body
	TorsoWeld.Parent = Body
	
	Body.CanCollide = true
	RotationForce = Instance.new("BodyAngularVelocity")
	RotationForce.maxTorque = Vector3.new(0, math.huge, 0)
	RotationForce.angularvelocity = Vector3.new(0, 0, 0)
	RotationForce.Parent = Torso
	
	ThrustForce = Instance.new("BodyVelocity")
	ThrustForce.maxForce = Vector3.new(math.huge, 0, math.huge)
	ThrustForce.velocity = Vector3.new(0, 0, 0)
	ThrustForce.P = 100
	ThrustForce.Parent = Torso
	
	TurnGyro = Instance.new("BodyGyro")
	TurnGyro.maxTorque = Vector3.new(5000, 0, 5000)
	TurnGyro.P = 300
	TurnGyro.D = 100
	TurnGyro.Parent = Torso
	
	Body.Parent = Tool
	
	Torso.CFrame = OrigCF
	
	local RayHit, RayPos, RayNormal = RayCast(Torso.Position, Vector3.new(0, -1, 0), (Torso.Size.Y * 2), {Character})
	if RayHit then
		Torso.CFrame = Torso.CFrame + Vector3.new(0, ((Character:GetModelSize().Y / 2) + 1.5), 0)
	end
	
	Spawn(ThrustUpdater)
	
end
function FreezePlayer()
	if CheckIfAlive() then
		local FreezePart = BasePart:Clone()
		FreezePart.Name = "FreezePart"
		FreezePart.Transparency = 1
		FreezePart.Anchored = true
		FreezePart.CanCollide = false
		local FreezeWeld = Instance.new("Weld")
		FreezeWeld.Part0 = Torso
		FreezeWeld.Part1 = FreezePart
		FreezeWeld.Parent = FreezePart
		Debris:AddItem(FreezePart, 0.125)
		FreezePart.Parent = Character
		Torso.Velocity = Vector3.new(0, -25, 0)
		Torso.RotVelocity = Vector3.new(0, 0, 0)
	end
end
function CleanUp()
	Handle.Velocity = Vector3.new(0, 0, 0)
	Handle.RotVelocity = Vector3.new(0, 0, 0)
	for i, v in pairs({}) do
		if v then
			v:disconnect()
		end
	end
	if Seat and Seat.Parent and Seat.Occupant then
		local humanoid = Seat.Occupant
		if humanoid and humanoid:IsA("Humanoid") then
			humanoid.Sit = false
		end
	end
	for i, v in pairs({Body, RotationForce, ThrustForce, TurnGyro}) do
		if v and v.Parent then
			v:Destroy()
		end
	end
	for i, v in pairs(Tool:GetChildren()) do
		if v:IsA("BasePart") and v ~= Handle then
			v:Destroy()
		end
	end
end
function CheckIfAlive()
	return (((Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent and Player and Player.Parent) and true) or false)
end
function Equipped(Mouse)
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("Torso")
	if not CheckIfAlive() then
		return
	end
	for i, v in pairs(Colors) do
		Spawn(function()
			InvokeClient("Preload", (BaseUrl .. v.Texture))
		end)
	end
	Spawn(CleanUp)
	Spawn(EnableFirstPersonView)
	Spawn(SpawnVehicle)
	ToolEquipped = true
end
function Unequipped()
	Spawn(CleanUp)
	Spawn(FreezePlayer)
	for i, v in pairs(Sounds) do
		v:Stop()
		Spawn(function()
			InvokeClient("StopSound", v)
		end)
	end
	if CheckIfAlive() then
		Humanoid.PlatformStand = false
	end
	Handle.Transparency = 0
	ToolEquipped = false
end
function OnServerInvoke(player, mode, value)
	if player == Player and ToolEquipped and value and CheckIfAlive() then
		if mode == "KeyPress" then
			local Down = value.Down
			local Key = value.Key
			local ByteKey = string.byte(Key)
			for i, v in pairs(Controls) do
				if Key == v.Key or ByteKey == v.ByteKey then
					Controls[i].Mode = Down
				end
			end
			if Key == " " and Down then --Jump controller
				if math.abs(tick() - Jump.LastJump) > Jump.ReloadTime and not Jump.Jumping and ThrustForce and ThrustForce.Parent then
					Jump.Jumping = true
					local Parts = GetAllConnectedParts(Body)
					local Mass = 0
					for i, v in pairs(Parts) do
						Mass = (Mass + v:GetMass())
					end
					ThrustForce.maxForce = Vector3.new(ThrustForce.maxForce.X, ((Mass * Gravity) * 100), ThrustForce.maxForce.Z)
					ThrustForce.velocity = (Vector3.new(0, 1, 0) * Jump.JumpForce) + Vector3.new(ThrustForce.velocity.X, 0, ThrustForce.velocity.Z)
					wait(0.1)
					ThrustForce.maxForce = Vector3.new(ThrustForce.maxForce.X, 0, ThrustForce.maxForce.Z)
					ThrustForce.velocity = Vector3.new(ThrustForce.velocity.X, 0, ThrustForce.velocity.Z)
					Jump.LastJump = tick()
					Jump.Jumping = false
				end
			elseif Key == "x" and Down then --Toggle light(s) on/off.
				for i, v in pairs(Lights) do
					if v and v.Parent then
						v.Enabled = not v.Enabled
					end
				end
			elseif Key == "h" and Down then --Play honk sound.
				local Sound = Sounds.Honk
				if (tick() - Honk.LastHonk) >= (Sound.TimeLength + Honk.ReloadTime) and not Honk.Honking then
					Honk.Honking = true
					local TempSound = Sound:Clone()
					Debris:AddItem(TempSound, Sound.TimeLength)
					TempSound.Parent = Body
					TempSound:Play()
					Honk.LastHonk = tick()
					Honk.Honking = false
				end
			elseif Key == "q" and Down then --Activate special.
				if not Special.Allowed or not Special.Enabled or Special.Active then
					return
				end
				Special.Enabled = false
				Special.Active = true
				wait(Special.Duration)
				Special.Active = false
				wait(Special.ReloadTime)
				Special.Enabled = true
			elseif ByteKey == 48 and Down then --Activate speed boost.
				if not SpeedBoost.Allowed or not SpeedBoost.Enabled or SpeedBoost.Active then
					return
				end
				SpeedBoost.Enabled = false
				SpeedBoost.Active = true
				for i, v in pairs(Sparkles) do
					if v and v.Parent then
						v.Enabled = true
					end
				end
				MaxSpeed.Acceleration = Speed.Acceleration.Boost
				MaxSpeed.Deceleration = Speed.Deceleration.Boost
				MaxSpeed.Movement = Speed.MovementSpeed.Boost
				wait(SpeedBoost.Duration)
				MaxSpeed.Acceleration = Speed.Acceleration.Normal
				MaxSpeed.Deceleration = Speed.Deceleration.Normal
				MaxSpeed.Movement = Speed.MovementSpeed.Normal
				for i, v in pairs(Sparkles) do
					if v and v.Parent then
						v.Enabled = false
					end
				end
				SpeedBoost.Active = false
				wait(SpeedBoost.ReloadTime)
				SpeedBoost.Enabled = true
			end
		end
	end
end
function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end
Spawn(CleanUp)
ServerControl.OnServerInvoke = OnServerInvoke
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "TrailScript" and v.Parent:FindFirstChild("DisplayModel") then
		source = [[--Made by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Debris = game:GetService("Debris")
CurrentColor = Tool:WaitForChild("CurrentColor")
BasePart = Instance.new("Part")
BasePart.Shape = Enum.PartType.Block
BasePart.Material = Enum.Material.Plastic
BasePart.TopSurface = Enum.SurfaceType.Smooth
BasePart.BottomSurface = Enum.SurfaceType.Smooth
BasePart.FormFactor = Enum.FormFactor.Custom
BasePart.Anchored = false
BasePart.CanCollide = true
BasePart.Locked = true
BaseTrailPart = BasePart:Clone()
BaseTrailPart.Name = "LaserTrail"
BaseTrailPart.Transparency = 0.2
BaseTrailPart.Size = Vector3.new(0.5, 5, 3)
BaseTrailPart.Material = Enum.Material.SmoothPlastic
BaseTrailPart.TopSurface = Enum.SurfaceType.SmoothNoOutlines
BaseTrailPart.BottomSurface = Enum.SurfaceType.SmoothNoOutlines
BaseTrailPart.LeftSurface = Enum.SurfaceType.SmoothNoOutlines
BaseTrailPart.RightSurface = Enum.SurfaceType.SmoothNoOutlines
BaseTrailPart.FrontSurface = Enum.SurfaceType.SmoothNoOutlines
BaseTrailPart.BackSurface = Enum.SurfaceType.SmoothNoOutlines
BaseTrailPart.Anchored = true
BaseTrailPart.CanCollide = false
TrailLight = Instance.new("PointLight")
TrailLight.Name = "Light"
TrailLight.Brightness = 10
TrailLight.Range = 8
TrailLight.Shadows = false
TrailLight.Enabled = true
TrailLight.Parent = BaseTrailPart
Rate = (1 / 60)
function StartTrail(Source, Parent)
	
	local TrailParts = {}
	
	local SourceAlive = true
	local NumberOfParts = 60
	local LastPoint = (Source.CFrame * CFrame.new(0, 0, 4)).p
	
	Source.Changed:connect(function(Property)
		if Property == "Parent" and not Source.Parent then
			SourceAlive = false
		end
	end)
	
	while SourceAlive do
		local CurrentPoint = (Source.CFrame * CFrame.new(-1.125, 0, 4)).p
		if Source.Velocity.magnitude > 20 then
			local TrailPart = BaseTrailPart:Clone()
			TrailPart.BrickColor = BrickColor.new(CurrentColor.Value)
			TrailPart.Light.Color = CurrentColor.Value
			TrailPart.Size = Vector3.new(TrailPart.Size.X, TrailPart.Size.Y, (CurrentPoint - LastPoint).magnitude)
			table.insert(TrailParts, TrailPart)
			TrailPart.Parent = Parent
			TrailPart.CFrame = CFrame.new(((CurrentPoint + LastPoint) * 0.5), LastPoint)
			if #TrailParts > NumberOfParts then
				local TrailPart = TrailParts[1]
				if TrailPart and TrailPart.Parent then
					TrailPart:Destroy()
				end
				table.remove(TrailParts, 1)
			end
		else
			local TrailPart = TrailParts[1]
			if TrailPart and TrailPart.Parent then
				TrailPart:Destroy()
			end
			table.remove(TrailParts, 1)
		end
		LastPoint = CurrentPoint
		wait(Rate)
	end
	
	for i, v in pairs(TrailParts) do
		if v and v.Parent then
			v:Destroy()
		end
	end
	
end
Tool.ChildAdded:connect(function(Child)
	if Child.Name == "Body" then
		Spawn(function()
			StartTrail(Child, Tool)
		end)
	end
end)]]
	elseif v.Name == "BlowDryer" then
		source = [[--Rescripted by Luckymaxer
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Players = game:GetService("Players")
Debris = game:GetService("Debris")
AirScript = script:WaitForChild("AirScript")
Colors = {"White", "Light stone grey", "Light blue", "Pastel Blue"} 
BasePart = Instance.new("Part")
BasePart.Shape = Enum.PartType.Block
BasePart.Material = Enum.Material.Plastic
BasePart.TopSurface = Enum.SurfaceType.Smooth
BasePart.BottomSurface = Enum.SurfaceType.Smooth
BasePart.FormFactor = Enum.FormFactor.Custom
BasePart.Size = Vector3.new(0.2, 0.2, 0.2)
BasePart.CanCollide = true
BasePart.Locked = true
BasePart.Anchored = false
AirBubble = BasePart:Clone()
AirBubble.Name = "Effect"
AirBubble.Shape = Enum.PartType.Ball
AirBubble.Size = Vector3.new(2, 2, 2)
AirBubble.CanCollide = false
Gravity = 196.20
Sounds = {
	DryerSound = Handle:WaitForChild("DryerSound")
}
MouseDown = false
ToolEquipped = false
ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool
ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool
Tool.Enabled = true
function Fire(Direction)
	
	if not Tool.Enabled or not CheckIfAlive() then
		return
	end
	
	local SpawnPos = Handle.Position + (Direction * 7.5)
	
	local Offset = Vector3.new(
		((math.random() - 0.5) * 50),
		((math.random() - 0.5) * 50),
		((math.random() - 0.5) * 50)
	)
	local Force = 80
	local Air = AirBubble:Clone()
	Air.Transparency = (math.random() * 0.5)
	Air.CFrame = CFrame.new(SpawnPos, Vector3.new(Offset.X, Offset.Y, Offset.Z))
	Air.Velocity = (Direction * Force)
	Air.BrickColor = BrickColor.new(Colors[math.random(1, #Colors)])
	
	local Mass = (Air:GetMass() * Gravity)
	
	local BodyVelocity = Instance.new("BodyVelocity")
	BodyVelocity.maxForce = Vector3.new(Mass, Mass, Mass)
	BodyVelocity.velocity = (Direction * Force)
	BodyVelocity.Parent = Air
	
	local Creator = Instance.new("ObjectValue")
	Creator.Name = "Creator"
	Creator.Value = Player
	Creator.Parent = Air
	
	local AirScriptClone = AirScript:Clone()
	AirScriptClone.Disabled = false
	AirScriptClone.Parent = Air
	
	Debris:AddItem(Air, 2)
	
	Air.Parent = game:GetService("Workspace")
end
function CheckIfAlive()
	return (((Player and Player.Parent and Character and Character.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0) and true) or false)
end
function Equipped()
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	if not CheckIfAlive() then
		return
	end
	ToolEquipped = true
end
function Unequipped()
	MouseDown = false
	ToolEquipped = false
end
function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end
ServerControl.OnServerInvoke = (function(player, Mode, Value)
	if player ~= Player or not ToolEquipped or not CheckIfAlive() or not Mode or not Value then
		return
	end
	if Mode == "Button1Click" then
		local Down = Value.Down
		if Down and not MouseDown and Tool.Enabled then
			MouseDown = true
			Spawn(function()
				Sounds.DryerSound:Play()
				local Rate = (1 / 60)
				local MaxDuration = 2
				local StartTime = tick()
				if ToolUnequipped then
					ToolUnequipped:disconnect()
				end
				local CurrentlyEquipped = true
				ToolUnequipped = Tool.Unequipped:connect(function()
					CurrentlyEquipped = false
				end)
				while MouseDown and ToolEquipped and CheckIfAlive() and (tick() - StartTime) < MaxDuration do
					local TargetPos = InvokeClient("MousePosition")
					if TargetPos then
						TargetPos = TargetPos.Position
						Spawn(function()
							for i = 1, math.random(2, 3) do
								if CurrentlyEquipped then
									local Direction = (TargetPos - Handle.Position).unit
									local Offset = Vector3.new(
										((math.random() - 0.5) * 0.3),
										((math.random() - 0.5) * 0.3),
										((math.random() - 0.5) * 0.3)
									)
									Fire(Vector3.new((Direction.X + Offset.X), (Direction.Y + Offset.Y), (Direction.Z + Offset.Z)))
									wait(0.1)
								end
							end
						end)
					end
					wait(Rate)
				end
				Sounds.DryerSound:Stop()
				Tool.Enabled = false
				wait(1)
				Tool.Enabled = true
			end)
		elseif not Down and MouseDown then
			MouseDown = false
		end
	end
end)
Tool.Equipped:connect(Equipped)
Tool.Unequipped:connect(Unequipped)]]
	elseif v.Name == "AirScript" then
		source = [[--Rescripted by Luckymaxer
--Updated for R15 avatar by StarWars
Part = script.Parent
Players = game:GetService("Players")
Debris = game:GetService("Debris")
Creator = Part:FindFirstChild("Creator")
function IsTeamMate(Player1, Player2)
	return (Player1 and Player2 and not Player1.Neutral and not Player2.Neutral and Player1.TeamColor == Player2.TeamColor)
end
function TagHumanoid(humanoid, player)
	local Creator_Tag = Instance.new("ObjectValue")
	Creator_Tag.Name = "creator"
	Creator_Tag.Value = player
	Debris:AddItem(Creator_Tag, 2)
	Creator_Tag.Parent = humanoid
end
function UntagHumanoid(humanoid)
	for i, v in pairs(humanoid:GetChildren()) do
		if v:IsA("ObjectValue") and v.Name == "creator" then
			v:Destroy()
		end
	end
end
function Touched(Hit)
	if not Hit or not Hit.Parent then
		return
	end
	local character = Hit.Parent
	if character:IsA("Hat") then
		character = character.Parent
	end
	for i, v in pairs(character:GetChildren()) do
		if v:IsA("ForceField") then
			return
		end
	end
	local humanoid = character:FindFirstChild("Humanoid")
	if not humanoid or humanoid.Health == 0 then
		return
	end
	local CreatorPlayer = (((Creator and Creator.Value and Creator.Value:IsA("Player")) and Creator.Value) or nil)
	local player = Players:GetPlayerFromCharacter(character)
	if CreatorPlayer and player and (CreatorPlayer == player or IsTeamMate(CreatorPlayer, player)) then
		return
	end
	local torso = character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
	if not torso then
		return
	end
	local WindEffect = torso:FindFirstChild("WindEffect")
	if WindEffect then
		return
	end
	local Direction = Part.Velocity.unit
	local WindEffect = Instance.new("BodyVelocity")
	WindEffect.Name = "WindEffect"
	WindEffect.maxForce = Vector3.new(1e7, 1e7, 1e7)
	WindEffect.P = 125
	WindEffect.velocity = ((Direction * 75) + Vector3.new(0, 30, 0))
	Debris:AddItem(WindEffect, 0.5)
	WindEffect.Parent = torso
	Debris:AddItem(Part, 0)
	Part:Destroy()
end
Part.Touched:connect(Touched)
Debris:AddItem(Part, 2)]]
	elseif v.Parent:FindFirstChild("R15CoastingPose") then
		source = [[--Rescripted by Luckymaxer
--Made by Stickmasterluke
--// Fixed for R15 avatars by StarWars
-- Fixed for mobile support by Luke, again
Tool = script.Parent
Handle = Tool:WaitForChild("Handle")
Mesh = Handle:WaitForChild("Mesh")
local Cloud
Players = game:GetService("Players")
Debris = game:GetService("Debris")
BasePart = Instance.new("Part")
BasePart.Shape = Enum.PartType.Block
BasePart.Material = Enum.Material.Plastic
BasePart.TopSurface = Enum.SurfaceType.Smooth
BasePart.BottomSurface = Enum.SurfaceType.Smooth
BasePart.FormFactor = Enum.FormFactor.Custom
BasePart.Anchored = false
BasePart.Locked = true
BasePart.CanCollide = true
Sounds = {
	Wind = Handle:WaitForChild("Wind")
}
BaseScale = Vector3.new(3, 3, 3)
Rate = (1 / 60)
Flying = false
ToolEquipped = false
ServerControl = (Tool:FindFirstChild("ServerControl") or Instance.new("RemoteFunction"))
ServerControl.Name = "ServerControl"
ServerControl.Parent = Tool
ClientControl = (Tool:FindFirstChild("ClientControl") or Instance.new("RemoteFunction"))
ClientControl.Name = "ClientControl"
ClientControl.Parent = Tool
Mesh.Scale = BaseScale
Handle.Transparency = 0
Tool.Enabled = true
function RemoveFlyStuff()
	for i, v in pairs(Tool:GetChildren()) do
		if v:IsA("BasePart") and v.Name == "EffectCloud" then
			v:Destroy()
		end
		for i, v in pairs(Sounds) do
			v:Stop()
		end
	end
end
function CheckIfAlive()
	return (((Player and Player.Parent and Humanoid and Humanoid.Parent and Humanoid.Health > 0 and Torso and Torso.Parent) and true) or false)
end
function Equipped()
	Character = Tool.Parent
	Player = Players:GetPlayerFromCharacter(Character)
	Humanoid = Character:FindFirstChild("Humanoid")
	Torso = Character:FindFirstChild("HumanoidRootPart")
	if not CheckIfAlive() then
		return
	end
	spawn(function()
		Handle.Transparency = 0
		RemoveFlyStuff()
	end)
	Flying = false
	ToolEquipped = true
end
function Unequipped()
	Handle.Transparency = 0
	RemoveFlyStuff()
	Flying = false
	ToolEquipped = false
end
function OnServerInvoke(player, mode, value)
	if player ~= Player or not value or not CheckIfAlive() or not ToolEquipped then
		return
	end
	print(mode)
	if mode == "Fly" then
		local Fly = value.Flying
		Flying = Fly
		if Cloud and Cloud.Parent then
			Cloud:Destroy()
		end
		Handle.Transparency = ((Flying and 1) or 0)
		if Flying then
			Cloud = Handle:Clone()
			Cloud.Name = "EffectCloud"
			Cloud.Transparency = 0
			Cloud.CanCollide = false
			--[[local Wind = Cloud:FindFirstChildOfClass("Sound")
			if Wind then
				Wind:Play()
			end]
		local Smoke = Cloud:FindFirstChild("Smoke")
		if Smoke then
			Smoke.Enabled = true
		end
		local Weld = Instance.new("Weld")
		Weld.Part0 = Torso
		Weld.Part1 = Cloud
		Weld.C0 = (CFrame.new(1, -4, 0) * CFrame.Angles(0, (math.pi / 2), 0))
		Weld.C1 = CFrame.new(0, 0, 0)
		Weld.Parent = Cloud
		Cloud.Parent = Tool
		return Cloud
	end
	elseif mode == "SetSound" then
	if Sounds.Wind then
		--print("Changing Sound")
		Sounds.Wind.Pitch = ((value * 2) + 1)
		Sounds.Wind.Volume = (value + 0.1)
	end

elseif mode == "SetMesh" then
	local CloudMesh = Cloud:FindFirstChildOfClass("SpecialMesh")
	if Cloud and CloudMesh then
		print("Changing Mesh")
		CloudMesh.Scale = Vector3.new(4, 4, (4 + (value * 4)))
	end

elseif mode == "ToggleSound" then
	local Sound = Sounds.Wind
	local Playing = value
	if not Sound then
		return
	end
	if Playing then
		Sound:Play()
	else
		Sound:Stop()
	end
end
end
function InvokeClient(Mode, Value)
	local ClientReturn = nil
	pcall(function()
		ClientReturn = ClientControl:InvokeClient(Player, Mode, Value)
	end)
	return ClientReturn
end
for i, v in pairs(Tool:GetChildren()) do
	if v:IsA("BasePart") and v ~= Handle then
		v:Destroy()
	end
end
ServerControl.OnServerInvoke = OnServerInvoke
Tool.Equipped:Connect(Equipped)
Tool.Unequipped:Connect(Unequipped)]]
	elseif v.Name == "SpeedEffect" then
		source = [[-- assume we are in the character, let's check
function sepuku()
	script.Parent = nil
end
local debris = game:GetService("Debris")
local h = script.Parent:FindFirstChild("Humanoid")
if (h == nil) then sepuku() end
local torso = script.Parent:FindFirstChild("Torso") or script.Parent:FindFirstChild("UpperTorso")
if (torso == nil) then sepuku() end
local head = script.Parent:FindFirstChild("Head")
if (head == nil) then head = torso end
local equalizingForce = 236 / 1.2 -- amount of force required to levitate a mass
local gravity = .75 -- things float at > 1
local fire = Instance.new("Fire")
fire.Parent = head
fire.Heat = 10
fire.Size = 3
function recursiveGetLift(node)
	local m = 0
	local c = node:GetChildren()
	if (node:FindFirstChild("Head") ~= nil) then head = node:FindFirstChild("Head") end -- nasty hack to detect when your parts get blown off
	for i=1,#c do
		if c[i].className == "Part" then
			if (head ~= nil and (c[i].Position - head.Position).magnitude < 10) then -- GROSS
				if c[i].Name == "Handle" then
					m = m + (c[i]:GetMass() * equalizingForce * 1) -- hack that makes hats weightless, so different hats don't change your jump height
				else
					m = m + (c[i]:GetMass() * equalizingForce * gravity)
				end
			end
		end
		m = m + recursiveGetLift(c[i])
	end
	return m
end
function jumpIt()
	local mass = recursiveGetLift(h.Parent)
	local force = Instance.new("BodyForce")
	force.force = Vector3.new(0,mass * 2,0)
	force.Parent = torso
	debris:AddItem(force,0.5)
end
local con = h.Jumping:connect(jumpIt)
local oldSpeed = h.WalkSpeed
h.WalkSpeed = h.WalkSpeed * 1.6
local oldMaxHealth = h.MaxHealth
h.MaxHealth = oldMaxHealth * 1.5
h.Health = h.MaxHealth
local bodySpin = Instance.new("BodyAngularVelocity")
bodySpin.P = 200000
bodySpin.angularvelocity = Vector3.new(0,15,0)
bodySpin.maxTorque = Vector3.new(bodySpin.P,bodySpin.P,bodySpin.P)
bodySpin.Parent = torso
wait(30)
fire:Destroy()
h.WalkSpeed = oldSpeed
h.MaxHealth = oldMaxHealth
if h.Health > 60 then
	h.Health = 60
end
con:disconnect()
bodySpin:Destroy()
sepuku()]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("Lobby") and v.Parent:FindFirstChild("Lobby"):IsA("SpawnLocation") then
		source = [[local Players=game:GetService("Players")
local plrFromChar=Players.GetPlayerFromCharacter
local BadgeService=game:GetService("BadgeService")
local Lobby=script.Parent
local BadgeId=2124450213

for i,v in pairs(Lobby:GetChildren()) do
	if v:IsA("BasePart") then
		if v.Name=="Wall" then
			v.Touched:Connect(function(part)
				local c=part:FindFirstAncestorWhichIsA("Model")
				if c then
					local p=plrFromChar(Players,c)
					if p then
						BadgeService:AwardBadge(p.UserId,BadgeId)
					end
				end
			end)
		end
	end
end]]
	elseif v.Name == "Kill" and v.Parent.Name == "Baseplate" then
		source = [[script.Parent.Touched:connect(function(Part)
	if Part.Parent then
		local h=Part.Parent:FindFirstChild("Humanoid")
		if h then
			h:TakeDamage(h.MaxHealth) -- forcefielded people can pass through
		end
	end
end)
]]
	elseif v.Name == "onDied" and v.Parent:FindFirstChildOfClass("Humanoid") then
		source = [[local char=script.Parent
local humanoid=char:WaitForChild("Humanoid")
local hrp=char:WaitForChild("HumanoidRootPart")
local Alive = true -- since it's copied to the player everytime, everytime this script will run the player will be alive
local BadgeId=2124444600
local GroupService=game:GetService("GroupService")
local BadgeService=game:GetService("BadgeService")

humanoid.Died:connect(function()
	if Alive == true then -- if the player is alive
		Alive = false -- then don't let it fire multiple times
		wait(0.25) -- sometimes the explosion creator values are given after death, so this wait time allows those values to be provided before checking for a creator value (line 12)
		local player=game.Players:GetPlayerFromCharacter(char)
		local WOs=player.leaderstats.WOs
		local KOs=player.leaderstats.KOs
		local killer=humanoid:FindFirstChild("creator")
		
		WOs.Value=WOs.Value+1
		if killer then
			print(humanoid.Parent.Name.." was killed by "..killer.Value.Name.."!")
			if player~=killer.Value then
				killer.Value.leaderstats.KOs.Value=killer.Value.leaderstats.KOs.Value+1
				pcall(function()
					if player.Name==GroupService:GetGroupInfoAsync(game.CreatorId).Owner.Name then
						if not BadgeService:UserHasBadgeAsync(killer.Value.UserId,BadgeId) then
							BadgeService:AwardBadge(killer.Value.UserId,BadgeId)
						end
					end
				end)
			end
		end
		local x=workspace:GetDescendants()
		for i=1,#x do
			if x[i].Name=="GameValues" then
				local y=x[i].Teams:GetChildren()
				for s=1,#y do
					if y[s].Value==player.TeamColor then
						if y[s].Spawns.Value==0 then
							player.TeamColor=BrickColor.new(1001)
							game.ReplicatedStorage.Remotes.ChangeTeam:FireClient(player,player.TeamColor)
							player:WaitForChild("AntiTeamKill",5).Value=false
						end
					end
				end
			end
		end
		wait(1) -- -0.5 because of line 7
		player:LoadCharacter()
	end
end)

humanoid.ChildAdded:connect(function(Obj)
	if Obj.Name=="creator" then
		wait(.5)
		Obj:Destroy()
	end
end)

hrp.ChildAdded:connect(function(Obj)
	if Obj:IsA("BodyMover") then
		wait(.5)
		Obj:Destroy()
	end
end)]]
	elseif v.Parent:FindFirstChild("RocketDestroyEvent") then
		source = [[local Rocket = Instance.new("Part")
Rocket.Locked = true
Rocket.BackSurface = 3
Rocket.BottomSurface = 3
Rocket.FrontSurface = 3
Rocket.LeftSurface = 3
Rocket.RightSurface = 3
Rocket.TopSurface = 3
Rocket.Size = Vector3.new(1,1,4)
Rocket.BrickColor = BrickColor.new(23)
Rocket.CanCollide = false

local ModFx=require(game.ReplicatedStorage.Other)
local Tool=script.Parent
local Reload_Enabled=false --Go to StarterPlayer.StarterPlayerScripts.LocalScript for an explnation of why this works
--local Player=ModFx.GetPlayerFromTool(Tool) --[[This will be refreshed throughout the script 
--											so that if someone wanted to make the tools 
--											droppable, itd work with other players	]
		-- commented cause its useless as a global variable, however not deleted so as to keep the above comments
		local ColSer=game:GetService("CollectionService")
		local Debris=game:GetService("Debris")

		local function FireWep(plr,targetPos)
			if Tool.Enabled==false then return end
			local Player=ModFx.GetPlayerFromTool(Tool)
			if plr~=Player then return end
			local c=plr.Character
			if not c then return end
			local h=c:FindFirstChildWhichIsA("Humanoid")
			local plrTool=c:FindFirstChildWhichIsA("Tool")
			local Head=c:FindFirstChild("Head")
			if not Head or not plrTool or not h then return end
			if plrTool~=Tool then return end
			if h.Health<=0 then return end

			Tool.Enabled=false

			local dir = targetPos - Head.Position
			dir = dir*(1/dir.magnitude)

			local pos = Head.Position + (dir * 8)
			local ad=5000

			local missile = Rocket:clone()
			missile.Name="Rocket"

			local BV=Instance.new("BodyVelocity")
			BV.Parent=missile
			BV.P=12500
			BV.MaxForce=Vector3.new(ad,ad,ad)
			BV.Velocity=dir*60
			missile.CFrame = CFrame.new(pos,  pos + dir)

			local creator_tag = Instance.new("ObjectValue")
			creator_tag.Value = plr
			creator_tag.Name = "creator"
			creator_tag.Parent = missile

			local exp=Tool.Handle.exp:Clone()
			exp.PlaybackSpeed=math.random(90,110)/100
			exp.PlayOnRemove=true
			exp.Parent=missile

			local swoosh=Tool.Handle.swoosh:Clone()
			swoosh.PlaybackSpeed=math.random(95,105)/100
			swoosh.Parent=missile

			missile.Parent = workspace
			ColSer:AddTag(missile,missile.Name) 
			ColSer:AddTag(missile,plr.Name)
			missile:SetNetworkOwner(plr)
			swoosh:Play()

			local effect=plr:FindFirstChild("Effect")
			if effect and effect.Value~="None" then
				if effect.Value=="Fire" then
					Instance.new("Fire",missile)
				else
					spawn(function()
						require(game:GetService("ReplicatedStorage").TrailModule).AddTrail(missile,effect.Value,.5,.5,1)
					end)
				end
			end
			Debris:AddItem(missile,10)
			if Reload_Enabled then
				wait(7)
			end
			Tool.Enabled=true
		end

		Tool.Fire.OnServerEvent:Connect(FireWep)

		local function DestroyRocket(plr,Obj,ClientPos)
			local x=true
			local succ,err=pcall(function() 
				if Obj:GetNetworkOwner()~=plr then x=false end 
			end) 
			if err then warn(plr.Name.." may be exploiting") return end -- Not sure how this would happen.
			if x==false then warn(plr.Name.." is definitely exploiting") --[[plr:Kick("Possible exploit detected")] return end
			local ServerPos=Obj.Position
			local creator=Obj:FindFirstChild("creator")
			local CreatorValue
			if creator then
				CreatorValue=creator.Value
			end
			local Player=ModFx.GetPlayerFromTool(Tool)
			if CreatorValue~=nil and CreatorValue==plr and Player and Player==plr and (ServerPos - ClientPos).magnitude < 20 and ColSer:HasTag(Obj,Obj.Name) 
				and ColSer:HasTag(Obj,plr.Name) then -- all these to ensure that it's a rocket, and its their rocket, and its from their tool
				-- "(ServerPos - ClientPos).magnitude" = the distance between the serverside and clientside missile on hit
				Obj:ClearAllChildren()
				Debris:AddItem(Obj,0)
				ModFx.Explosion(CreatorValue,"Rocket",ClientPos)
			end
		end

		Tool.RocketDestroyEvent.OnServerEvent:connect(DestroyRocket)]]
	elseif v.Name == "Script" and v.Parent.Name == "Slingshot" then
		source = [[local Debris = game:GetService("Debris")
local ball = script.Parent
local damage = 8
local Players=game.Players
local plrFromChar=Players.GetPlayerFromCharacter

local function tagHumanoid(humanoid)
	local tag = ball:FindFirstChild("creator")
	if not tag then return end
	local hc=humanoid:FindFirstChild("creator")
	if hc then
		Debris:AddItem(hc,0)
	end
	local new_tag = tag:Clone()
	new_tag.Parent = humanoid
	Debris:AddItem(new_tag,1)
end

local function Kill(p1,p2)
	if not p1 or not p2 then return true end
	local ATK=p1:FindFirstChild("AntiTeamKill")
	local eATK=p2:FindFirstChild("AntiTeamKill")
	if not ATK or not eATK then return true end
	if ATK.Value==false or eATK.Value==false then return true end
	if p1.Neutral==true or p2.Neutral==true then return true end
	if p1.Team==p2.Team then return false end
end

local function onTouched(hit)
	
	local creator=ball:FindFirstChild("creator")
	if not creator then return end
	local p=creator.Value
	if not p then return end
	local c=creator.Value.Character
	if not c then return end
	local h=c:FindFirstChild("Humanoid")
	if not h then return end
	local humanoid=hit.Parent:FindFirstChild("Humanoid")
	
	if humanoid then

		if humanoid==h then return end
		if Kill(p,plrFromChar(Players,humanoid.Parent))==false then return end
		
		tagHumanoid(humanoid)
		humanoid:TakeDamage(damage)

		return
	end
	damage = damage / 2 -- this doesnt execute if a humanoid exists
	if damage > 1 then
		return
	end
	connection:disconnect()
	Debris:AddItem(ball,0)
end

connection = ball.Touched:connect(onTouched)

r = game:GetService("RunService")
t, s = r.Stepped:wait()
d = t + 2.0 - s
while t < d do
	t = r.Stepped:wait()
end

ball:ClearAllChildren()
Debris:AddItem(ball,0)]]
	elseif v.Name == "Server" and v.Parent.Name == "Slingshot" then
		source = [[local Pellet = Instance.new("Part")
Pellet.Name="Pellet"
Pellet.Locked = true
Pellet.BackSurface = 0
Pellet.BottomSurface = 0
Pellet.FrontSurface = 0
Pellet.LeftSurface = 0
Pellet.RightSurface = 0
Pellet.TopSurface = 0
Pellet.Shape = 0
Pellet.Size = Vector3.new(1,1,1)
Pellet.BrickColor = BrickColor.new(2)

local ModFx=require(game.ReplicatedStorage.Other)
local Tool=script.Parent
local Reload_Enabled=false

local VELOCITY = 85 -- constant

local function FireWep(plr,targetPos)
	if Tool.Enabled==false then return end
	if ModFx.GetPlayerFromTool(Tool)~=plr then return end
	local c=plr.Character
	if not c then return end
	local h=c:FindFirstChildWhichIsA("Humanoid")
	local plrTool=c:FindFirstChildWhichIsA("Tool")
	local torso=c:FindFirstChild("HumanoidRootPart")
	local head=c:FindFirstChild("Head")
	if not h or not plrTool or not torso or not head then return end
	if plrTool~=Tool then return end
	if h.Health<=0 then return end
	
	Tool.Enabled=false
	
	local dir=targetPos-head.Position
	--start confusing stuff
	dir=dir*(1/dir.magnitude)
	local launch=torso.Position+(5*dir)
	local delta = targetPos - launch
	local dy = delta.y
	local new_delta = Vector3.new(delta.x, 0, delta.z)
	delta = new_delta

	local dx = delta.magnitude
	local unit_delta = delta.unit
	
	local function computeLaunchAngle(dx,dy,grav)
		local g = math.abs(grav)
		local inRoot = (VELOCITY^4) - (g*(g*(dx^2) + (2*dy)*(VELOCITY^2)))
		if inRoot <= 0 then
			return math.pi/4
		end
		local root = math.sqrt(inRoot)
		local inATan1 = ((VELOCITY^2) + root) / (g*dx)
	
		local inATan2 = ((VELOCITY^2) - root) / (g*dx)
		local answer1 = math.atan(inATan1)
		local answer2 = math.atan(inATan2)
		if answer1 < answer2 then return answer1 end
		return answer2
	end
	
	local theta = computeLaunchAngle(dx, dy, workspace.Gravity)

	local vy = math.sin(theta)
	local xz = math.cos(theta)
	local vx = unit_delta.x * xz
	local vz = unit_delta.z * xz	
	
	local vel=Vector3.new(vx,vy,vz) * VELOCITY
	--end confusing stuff
	local missile = Pellet:clone()
	missile.Position=launch
	missile.Velocity=vel
	missile.Parent = workspace
	missile:SetNetworkOwner(plr)
	
	local creator_tag = Instance.new("ObjectValue")
	creator_tag.Value = plr
	creator_tag.Name = "creator"
	creator_tag.Parent = missile
	
	local damage_value=Instance.new("IntValue")
	damage_value.Value=8
	damage_value.Name="damage"
	damage_value.Parent=missile
	
	local l=Tool.Handle.Sound:Clone()
	l.Parent=Tool.Handle
	l:Play()
	l.Ended:connect(function()
		l:Destroy()
	end)
	
	local newscript=Tool.Script:Clone()
	newscript.Parent=missile
	newscript.Disabled=false
	
	if Reload_Enabled then
		wait(0.2)
	end
	Tool.Enabled=true
end

Tool.Fire.OnServerEvent:Connect(FireWep)]]
	elseif v.Name == "Script" and v.Parent.Name == "Superball" then
		source = [[local Debris = game:GetService("Debris")
local ball = script.Parent
local damage = 55
local r = game:GetService("RunService")
local last_sound_time=r.Stepped:wait()
local Players=game.Players
local plrFromChar=Players.GetPlayerFromCharacter

local function tagHumanoid(humanoid)
	local tag = ball:FindFirstChild("creator")
	if not tag then return end
	local hc=humanoid:FindFirstChild("creator")
	if hc then
		Debris:AddItem(hc,0)
	end
	local new_tag = tag:Clone()
	new_tag.Parent = humanoid
	Debris:AddItem(new_tag,1)
end

local function Kill(p1,p2)
	if not p1 or not p2 then return true end
	local ATK=p1:FindFirstChild("AntiTeamKill")
	local eATK=p2:FindFirstChild("AntiTeamKill")
	if not ATK or not eATK then return true end
	if ATK.Value==false or eATK.Value==false then return true end
	if p1.Neutral==true or p2.Neutral==true then return true end
	if p1.Team==p2.Team then return false end
end

local function onTouched(hit)
	local now = r.Stepped:wait()
	if now - last_sound_time <= .1 then return end--[[ this seems to be a debounce that doesnt allow the 	
											sound to play more than once during a 0.1s interval]
		last_sound_time = now
		if ball.Boing.Playing==false then
			ball.Boing.PlaybackSpeed=math.random(85,115)/100
			ball.Boing:play()
		end

		local creator=ball:FindFirstChild("creator")
		if not creator then return end
		local p=creator.Value
		if not p then return end
		local c=creator.Value.Character
		if not c then return end
		local h=c:FindFirstChild("Humanoid")
		if not h then return end
		local humanoid=hit.Parent:FindFirstChild("Humanoid")

		if humanoid then
			if humanoid==h then return end
			if Kill(p,plrFromChar(Players,humanoid.Parent))==false then return end
			tagHumanoid(humanoid)
			humanoid:TakeDamage(damage)
			return
		end
		damage = damage / 2 -- this doesnt execute if a humanoid exists
		if damage > 2 then
			return
		end
		connection:disconnect()
		Debris:AddItem(ball,0)
	end

	connection = ball.Touched:connect(onTouched)

	t, s = r.Stepped:wait()
	d = t + 2.0 - s
	while t < d do
		t = r.Stepped:wait()
	end

	ball:ClearAllChildren()
	Debris:AddItem(ball,0)]]
	elseif v.Name == "Server" and v.Parent.Name == "Superball" then
		source = [[local missile = Instance.new("Part")
missile.Size = Vector3.new(2,2,2)
missile.Shape = 0
missile.BottomSurface = 0
missile.TopSurface = 0 
missile.Name = "Cannon Shot"
missile.Elasticity = 1
missile.Reflectance = .2
missile.Friction = 0

local ModFx=require(game.ReplicatedStorage.Other)
local TrailFx=require(game.ReplicatedStorage.TrailModule)
local Tool=script.Parent
local Reload_Enabled=false
local Debris=game:GetService("Debris")

local function FireWep(plr,targetPos)
	if Tool.Enabled==false then return end
	local Player=ModFx.GetPlayerFromTool(Tool)
	if plr~=Player then return end
	local c=plr.Character
	if not c then return end
	local h=c:FindFirstChildWhichIsA("Humanoid")
	local Head=c:FindFirstChild("Head")
	local plrTool=c:FindFirstChildWhichIsA("Tool")
	if not h or not Head or not plrTool then return end
	if plrTool~=Tool then return end
	if h.Health<=0 then return end
	
	Tool.Enabled=false
	
	local lookAt=(targetPos - Head.Position).unit
	local spawnPos=Head.Position
	spawnPos=spawnPos+(lookAt*5)
	
	local missile2 = missile:Clone()
	missile2.BrickColor = BrickColor.Random()
	missile2.Position = spawnPos
	missile2.Velocity = (lookAt*200)
	missile2.Parent = workspace
	missile2:SetNetworkOwner(plr)
	Tool.Handle.Boing:Play()
	
	local creator_tag = Instance.new("ObjectValue")
	creator_tag.Value = plr
	creator_tag.Name = "creator"
	creator_tag.Parent = missile2
	
	local newscript=Tool.Script:Clone()
	newscript.Parent=missile2
	newscript.Disabled=false
	
	local l=Tool.Handle.Boing:Clone()
	l.Parent=missile2
	
	local effect=plr:FindFirstChild("Effect")
	if effect and effect.Value~="None" then
		if effect.Value=="Fire" then
			Instance.new("Fire",missile2)
		else
			spawn(function()
				TrailFx.AddTrail(missile2,effect.Value,1,.4,1)
			end)
		end
	end
	Debris:AddItem(missile2,5)
	if Reload_Enabled then
		wait(2)
	end
	Tool.Enabled=true
end

Tool.Fire.OnServerEvent:Connect(FireWep)
]]
	elseif v.Name == "Server" and v.Parent.Name == "Sword" then
		source = [[local Tool=script.Parent
local Reload_Enabled=false
local Damage=Tool:WaitForChild("damage")
local sword=Tool:WaitForChild("Handle")
local r = game:service("RunService")

local base_damage = 5
local slash_damage = 10
local lunge_damage = 30

local ModFx=require(game.ReplicatedStorage.Other)
local Player=ModFx.GetPlayerFromTool(Tool)

local trails={
	["Rainbow"]=function()
		return game.ServerStorage.Trails.RainbowKeypoints.Color
	end,
	["RisingSun"]=function()
		return game.ServerStorage.Trails.RisingSunKeypoints.Color
	end,
	["Arctic"]=function()
		return game.ServerStorage.Trails.ArcticKeypoints.Color
	end,
	["TeamColor"]=function()
		return ColorSequence.new(Player.TeamColor.Color)
	end,
	["Fire"]=function()
		sword.Trail.Enabled=false -- just in case
		for i,v in pairs(sword:GetChildren()) do
			if v:IsA("Attachment") then
				Instance.new("Fire",v)
			end
		end
	end
}

local function swordUp()
	Tool.GripForward = Vector3.new(-1,0,0)
	Tool.GripRight = Vector3.new(0,1,0)
	Tool.GripUp = Vector3.new(0,0,1)
end

local function swordOut()
	Tool.GripForward = Vector3.new(0,0,1)
	Tool.GripRight = Vector3.new(0,-1,0)
	Tool.GripUp = Vector3.new(-1,0,0)
end

local function IsEffect(str)
	local a=false
	for i,v in pairs(trails) do
		if str==i then
			a=true
		end
	end
	return a
end

local function applyTrail(typ)
	if IsEffect(typ)==false then
		return
	end
	if typ=="Fire" then
		trails[typ]()
	else
		sword.Trail.Enabled=true
		sword.Trail.Color=trails[typ]()
	end
end

local function removeTrail()
	sword.Trail.Enabled=false
	for i,v in pairs(sword:GetChildren()) do
		if v:IsA("Attachment") then
			v:ClearAllChildren()
		end
	end
end

local function dmg(humanoid,me,ePlayer)
	humanoid:TakeDamage(Tool.damage.Value) -- cover all humanoids, npc or other
	if ePlayer then
		if 	(not humanoid:FindFirstChild("creator")) and 
			me:FindFirstChild("leaderstats") then
			local creator = Instance.new("ObjectValue")
			creator.Value = me
			creator.Name = "creator"
			creator.Parent = humanoid
		end
		--humanoid:TakeDamage(Tool.damage.Value)
	end
end

sword.Touched:connect(function(hit)
	if hit.Parent then 
		local humanoid = hit.Parent:FindFirstChild("Humanoid")
		local vCharacter = Player.Character
		local hum = vCharacter:FindFirstChild("Humanoid")
		
		if humanoid and hum and humanoid~=hum and hum.Health>0 then
			local ePlayer = game.Players:GetPlayerFromCharacter(humanoid.Parent)
			if ePlayer then
				local ATK=Player:FindFirstChild("AntiTeamKill")
				if 	(ATK and ATK.Value==true) and
					(Player.Neutral==false and ePlayer.Neutral==false) and
					Player.TeamColor==ePlayer.TeamColor then
					return -- force-end the function
				end
				dmg(humanoid,Player,ePlayer)
			else
				dmg(humanoid,Player)
			end
		end

	end 
end)

local function attack(plr)
	Damage.Value=slash_damage
	sword.SwordSlash:Play()
	local anim = Instance.new("StringValue")
	anim.Name = "toolanim"
	anim.Value = "Slash"
	anim.Parent = Tool
	Damage.Value=base_damage
end

local function lunge(plr)

	local effect=Player:FindFirstChild("Effect")
	if effect then
		applyTrail(effect.Value)
	end
	sword.SwordLunge:Play()
	Damage.Value=lunge_damage
	local anim = Instance.new("StringValue")
	anim.Name = "toolanim"
	anim.Value = "Lunge"
	anim.Parent = Tool
	
	local vCharacter = Player.Character
	
	local force = Instance.new("BodyVelocity")
	force.velocity = Vector3.new(0,14.5,0) 
	force.maxForce = Vector3.new(0,5000,0)
	
	if Tool.Parent.Name~="Backpack" then
		force.Parent = vCharacter.HumanoidRootPart
	end	
	
	wait(.25)
	swordOut()
--	wait(.25)
--	force:Destroy() -- now in onDied
--	wait(.5)
	wait(.75)
	swordUp()
	removeTrail()
	Damage.Value=base_damage
end

Tool.Enabled = true
local last_attack = 0

Tool.Activated:connect(function()
	if Tool.Enabled==false then return end
	if Reload_Enabled then
		Tool.Enabled = false
	end
	local humanoid = Player.Character.Humanoid
	if not humanoid then
		return
	end
	local t = r.Stepped:wait()
	if humanoid.Health~=0 then
		if (t - last_attack < .2) then
			lunge()
		else
			attack()
		end
	end
	last_attack = t
	--wait(.5)
	Tool.Enabled = true
end)

Tool.Equipped:connect(function(mouse)
	sword.Unsheath:Play()
end)
]]
	elseif v.Name == "Server" and v.Parent:FindFirstChild("ResetTime") then
		source = [[local bomb = Instance.new("Part")
bomb.Size = Vector3.new(2,2,2)
bomb.BrickColor = BrickColor.new("Really black")
bomb.Shape = 0
bomb.BottomSurface = 0
bomb.TopSurface = 0
bomb.Name = "Bomb"
bomb.Locked = true

local ModFx=require(game.ReplicatedStorage.Other)
local Tool=script.Parent
local Reload_Enabled=false
--To change the blast radius, go to ReplicatedStorage.Other

local function FireWep(plr,cf) -- cant use .activated cause we need the camera orientation in localscript
	if Tool.Enabled==false then return end
	local Player=ModFx.GetPlayerFromTool(Tool)
	if plr~=Player then return end
	local c=plr.Character
	if not c then return end
	local h=c:FindFirstChildWhichIsA("Humanoid")
	local plrTool=c:FindFirstChildWhichIsA("Tool")
	if not h or not plrTool then return end
	if plrTool~=Tool then return end
	if h.Health<=0 then return end
	if plr:DistanceFromCharacter(cf.p)>30 then return end -- jan 11 2019 - changed from 20 to 30 studs
		
	Tool.Enabled=false
		
	local bomb2=bomb:Clone()
	
	local exp=Tool.Handle.exp:Clone()
	exp.PlaybackSpeed=math.random(90,110)/100
	exp.PlayOnRemove=true
	exp.Parent=bomb2
	
	local click=Tool.Handle.Click:Clone()
	click.PlaybackSpeed=math.random(95,105)/100
	click.Parent=bomb2
	
--	local creator_tag = Instance.new("ObjectValue") -- Don't need this anymore, as the module only needs the player value
--	creator_tag.Value = plr
--	creator_tag.Name = "creator"
--	creator_tag.Parent = bomb2
	
	bomb2.CFrame=cf
	bomb2.Parent=workspace.BombHolder
	
	game.ServerScriptService.b:Fire(plr,"Bomb",bomb2.Position,bomb2)
	
	if Reload_Enabled then
		wait(6)
	end
	
	Tool.Enabled=true
end

Tool.Fire.OnServerEvent:Connect(FireWep)]]
	elseif v.Parent.Name == "Trowel" then
		source = [[local wallHeight = 4
local brickSpeed = 0.04
local wallWidth = 12
local int=1

local ModFx=require(game.ReplicatedStorage.Other)
local Tool=script.Parent
local Reload_Enabled=false

local Player=ModFx.GetPlayerFromTool(Tool)

local effectTable={
	["RisingSun"]={
		BrickColor.new(21),
		BrickColor.new(106),
		BrickColor.new(333),
		BrickColor.new(24)
	},
	["Arctic"]={
		BrickColor.new(104),
		BrickColor.new(110--[[219]),
		BrickColor.new(213),
BrickColor.new(1013)
},
["TeamColor"]={
	Player.TeamColor,
}
}

local brick = Instance.new("Part")
brick.BottomSurface="Weld"
brick.Name="Trowel Wall"

local function snap(v)
	local absX=math.abs(v.x)
	local absZ=math.abs(v.z)
	if absX>absZ then
		return Vector3.new(v.x/absX,0,0)
	else
		return Vector3.new(0,0,v.z/absZ)
	end
end

local function placeBrick(cf, pos, color,f)
	local newbrick=brick:Clone()
	newbrick.BrickColor = color
	newbrick.CFrame = cf * CFrame.new(pos + newbrick.Size / 2)
	newbrick.Parent = f
	newbrick:MakeJoints()
	return newbrick, pos +  newbrick.Size
end


local function FireWep(plr,targetPos)	
	if Tool.Enabled==false then return end
	Player=ModFx.GetPlayerFromTool(Tool) -- refresh it
	if plr~=Player then return end
	local c=plr.Character
	if not c then return end
	local h=c:FindFirstChildWhichIsA("Humanoid") 
	if not h then return end
	if h.Health<=0 then return end
	local plrTool=c:FindFirstChildWhichIsA("Tool")
	if not plrTool then return end
	if plrTool~=Tool then return end
	if Reload_Enabled then
		Tool.Enabled=false
	end

	Tool.Handle.BuildSound:Play()
	local lookAt = snap((targetPos - plr.Character.Head.Position).unit)
	local cf = CFrame.new(targetPos, targetPos + lookAt)
	local color = BrickColor.Random()
	local bricks = {}

	local effect=plr:FindFirstChild("Effect")
	local fx=nil
	if effect and effect.Value and effectTable[effect.Value] then
		fx=effect.Value -- dont want people switching trails mid-build
	end

	assert(wallWidth>0)
	local y = 0
	local folder=Instance.new("Folder")
	folder.Name="WallHolder"
	folder.Parent=workspace
	game.Debris:AddItem(folder, 15) -- Roblox starts a coroutine outside the script, so no need to make your own cleanup scripts
	--game:GetService("CollectionService"):AddTag(folder,plr.Name)
	while y < wallHeight do
		if fx then
			for i,v in pairs(effectTable[fx]) do
				if int==i then
					color=v
				end
			end
			int=int+1
		end
		local p
		local x = -wallWidth/2
		while x < wallWidth/2 do
			local brick
			brick, p = placeBrick(cf, Vector3.new(x, y, 0), color, folder)
			x = p.x
			table.insert(bricks, brick)
			wait(brickSpeed)
		end
		y = p.y
	end
	int=1

	wait(5)
	Tool.Enabled=true
end

Tool.Fire.OnServerEvent:Connect(FireWep)]]
	elseif v.Name == "Amura Made This" then
		source = [[Amura initially made this island for Stickmasterluke's disaster game.
Props to him. ;D
]]
	elseif v.Name == "Weather Machine Power" then
		source = [[--Made by Stickmasterluke


local sp = script.Parent


--todo: steam particles form stacks
--todo: spinning turbine
--todo: adjustable speed of globespin
--todo: engine colors
--todo: tube colors

local powerLevelTag = sp:WaitForChild('PowerLevel')
local globeTag = sp:WaitForChild('Globe'):WaitForChild('SpinGlobeEnabled')
local screenFrame = sp:WaitForChild('Screen'):WaitForChild('SurfaceGui'):WaitForChild('TextLabelFull')
local tube1 = sp:WaitForChild('Tube1')
local tube2 = sp:WaitForChild('Tube2')
local engineColor = sp:WaitForChild('EngineColor')
local emitter1 = sp:WaitForChild('Stacks'):WaitForChild('Union1'):WaitForChild('ParticleEmitter')
local emitter2 = sp:WaitForChild('Stacks'):WaitForChild('Union2'):WaitForChild('ParticleEmitter')

local mainPart = sp:WaitForChild('MainPart')
local letterSorting = mainPart:WaitForChild('LetterSorting')
local powerDown = mainPart:WaitForChild('PowerDown')
local powerUpSound = mainPart:WaitForChild('PowerUpSound')


local engineColors = {
	[0] = 'Black',
	[1] = 'Pastel Blue',
	[2] = 'Pastel violet',
	[3] = 'Alder',
	[4] = 'Carnation pink',
	[5] = 'Persimmon',
	[6] = 'Bright red',
	[7] = 'Really red',
	[8] = 'Toothpaste',
	[9] = 'Lime green',
}

local lastValue = powerLevelTag.Value
function updateState()
	local val = powerLevelTag.Value
	if val > lastValue then
		powerUpSound:Play()
	end
	lastValue = val

	screenFrame.Text = tostring(val)

	tube1.BrickColor = BrickColor.new(val >= 1 and 'Cyan' or 'Light blue')
	tube2.BrickColor = BrickColor.new(val >= 3 and 'Cyan' or 'Light blue')
	engineColor.BrickColor = BrickColor.new(engineColors[val] or 'Institutional white')
	emitter2.Enabled = val >= 2
	emitter1.Enabled = val >= 4

	if val <= 0 then
		globeTag.Value = false
		powerDown:Play()
		letterSorting:Stop()
	else
		letterSorting.Pitch = val*.5
		letterSorting:Play()
		globeTag.Value = true
	end
end

updateState()

powerLevelTag.Changed:connect(updateState)


]]
	elseif v.Name == "OrbSpinyScript" then
		source = [[--Made by Stickmasterluke


local sp = script.Parent

local frame = sp:WaitForChild('Frame')
local spinGlobeValue = sp:WaitForChild('SpinGlobeEnabled')
random = math.random

local ringAVs = {}

for _,ring in pairs(sp:GetChildren()) do
	if ring.Name == 'SpinningRingUnion' then
		local bp = Instance.new('BodyPosition',ring)
		bp.maxForce = Vector3.new(1,1,1)*40000
		bp.Position = frame.Position
		local bav = Instance.new('BodyAngularVelocity',ring)
		ring.Anchored = false
		table.insert(ringAVs,bav)
	end
end

while true do
	wait(2)
	if spinGlobeValue.Value then
		for _,ringAV in pairs(ringAVs) do
			ringAV.AngularVelocity = Vector3.new(random(-2,2),random(-2,2),random(-2,2)) * 3
		end
	else
		for _,ringAV in pairs(ringAVs) do
			ringAV.AngularVelocity = Vector3.new(0,0,0)
		end
	end
end


]]
	elseif v.Parent.Name == "WaterLevel" then
		source = [[--Made by Stickmasterluke

sp=script.Parent
midhight=16
radius=4.5		--hight
wavetime=10		--seconds
shakeradius=6
phi=.618033988
a=0
while true do
	wait()
	a=a+1
	sp.CFrame=CFrame.new(math.sin((a/(wavetime*30/phi))*math.pi)*shakeradius,midhight+math.sin((a/(wavetime*30))*math.pi)*radius,math.sin((a/(wavetime*30*phi))*math.pi)*shakeradius)
end
]]
	elseif v.Name == "CompassScript" then
		source = [[
--


--todo:this could and should all be in a local script, with a bindable event

local sp = script.Parent
local event = game:GetService("ReplicatedStorage"):WaitForChild('Event')
local player = nil

local equipped = false
local equipCount = 0

sp.Equipped:connect(function()
	equipCount = equipCount + 1
	local thisEquip = equipCount
	equipped = true
	while equipped and thisEquip == equipCount do
		local character = sp.Parent
		player = game.Players:GetPlayerFromCharacter(character)
		if player then
			event:FireClient(player, 'OpenCompass')
		end
		wait(1)
	end
end)
sp.Unequipped:connect(function()
	equipped = false
	if player then
		event:FireClient(player, 'CloseCompass')
	end
end)


]]
	elseif v.Name == "BalloonScript" then
		source = [[--


local Tool = script.Parent
local handle=Tool:WaitForChild("Handle",5)
local upAndAway = false
local humanoid = nil
local head = nil
local upAndAwayForce=handle.BodyForce
isfloating=false

local equalizingForce = 236 / 1.2 -- amount of force required to levitate a mass
local gravity = 1.05 -- things float at > 1

local height = nil
local maxRise =  75

function float(lift)
	if not isfloating then
		isfloating=true
		while equipped do
			lift=recursiveGetLift(Tool.Parent)
			upAndAwayForce.force=Vector3.new(0,lift*.8,0)
			--if Tool.Handle.Position.y > height + maxRise then
			if Tool.Handle.Position.y>300 then
				equipped=false
				Tool.Handle.Pop:Play()
				Tool.GripPos=Vector3.new(0,-.4,0)
				Tool.Handle.Mesh.MeshId = "http://www.roblox.com/asset/?id=26725510"
			end
			for i=1,4 do
				updateBalloonSize()
				wait(1/20)
			end
		end
		upAndAwayForce.force=Vector3.new(0,0,0)
		isfloating=false
	end
end

function onEquipped()
	Tool.Handle.Mesh.MeshId="http://www.roblox.com/asset/?id=25498565"
	equipped = true
	--[[Tool.GripPos = Vector3.new(0,-1,0)
	Tool.GripForward = Vector3.new(0,1,0)
	Tool.GripRight = Vector3.new(0,0,-1)
	Tool.GripUp = Vector3.new(1,0,0)]
		Tool.Grip = CFrame.new(0,-1,0,0,1,0,0,0,-1,-1,0,0)
		local hrp = Tool.Parent:FindFirstChild('HumanoidRootPart')
		if hrp then
			height = hrp.Position.y
		else
			height = 0
		end
		lift=recursiveGetLift(Tool.Parent)
		float(lift)
	end

	function onUnequipped()
		equipped = false
	--[[Tool.GripForward = Vector3.new(1,0,0)
	Tool.GripRight = Vector3.new(0,0,1)
	Tool.GripUp = Vector3.new(0,1,0)]
		handle.Mesh.Scale = Vector3.new(1,1,1)
	end

	Tool.Unequipped:connect(onUnequipped)
	Tool.Equipped:connect(onEquipped)

	function recursiveGetLift(node)
		local m = 0
		local c = node:GetChildren()
		if (node:FindFirstChild("Head") ~= nil) then head = node:FindFirstChild("Head") end -- nasty hack to detect when your parts get blown off

		for i=1,#c do
			if c[i]:IsA("BasePart") then	
				if (head ~= nil and (c[i].Position - head.Position).magnitude < 10) then -- GROSS
					if c[i].Name == "Handle" then
						m = m + (c[i]:GetMass() * equalizingForce * 1) -- hack that makes hats weightless, so different hats don't change your jump height
					else
						m = m + (c[i]:GetMass() * equalizingForce * gravity)
					end
				end
			end
			m = m + recursiveGetLift(c[i])
		end
		return m
	end

	function updateBalloonSize()
		local range=(height+maxRise)-Tool.Handle.Position.y
	--[[if range<maxRise/3 then
		Tool.Handle.Mesh.Scale=Vector3.new(1,1,1)*2
	elseif range<maxRise*(2/3) then
		Tool.Handle.Mesh.Scale=Vector3.new(1,1,1)*1.5
	else
		Tool.Handle.Mesh.Scale=Vector3.new(1,1,1)
	end]
		Tool.Handle.Mesh.Scale=Vector3.new(1,1,1)*(2-math.min(1,math.max(0,range/maxRise)))
	end

--[[
while true do
	wait(1)
	script.Parent.Handle.BillboardGui.TextLabel1.Text = 'Server: '..tostring(script.Parent.Handle.BodyForce.force.Y)
	randomshade = .8+math.random()*.2
	script.Parent.Handle.BillboardGui.TextLabel1.BackgroundColor3 = Color3.new(randomshade,randomshade,randomshade)
end
]


	]]
	elseif v.Name == "AppleScript" then
		source = [[--Made by Stickmasterluke


local sp=script.Parent


local healamount=15
local extrawait=6

local handle=sp:WaitForChild('Handle',5)
local eatsound=handle:WaitForChild('EatSound',5)
local sparkles=handle:WaitForChild('Sparkles',5)
local event=sp:WaitForChild('Event')

local equipped=false
local check=true
local chr=nil
local h=nil
local plr=nil
local equipinstant=nil


sp.Activated:connect(function()
	if check and equipped and h and h.Health>0 then
		check=false
		event:FireClient(plr,'EatAnim')
		wait(1)
		if h.Health>0 and equipped then
			--print('Healing',h.Parent,h.Health,'to',h.Health+healamount)
			if h.Health < 100 then	--Will overheal without this check
				h:TakeDamage(-healamount)
			end
			--h.Health=h.Health+healamount
			if eatsound then
				eatsound:Play()
			end
		end
		wait(.62+extrawait)
		check=true
	end
end)

sp.Equipped:connect(function(mouse)
	equipped=true
	chr=sp.Parent
	plr=game.Players:GetPlayerFromCharacter(chr)
	h=chr:FindFirstChild('Humanoid')

	local myequipinstant={}
	equipinstant=myequipinstant
	wait(2)
	if equipped and myequipinstant==equipinstant then
		sparkles.Enabled=true
		wait(.3)
		sparkles.Enabled=false
	end
end)

sp.Unequipped:connect(function()
	equipped=false
end)


]]
	elseif v.Name == "Bounce" and v.Parent.Parent:FindFirstChild("SMallRailing") then
		source = [[function onTouched(part)
	if part.Parent ~= nil then
		local h = part.Parent:findFirstChild("Humanoid")
		local hrp = part.Parent:FindFirstChild('HumanoidRootPart')
		if h~=nil and hrp and h.Health > 0 then
			hrp.Velocity=Vector3.new(0,58,0)
			wait(0.5)
		end			
	end
end

script.Parent.Touched:connect(onTouched)
]]
	elseif v.Name == "Script" and v.Parent.Parent:FindFirstChild("MissileSystem1") then
		source = [[function onChildAdded(child)
	if child.Name == "SeatWeld" then
		child.C0 = CFrame.new(0,(script.Parent.Size.y/2 + 1.5),0)
		child.C1 = CFrame.new(0,0,0)
	end
end

script.Parent.ChildAdded:connect(onChildAdded)]]
	elseif v.Name == "Script" and v.Parent.Parent:FindFirstChild("TopSeat") then
		source = [[--Made by Stickmasterluke
]]
	elseif v.Name == "MusicScript" and v.Parent.Name == "Music" and v.Parent:IsA("Sound") then
		source = [[--


local sp = script.Parent

wait(5)

sp:Play()
]]
	elseif v.Name == "FountianScript" then
		source = [[--Made by Stickmasterluke
	--OLD CODE


local sp = script.Parent

local debris = game:GetService("Debris")

local baseupvelocity = 40
local variety = 15
local colors = {"Bright blue", "Medium blue", "Pastel Blue"}

local originalPosition = Vector3.new(0,0,0)


wait(1)
if sp and sp.Parent then
	originalPosition = sp.Position
end

while sp and sp.Parent and ((sp.Position-originalPosition).magnitude<2) do
	local p = Instance.new("Part")
	p.Name = "FountainWater"
	p.formFactor = "Symmetric"
	p.Shape = "Ball"
	p.Material = 'Foil'
	p.Transparency = .5
	if math.random()<.5 then
		p.CanCollide = false
	end
	p.Size = Vector3.new(1,1,1)
	p.BrickColor = BrickColor.new(colors[math.random(1,#colors)])
	p.TopSurface = "Smooth"
	p.BottomSurface = "Smooth"
	p.CFrame = CFrame.new(sp.Position+Vector3.new(0,1.5,0))
	p.Velocity = Vector3.new((math.random()-.5)*variety,baseupvelocity+((math.random()-.5)*variety),(math.random()-.5)*variety)
	p.RotVelocity = Vector3.new((math.random()-.5)*variety,(math.random()-.5)*variety,(math.random()-.5)*variety)
	p.Elasticity = 0
	p.Friction = 1
	debris:AddItem(p, 2.5)
	p.Parent = sp
	wait(.2+(math.random()*.1))
end



]]
	elseif v.Name == "HammerGame" and v.Parent.Name == "HammerGame" then
		source = [[--Made by Stickmasterluke


local sp = script.Parent

local button = sp:WaitForChild('Button')

local debounce = false

button.Touched:connect(function(hit)
	if hit and hit.Parent and not debounce and button and button.Velocity.magnitude == 0 then
		local strength = math.abs(hit.Velocity.y)
		local hitSound = button:FindFirstChild('HitSound')
		if strength > 10 and hitSound then
			hitSound:Play()
		end
		wait(.1)
		if strength > 65 then
			debounce = true
			local bell = sp:FindFirstChild('Bell')
			if bell then
				local bellSound = bell:FindFirstChild('BellSound')
				if bellSound then
					bellSound:Play()
				end
				local bellMesh = bell:FindFirstChild('Mesh')
				if bellMesh then
					bellMesh.Scale = Vector3.new(1.25,1.25,1.25)
				end
				wait(1)
				if bellMesh then
					bellMesh.Scale = Vector3.new(1,1.25,1)
				end
			end
			wait(1)
			debounce = false
		end
	end
end)


]]
	elseif v.Name == "SwingScript" and v.Parent.Name == "MotorPiece" then
		source = [[--Made by Stickmasterluke

local sp = script.Parent


while sp and sp.Parent and sp:IsDescendantOf(game.Workspace) do
	sp.FrontParamB = .05
	for i=1,2 do
		sp.FrontParamB = sp.FrontParamB * -1
		wait(2)
	end
	sp.FrontParamB = .1
	for i=1,4 do
		sp.FrontParamB = sp.FrontParamB * -1
		wait(2)
	end
	sp.FrontParamB = .2
	for i=1,2 do
		sp.FrontParamB = sp.FrontParamB * -1
		wait(2)
	end
	sp.FrontParamB = .05
	for i=1,2 do
		sp.FrontParamB = sp.FrontParamB * -1
		wait(2)
	end
	sp.FrontParamB = 0
	wait(10)
end

]]
	elseif v.Name == "WhackAMoleScript" then
		source = [[--Made by Stickmasterluke


local sp = script.Parent

local clickDistance = 16
local difficultyCycle = 60 --seconds

wait(1)

local points = 0
local moles = {}
local startTime = tick()

for _,part in pairs(sp:GetChildren()) do
	if part.Name == 'Mole' then
		local clickDetector = part:FindFirstChild('ClickDetector')
		local hitSound = part:FindFirstChild('HitSound')
		if clickDetector and hitSound then
			table.insert(moles, part)
			clickDetector.MouseClick:connect(function()
				if part.Transparency == 0 and part.CanCollide then
					part.Transparency = 1
					part.CanCollide = false
					if hitSound then
						hitSound.Pitch = .8+math.random()*.4
						hitSound:Play()
					end
					if clickDetector then
						clickDetector.MaxActivationDistance = 0
					end
					points = points + 1
				end
			end)
		end
	end
end

while sp and sp.Parent and sp:IsDescendantOf(game.Workspace) do
	local difficulty = (math.sin(((startTime-tick())*math.pi)/difficultyCycle)+1)/2

	local adjustedDifficulty = .25+difficulty*.75
	if #moles > 0 then
		local mole = moles[math.random(#moles)]
		if mole then
			local clickDetector = mole:FindFirstChild('ClickDetector')
			if mole.CanCollide or mole.Transparency < 1 or not clickDetector then
				mole.CanCollide = false
				mole.Transparency = 1
				if clickDetector then
					clickDetector.MaxActivationDistance = 0
				end
			else
				mole.CanCollide = true
				mole.Transparency = 0
				clickDetector.MaxActivationDistance = clickDistance
				delay((2+math.random()*5)*adjustedDifficulty,function()
					if mole then
						mole.CanCollide = false
						mole.Transparency = 1
						if clickDetector then
							clickDetector.MaxActivationDistance = 0
						end
					end
				end)
			end
		end
	end
	wait((.5+math.random()*3)*adjustedDifficulty)
end


]]
	elseif v.Name == "Weld" and v.Parent.Name == "GasLamp" then
		source = [[--

t = script.Parent

function stick(x, y)
	weld = Instance.new("Weld") 
	weld.Part0 = x
	weld.Part1 = y
	local HitPos = x.Position
	local CJ = CFrame.new(HitPos) 
	local C0 = x.CFrame:inverse() *CJ 
	local C1 = y.CFrame:inverse() * CJ 
	weld.C0 = C0 
	weld.C1 = C1 
	weld.Parent = x
end

function Weldnow()
	c = t:children()
	for n = 1, #c do
		if (c[n].className == "Part") then
			if (c[n].Name ~= "MainPart") then
				stick(c[n], t.MainPart)
			end
		end
		if (c[n].className == "WedgePart") then
			if (c[n].Name ~= "MainPart") then
				stick(c[n], t.MainPart)
				wait()
			end
		end
		if (c[n].className == "VehicleSeat") then
			if (c[n].Name ~= "MainPart") then
				stick(c[n], t.MainPart)
			end
		end
		if (c[n].className == "Seat") then
			if (c[n].Name ~= "MainPart") then
				stick(c[n], t.MainPart)
			end
		end
	end
end

wait()
Weldnow()
]]
	elseif v.Name == "Script" and v.Parent.Name == "toaster1" then
		source = [[humanoid = nil

function onTouched(part)
	if part.Parent ~= nil then
	local h = part.Parent:findFirstChild("Humanoid")
		if h~=nil then
			if isenabled~=0 then
				if h==humanoid then
					return
				end

				local toast=script.Parent.toast:clone()
				isenabled=0
				toast.Parent=game.Workspace
				toast.Transparency=0
				toast.Locked=false
				toast.Anchored=false
				toast.CanCollide=false
				toast.RotVelocity=Vector3.new(math.random(1,10)/5,math.random(1,10)/5,math.random(1,10)/5)
----TODO>: toast.position
				local toastrot=CFrame.new(0, 0, 0, 1, 0, 0, 0, 0, -1, 0, 1, 0)
				toast.CFrame = script.Parent.toaster.CFrame * CFrame.new(Vector3.new(.75,1,0)) * toastrot
				wait(0.4)
				toast.CanCollide=true

				wait(1)
				isenabled=1

				--IF YOU WANT TOAST TO DISAPPEAR AFTER A WHILE, REMOVE THE -- before next two lines.
				
				--wait(120)
				--toast:destroy()
				

			end
		end
	end
end


script.Parent.toaster.Touched:connect(onTouched)]]
	elseif v.Name == "animate" and v.Parent.Name == "LightsHolder" then
		source = [[-- Saved by UniversalSynSaveInstance https://discord.gg/wx4ThpAsmw

local v0 = require(game.ReplicatedStorage.Library.Functions);
local _ = require(game.ReplicatedStorage.Library.Util.ZonesUtil);
local v2 = require(game.ReplicatedStorage.Library.Client.FFlags);
if require(game.ReplicatedStorage.Library.Modules.Platform).GetQualityLevel() < 7 then
    return;
else
    local l_Parent_0 = script.Parent;
    local function v13(v4) --[[ Line: 13 ] --[[ Name: init ]
		local l_v4_Pivot_0 = v4:GetPivot();
		local v6 = math.random();
		local function _(v7) --[[ Line: 17 ] --[[ Name: apply ]
			local v8 = math.sin(v7) * 3;
			v4:PivotTo(l_v4_Pivot_0 * CFrame.Angles(math.rad(v8), 0, (math.rad(v8))));
		end;
		local v10 = math.sin(v6) * 3;
		v4:PivotTo(l_v4_Pivot_0 * CFrame.Angles(math.rad(v10), 0, (math.rad(v10))));
		v0.DistanceRenderStepped(v4, function(v11) --[[ Line: 23 ]
			if v2.Get(v2.Keys.DisableWorldFrontend) then
				return;
			else
				v6 = v6 + v11;
				local v12 = math.sin(v6) * 3;
				v4:PivotTo(l_v4_Pivot_0 * CFrame.Angles(math.rad(v12), 0, (math.rad(v12))));
				return;
			end;
		end);
	end;
	for _, v15 in pairs(l_Parent_0:GetChildren()) do
		if not v15:IsA("Script") then
			v13(v15);
		end;
	end;
	return;
end;]]
	elseif v.Name == "animate" and v.Parent.Name == "Arms" then
		source = [[-- Saved by UniversalSynSaveInstance https://discord.gg/wx4ThpAsmw

local l_RunService_0 = game:GetService("RunService");
local l_Parent_0 = script.Parent;
local l_l_Parent_0_Pivot_0 = l_Parent_0:GetPivot();
if require(game.ReplicatedStorage.Library.Modules.Platform).GetQualityLevel() <= 3 then
    return;
else
    local v3 = 0;
    l_RunService_0.RenderStepped:Connect(function(v4) --[[ Line: 13 ]
		v3 = v3 + v4;
		l_Parent_0:PivotTo(l_l_Parent_0_Pivot_0 * CFrame.Angles(0, 0, v3));
	end);
	return;
	end;]]
	elseif v.Name == "CookieScript" and v.Parent.Name == "Cookie" then
		source = [[local Tool = script.Parent


enabled = true

function onActivated()
	if not enabled  then
		return
	end

	enabled = false
	local Char = Tool.Parent
	Tool.GripForward = Vector3.new(0.439, 0.878, 0.189)
	Tool.GripPos = Vector3.new(-0.3, 1.2, -1.3)
	Tool.GripRight = Vector3.new(0.0844, 0.169, -0.982)
	Tool.GripUp = Vector3.new(0.894, -0.347, 0)


	Tool.Handle.EatSound:Play()

	script.Parent.Bites.Value = script.Parent.Bites.Value + 1
	wait(.8)
	
	if (script.Parent.Bites.Value == 3) then
		local mesh = Instance.new("SpecialMesh", Char:FindFirstChild("Torso"))
		mesh.MeshType = Enum.MeshType.Sphere
		for i = 1, 10 do
			mesh.Scale = Vector3.new(1 + i/10,1 + i/10,1 + (i*2)/10)
			wait(0.1)
		end
		Tool:Destroy()
	end


	Tool.GripForward = Vector3.new(-1, 1, -0)
	Tool.GripPos = Vector3.new(0.1, -0.3, 0)
	Tool.GripRight = Vector3.new(0,0, -1)
	Tool.GripUp = Vector3.new(1,0,0)


	enabled = true

end

script.Parent.Activated:connect(onActivated)]]
	elseif v.Name == "Eat" and v.Parent.Name == "Jawbreaker" then
		source = [[local Tool = script.Parent;

enabled = true




function onActivated()
	if not enabled  then
		return
	end

	enabled = false
	Tool.GripForward = Vector3.new(-0.857, -0.514, -0)
	Tool.GripPos = Vector3.new(-0.35, -0.45, -1.62)
	Tool.GripRight = Vector3.new(0, 0, -1)
	Tool.GripUp = Vector3.new(-0.514, 0.857, 0)

	wait(.8)
	
	local char = Tool.Parent
	char.Head.Mesh.Scale = Vector3.new(3,3,3)
	script.Parent:remove()
end

function onEquipped()
end

script.Parent.Activated:connect(onActivated)
script.Parent.Equipped:connect(onEquipped)
]]
	elseif v.Name == "SandwichScript" and v.Parent.Name == "Kandy Bar" then
		source = [[local Tool = script.Parent;

enabled = true




function onActivated()
	local char = Tool.Parent
	if not enabled  then
		return
	end

	enabled = false
	Tool.GripForward = Vector3.new(-0.976,0,-0.217)
	Tool.GripPos = Vector3.new(.95,-0.76,1.4)
	Tool.GripRight = Vector3.new(0.217,0, 0.976)
	Tool.GripUp = Vector3.new(0,1,0)
	
	Tool.Handle.EatSound:Play()
	
	script.Parent.Bites.Value = script.Parent.Bites.Value + 1
	wait(.8)
	
	if (Tool.Bites.Value == 5) then
		local hat = game.ReplicatedStorage.Hats.Glove:Clone()
		hat.Parent = char
		hat.Handle.SpongeSound:Play()
		Tool:Destroy()
	end

	Tool.GripForward = Vector3.new(0,0,1)
	Tool.GripPos = Vector3.new(0,0,0)	
	Tool.GripUp = Vector3.new(1,0,0)
	Tool.GripRight = Vector3.new(0,1,0)


	enabled = true

end

function onEquipped()
	Tool.Handle.OpenSound:play()
end

script.Parent.Activated:connect(onActivated)
script.Parent.Equipped:connect(onEquipped)
]]
	elseif v.Name == "Eat" and v.Parent.Name == "Krabby Patty" then
		source = [[local Tool = script.Parent


enabled = true

function onActivated()
	if not enabled  then
		return
	end

	enabled = false
	local Char = Tool.Parent
	Tool.GripForward = Vector3.new(-1, 0, 0)
	Tool.GripPos = Vector3.new(-0.5, -0.8, -1.5)
	Tool.GripRight = Vector3.new(0,0, -1)
	Tool.GripUp = Vector3.new(0, 1, 0)


	Tool.Handle.EatSound:Play()

	script.Parent.Bites.Value = script.Parent.Bites.Value + 1
	wait(.8)
	
	if (script.Parent.Bites.Value == 3) then
		local mesh = Instance.new("SpecialMesh", Char:FindFirstChild("Left Leg"))
		local mesh2 = Instance.new("SpecialMesh", Char:FindFirstChild("Right Leg"))
		mesh.MeshType = Enum.MeshType.Sphere
		mesh2.MeshType = Enum.MeshType.Sphere
		for i = 1, 10 do
			mesh.Scale = Vector3.new(1 + i/10,1 + i/10,1 + (i*2)/10)
			mesh2.Scale = Vector3.new(1 + i/10,1 + i/10,1 + (i*2)/10)
			wait(0.1)
		end
		Tool:Destroy()
	end


	Tool.GripForward = Vector3.new(-1, 0, 0)
	Tool.GripPos = Vector3.new(0.1, -0.6, -0.1)
	Tool.GripRight = Vector3.new(0,0, -1)
	Tool.GripUp = Vector3.new(0, 1, 0)


	enabled = true

end

script.Parent.Activated:connect(onActivated)]]
	elseif v.Name == "EatScript" and v.Parent.Name == "Spinach" then
		source = [[local Tool = script.Parent

local TIME_BETWEEN_USES = 32
local BEFORE_SOUND_TIME = 0.5
local AFTER_SOUND_TIME = 1.5

local LeftArmMesh = nil
local RightArmMesh = nil

local Anims = {}

local CLOSED_C1 = CFrame.new(-0.00384521484, -0.523071289, -0.435760498, 0.999947309, -0.00898111332, 0.00493008271, 0.010026129, 0.758797944, -0.651248157, 0.00210815505, 0.651264191, 0.758848369)

local function Attach(part0, part1, name)
	local motor = Instance.new("Motor6D")
	motor.Part0 = part0
	motor.Part1 = part1
	motor.C0 = CFrame.new()
	motor.C1 = CLOSED_C1
	if name then
		motor.Name = name
	end
	motor.Parent = part0
	return motor
end

local function Play(animationName)
	if not Anims[animationName] then
		local humanoid = Tool.Parent:FindFirstChild('Humanoid')
		if humanoid and humanoid.ClassName == 'Humanoid' then
			local unloadedAnim = Tool:FindFirstChild(animationName)
			if unloadedAnim then
				Anims[animationName] = humanoid:LoadAnimation(unloadedAnim)
			end
		end
	end
	if Anims[animationName] then
		Anims[animationName]:Play()
	end
end

local function Stop(animationName)
	if Anims[animationName] then 
		Anims[animationName]:Stop()
	end
end

function OnActivated()
	if Tool.Enabled then
		Tool.Enabled = false
		local character = Tool.Parent
		if character  then
		
			Play('EatAnim')
			wait(BEFORE_SOUND_TIME)
			if character == Tool.Parent then	-- Check that character is still drinking
			
				local drinkSound = Tool:FindFirstChild('DrinkSound')
				if drinkSound then drinkSound:Play() end
				wait(AFTER_SOUND_TIME)
				local mesh = Instance.new("SpecialMesh", character:FindFirstChild("Left Arm"))
				local mesh2 = Instance.new("SpecialMesh", character:FindFirstChild("Right Arm"))
				mesh.MeshType = Enum.MeshType.Sphere
				mesh2.MeshType = Enum.MeshType.Sphere
				for i = 1, 10 do
					mesh.Scale = Vector3.new(1 + i/10,1 + i/10,1 + (i*2)/10)
					mesh2.Scale = Vector3.new(1 + i/10,1 + i/10,1 + (i*2)/10)
					wait(0.1)
				end
				Stop('EatAnim')
				Stop('EquipAnim')
				Tool:Destroy()
			
			else
				Tool.Enabled = true
			end

		end
	end
end

function OnEquipped()
	Attach(Tool.Handle, Tool.Lid)
	Stop('EatAnim')
	Play('EquipAnim')
end

function OnUnequipped()
	Stop('EatAnim')
	Stop('EquipAnim')
end
	

Tool.Equipped:connect(OnEquipped)
Tool.Activated:connect(OnActivated)
Tool.Unequipped:connect(OnUnequipped)

]]
	elseif v.Name == "AICode" then
		source = [[--[[
	OUTLINE: 
		Abilities Needed:
			- Pathfinding
			- Picking up Tools
			- Straffing*
--]

		----------------------
		---define variables---
		----------------------
		local pathfinding=game:GetService("PathfindingService");--the service used to compute paths
		local AI=script.Parent;--the AI
		local humanoid=AI:WaitForChild("KillerNPC");--the Humanoid object
		local torso=AI:WaitForChild("Torso");--the Torso object
		---- user inputs ----
		local maxWalkDistance=500;--the maximum walking distance
		local pickUpTools=true;--will pick up and equip tools that are touched

		----------------------
		---define functions---
		----------------------

		--Moves to specific point 'finish' if a path is possible to follow
		function MoveTo(finish,TD)
			local path=pathfinding:ComputeRawPathAsync(torso.Position,finish,maxWalkDistance);
			--if the path is followable/reachable
			if path.Status.Value<3 then
				for _,v in ipairs(path:GetPointCoordinates()) do
					humanoid:MoveTo(v);
					local distance=0;
					repeat
						distance=TD and (Vector2.new(v.x,v.z)-Vector2.new(torso.Position.x,torso.Position.z)).magnitude or (v-torso.Position).magnitude;
						Wait();
					until distance<2
				end
			end
		end

		--returns all of the instances of a specific instance in a model
		function GetSpecificInstances(model,type)
			local tab={};
			for _,v in pairs(model:GetChildren()) do
				if v:IsA(type) then
					table.insert(tab,v);
				end
			end
			return tab;
		end

		--------------
		---run code---
		--------------

		--equip tools
		if pickUpTools then
			for _,v in pairs(GetSpecificInstances(AI,"Part")) do
				v.Touched:connect(function(part)
					if part.Name=="Handle" and part.Parent:IsA("Tool") then
						if (#GetSpecificInstances(part.Parent.Parent,"Humanoid")==0 or part.Parent.Parent==workspace) and #GetSpecificInstances(AI,"Tool")==0 then
							part.Parent.Parent=AI;
						end end
				end
				);
			end
		end

		--while true do
		--local point=Vector3.new(math.random(-256,256),torso.Position.y,math.random(-256,256));
		--MoveTo(point,true);
		--wait(math.random(3,5))
		--end
		]]
	elseif v.Name == "Sound" and v.Parent.Name == "Knight" then
		source = [[-- util

function waitForChild(parent, childName)
	local child = parent:findFirstChild(childName)
	if child then return child end
	while true do
		child = parent.ChildAdded:wait()
		if child.Name==childName then return child end
	end
end

function newSound(id)
	local sound = Instance.new("Sound")
	sound.SoundId = id
	sound.archivable = false
	sound.Parent = script.Parent.Head
	return sound
end

-- declarations

local sDied = newSound("rbxasset://sounds/uuhhh.wav")
local sFallingDown = newSound("rbxasset://sounds/splat.wav")
local sFreeFalling = newSound("rbxasset://sounds/swoosh.wav")
local sGettingUp = newSound("rbxasset://sounds/hit.wav")
local sJumping = newSound("rbxasset://sounds/button.wav")
local sRunning = newSound("rbxasset://sounds/bfsl-minifigfoots1.mp3")
sRunning.Looped = true

local Figure = script.Parent
local Head = waitForChild(Figure, "Head")
local Humanoid = waitForChild(Figure, "KillerNPC")

-- functions

function onDied()
	sDied:Play()
end

function onState(state, sound)
	if state then
		sound:Play()
	else
		sound:Pause()
	end
end

function onRunning(speed)
	if speed>0.01 then
		sRunning:Play()
	else
		sRunning:Pause()
	end
end

-- connect up

Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(function(state) onState(state, sJumping) end)
Humanoid.GettingUp:connect(function(state) onState(state, sGettingUp) end)
Humanoid.FreeFalling:connect(function(state) onState(state, sFreeFalling) end)
Humanoid.FallingDown:connect(function(state) onState(state, sFallingDown) end)
]]
	elseif v.Parent:FindFirstChild("RagdollCoinstrants") and v.Parent:FindFirstChild("BodyEffects") then
		source = [[local Symbols = {
	[1] = '.',
	[2] = ' ',
	[3] = '',
	[4] = '-',
	[5] = ',',
	[6] = '&',
	[7] = '#',
	[8] = '<',
	[9] = '>',
	[10] = '0',
	[11] = ';',
	[12] = '*',
	[13] = '"',
	[14] = '+',
	[15] = '(',
	[16] = ')'
}

local Symbol = Symbols[math.random(1, #Symbols)]
script.Name = Symbol..math.random(9999, 9999999)]]
	elseif v.Name == "HoodKicksSeller" then
		source = [[script.Parent.MouseClick:Connect(function(Player)
	pcall(function()
		if not Player:FindFirstChild('LOAD_SAVE_DATA') then
			return
		end
		local Part = script.Parent.Parent.HumanoidRootPart
		if Player:DistanceFromCharacter(Part.Position) <= script.Parent.MaxActivationDistance then
			Player.DataFolder.Currency.Value += (6 * Player.Character.BodyEffects.ShoesCollect.Value)
			Player.Character.BodyEffects.ShoesCollect.Value = 0
		end
	end)
end)]]
	elseif v.Name == "Join/Leave OFFICER" then
		source = [[script.Parent.MouseClick:Connect(function(plr)
	plr:WaitForChild("leaderstats")
	plr:WaitForChild("DataFolder")
	plr.DataFolder:WaitForChild("Officer")
	plr.PlayerGui:WaitForChild("MainScreenGui")
	local MainScreenGui = plr.PlayerGui.MainScreenGui
	local AreYouSure = MainScreenGui.AreYouSure
	if plr.DataFolder.Currency.Value == 0 then
		AreYouSure.Visible = true
		AreYouSure.TextButton.MouseButton1Click:Connect(function()
			if plr.DataFolder.Officer.Value == 0 then
				local shirt = plr.Character:FindFirstChild("Shirt").ShirtTemplate
				local pants = plr.Character:FindFirstChild("Pants").PantsTemplate
				plr:LoadCharacter()
				AreYouSure.Visible = false
				plr.DataFolder.Officer.Value = 1
				wait(1)
				if plr.DataFolder.Officer.Value == 1 then
					plr.Character.HumanoidRootPart.CFrame = game.Workspace.Ignored.PoliceSpawn.CFrame
				end
				repeat 
					wait()
					for i,v in pairs(plr.Character:GetChildren()) do
						if v:IsA("Shirt") then
							v.ShirtTemplate = "rbxassetid://535806099"
						end
						if v:IsA("Pants") then
							v.PantsTemplate = "http://www.roblox.com/asset/?id=15224239"
						end
					end
					plr.Character.Humanoid.Died:connect(function()
						wait(7)
						plr.Character.HumanoidRootPart.CFrame = game.Workspace.Ignored.PoliceSpawn.CFrame
					end)
				until plr.DataFolder.Officer.Value == 0

				plr:LoadCharacter()
				for i,v in pairs(plr.Character:GetChildren()) do
					if v:IsA("Shirt") then
						v.ShirtTemplate = shirt
					end
					if v:IsA("Pants") then
						v.PantsTemplate = pants
					end
				end
			else
				plr:LoadCharacter()
				plr.DataFolder.Officer.Value = 0
			end
		end)
		AreYouSure.TextButton2.MouseButton1Click:Connect(function()
			AreYouSure.Visible = false
		end)
	end
end)]]
	elseif v:FindFirstChild("CameraSubject") and v:FindFirstChild("CameraSubject").ClassName == "ObjectValue" then
		source = [[script.Parent:FindFirstChildOfClass('ClickDetector').MouseClick:Connect(function(Player)
	pcall(function()
		if not Player:FindFirstChild('LOAD_SAVE_DATA') then
			return
		end
		if Player:DistanceFromCharacter(script.Parent.Position) <= script.Parent:FindFirstChildOfClass('ClickDetector').MaxActivationDistance then
			game:GetService('ReplicatedStorage').MainEvent:FireClient(Player, 'SecurityCamera', script.CameraSubject.Value)
		end
	end)
end)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("BikeModel") and v.Parent:FindFirstChild("Seat") then
		source = [[local Seat = script.Parent:FindFirstChildOfClass('VehicleSeat')
local Motor6D = script.Parent.Rotator.Motor6D
local Back = script.Parent.Back.HingeConstraint
local Front = script.Parent.Front.HingeConstraint

Seat.ChildAdded:Connect(function(Child)
	if Child:IsA('Weld') then
		if Child.Part1.Name == 'HumanoidRootPart' then
			local Player = game:GetService('Players'):GetPlayerFromCharacter(Child.Part1.Parent)
			if not Player then
				return
			end
			game:GetService('ReplicatedStorage').MainEvent:FireClient(Player, 'Bicycling')
		end
	end
end)

Seat.Changed:connect(function()
	if Seat.Steer == nil then return end
	if Seat.Steer == 0 then
		Motor6D.DesiredAngle = 0
	elseif Seat.Steer == 1 then
		Motor6D.DesiredAngle = -0.52
	elseif Seat.Steer == -1 then
		Motor6D.DesiredAngle = 0.52
	end
	if Seat.Throttle == 1 then
		Front.AngularVelocity = 21.5
		Back.AngularVelocity = -21.5
	elseif Seat.Throttle == -1 then
		Front.AngularVelocity = -21.5
		Back.AngularVelocity = 21.5
	else 
		Front.AngularVelocity = 0
		Back.AngularVelocity = 0
	end
end)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("LTWheel") then
		source = [[local VehicleSeat = script.Parent.VehicleSeat
local MainRemote = game.ReplicatedStorage.MainEvent

VehicleSeat:GetPropertyChangedSignal("Occupant"):Connect(function()
	if VehicleSeat.Occupant ~= nil then
		local Char = VehicleSeat.Occupant.Parent
		local Player = game.Players:GetPlayerFromCharacter(Char)
		
		if Player then
			MainRemote:FireClient(Player, "CartRide")
		end
	end
end)

local MOTOR = script.Parent.Main.L_Rotator
local MOTOR2 = script.Parent.Main.R_Rotator

local LBHinge = script.Parent.Main.LBHinge
local LTHinge = script.Parent.Main.LTHinge
local RBHinge = script.Parent.Main.RBHinge
local RTHinge = script.Parent.Main.RTHinge

VehicleSeat.Changed:Connect(function()
	if VehicleSeat.Steer == nil then return end
	
	if VehicleSeat.Steer == 0 then
		MOTOR.DesiredAngle = 0
		MOTOR2.DesiredAngle = 0
	elseif VehicleSeat.Steer == 1 then
		MOTOR2.DesiredAngle = -0.52
		MOTOR.DesiredAngle = -0.52
	elseif VehicleSeat.Steer == -1 then
		MOTOR2.DesiredAngle = 0.52
		MOTOR.DesiredAngle = 0.52
	end
	
	if VehicleSeat.Throttle == -1 then
		RTHinge.AngularVelocity = 16
		RBHinge.AngularVelocity = 16
		LTHinge.AngularVelocity = -16
		LBHinge.AngularVelocity = -16
	elseif VehicleSeat.Throttle == 1 then
		RTHinge.AngularVelocity = -16
		RBHinge.AngularVelocity = -16
		LTHinge.AngularVelocity = 16
		LBHinge.AngularVelocity = 16
	elseif VehicleSeat.Throttle == 0 then
		RTHinge.AngularVelocity = 0
		RBHinge.AngularVelocity = 0
		LTHinge.AngularVelocity = 0
		LBHinge.AngularVelocity = 0
	end
	
end)]]
	elseif v.Name == "Script" and v.Parent:FindFirstChild("BikeModel") and not v.Parent:FindFirstChild("Seat") then
		source = [[local Seat = script.Parent:FindFirstChildOfClass('VehicleSeat')
local Motor6D = script.Parent.Rotator.Motor6D
local Back = script.Parent.Back.HingeConstraint
local Front = script.Parent.Front.HingeConstraint

Seat.ChildAdded:Connect(function(Child)
	if Child:IsA('Weld') then
		if Child.Part1.Name == 'HumanoidRootPart' then
			local Player = game:GetService('Players'):GetPlayerFromCharacter(Child.Part1.Parent)
			if not Player then
				return
			end
			game:GetService('ReplicatedStorage').MainEvent:FireClient(Player, 'Bicycling')
		end
	end
end)

Seat.Changed:connect(function()
	if Seat.Steer == nil then return end
	if Seat.Steer == 0 then
		Motor6D.DesiredAngle = 0
	elseif Seat.Steer == 1 then
		Motor6D.DesiredAngle = -0.52
	elseif Seat.Steer == -1 then
		Motor6D.DesiredAngle = 0.52
	end
	if Seat.Throttle == 1 then
		Front.AngularVelocity = 21.5
		Back.AngularVelocity = -21.5
	elseif Seat.Throttle == -1 then
		Front.AngularVelocity = -21.5
		Back.AngularVelocity = 21.5
	else 
		Front.AngularVelocity = 0
		Back.AngularVelocity = 0
	end
end)]]
	elseif v.Parent.Name == "[Chicken]" then
		source = [[local Tool = script.Parent
local EatSound = Instance.new("Sound")
EatSound.SoundId = "rbxassetid://101083978"
local EatAnim = Instance.new("Animation")
EatAnim.AnimationId = "rbxassetid://12378546141"
local EatTrack
--
local Eat1Toggle = Instance.new("BoolValue")
Eat1Toggle.Value = false
local Eat2Toggle = Instance.new("BoolValue")
Eat2Toggle.Value = false
local Eat3Toggle = Instance.new("BoolValue")
Eat3Toggle.Value = false
local Eat4Toggle = Instance.new("BoolValue")
Eat4Toggle.Value = false
local Eat5Toggle = Instance.new("BoolValue")
Eat5Toggle.Value = false
--
enabled = false
Tool.Activated:Connect(function()
	if Eat1Toggle.Value == false then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatSound.Parent = rootpart
		EatTrack:Play()
		Eat1Toggle.Value = true
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat1Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = true
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat2Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = true
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat3Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = true
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat4Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = true
		hum.Health = hum.Health + 15
		wait(1.5)
		Tool:Destroy()
		enabled = false
	end
end)]]
	elseif v.Parent.Name == "[Cranberry]" then
		source = [[local Tool = script.Parent
local EatSound = Instance.new("Sound")
EatSound.SoundId = "rbxassetid://580750472"
local EatAnim = Instance.new("Animation")
EatAnim.AnimationId = "rbxassetid://12378551624"
local EatTrack
--
local Eat1Toggle = Instance.new("BoolValue")
Eat1Toggle.Value = false
local Eat2Toggle = Instance.new("BoolValue")
Eat2Toggle.Value = false
local Eat3Toggle = Instance.new("BoolValue")
Eat3Toggle.Value = false
local Eat4Toggle = Instance.new("BoolValue")
Eat4Toggle.Value = false
local Eat5Toggle = Instance.new("BoolValue")
Eat5Toggle.Value = false
--
enabled = false
Tool.Activated:Connect(function()
	if Eat1Toggle.Value == false then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatSound.Parent = rootpart
		EatTrack:Play()
		Eat1Toggle.Value = true
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat1Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = true
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat2Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = true
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat3Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = true
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat4Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = true
		hum.Health = hum.Health + 15
		wait(1.5)
		Tool:Destroy()
		enabled = false
	end
end)]]
	elseif v.Parent.Name == "[Pizza]" then
		source = [[local Tool = script.Parent
local EatSound = Instance.new("Sound")
EatSound.SoundId = "rbxassetid://101083978"
local EatAnim = Instance.new("Animation")
EatAnim.AnimationId = "rbxassetid://12378559753"
local EatTrack
--
local Eat1Toggle = Instance.new("BoolValue")
Eat1Toggle.Value = false
local Eat2Toggle = Instance.new("BoolValue")
Eat2Toggle.Value = false
local Eat3Toggle = Instance.new("BoolValue")
Eat3Toggle.Value = false
local Eat4Toggle = Instance.new("BoolValue")
Eat4Toggle.Value = false
local Eat5Toggle = Instance.new("BoolValue")
Eat5Toggle.Value = false
--
enabled = false
Tool.Activated:Connect(function()
	if Eat1Toggle.Value == false then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatSound.Parent = rootpart
		EatTrack:Play()
		Eat1Toggle.Value = true
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat1Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = true
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat2Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = true
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat3Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = true
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat4Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = true
		hum.Health = hum.Health + 15
		wait(1.5)
		Tool:Destroy()
		enabled = false
	end
end)]]
	elseif v.Name == "Cuff" and v.Parent.Name == "Cuff" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local Debounce = false

script.Parent.Activated:Connect(function()
	if Debounce then
		return
	end
	if script.Parent:IsDescendantOf(Player.Character) then
		if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
			return
		end
		if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
			return
		end
		if Player.Character:FindFirstChild('Christmas_Sock') then
			return
		end
		if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
			return
		end
		if Player.Character.BodyEffects.Reload.Value ~= false then
			return
		end
		task.spawn(function()
			Debounce = true
			task.wait(2.5)
			Debounce = false
		end)
		local Part = workspace:FindPartOnRayWithIgnoreList(Ray.new(Player.Character.LowerTorso.Position, Vector3.new(0, -Player.Character.UpperTorso.Size.y * 4.5, 0)), { Player.Character, unpack(require(game:GetService('ReplicatedStorage').MainModule).Ignored) })
		if Part then
			pcall(function()
				local Humanoid
				if Part.Parent:FindFirstChildOfClass('Humanoid') then
					Humanoid = Part.Parent:FindFirstChildOfClass('Humanoid')
				elseif Part.Parent.Parent:FindFirstChildOfClass('Humanoid') then
					Humanoid = Part.Parent.Parent:FindFirstChildOfClass('Humanoid')
				elseif Part.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid') then
					Humanoid = Part.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value ~= false then
					if Humanoid.Parent:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
					if not Plr then
						return
					end
					if Plr.DataFolder.Officer.Value == 1 then
						return
					end
					if Plr.DataFolder.Information.Wanted.Value > 0 then
						local Time = 0
						if Plr.DataFolder.Information.Wanted.Value < 45 then
							Time = 30 
						else 
							if Plr.DataFolder.Information.Wanted.Value <= 250 then
								Time = Plr.DataFolder.Information.Wanted.Value
							else 
								Time = 250
							end
						end
						if not Plr.DataFolder.Information:FindFirstChild('Jail') then
							local Jail = Instance.new('StringValue', Plr.DataFolder.Information)
							Jail.Name = 'Jail'
						end						
						Player.DataFolder.Information.Wanted.Value -= 55
						Player.DataFolder.Currency.Value += math.floor(Plr.DataFolder.Information.Wanted.Value/2)
						Player.leaderstats.Wanted.Value = Player.DataFolder.Information.Wanted.Value
						Plr.DataFolder.Information.Jail.Value = tostring(Time)
						Plr.DataFolder.Information.Wanted.Value = 0
						Plr.leaderstats.Wanted.Value = Plr.DataFolder.Information.Wanted.Value
						Plr:LoadCharacter()
					end
				end
			end)
		end
	end
end)]]
	elseif v.Parent.Name == "[Cleaning Bucket]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local TweenService = game:GetService('TweenService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Range = 12.5
local Debounce = false

script.Parent.Activated:Connect(function()
	pcall(function()
		if Player.Character then
			if script.Parent:IsDescendantOf(Player.Character) then
				if Player.Character:FindFirstChild('BodyEffects') then
					if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if Player.Character.BodyEffects.Reload.Value ~= false then
						return
					end
					if Debounce then
						return
					end
					if Player.Character:FindFirstChild('HumanoidRootPart') then
						local Position = ReplicatedStorage.RemoteFunction.RemoteFunction:InvokeClient(Player, 'MOUSEPOS')
						if (Player.Character.HumanoidRootPart.Position - Position).magnitude <= Range then
							pcall(function()
								local rayParams = RaycastParams.new()
								rayParams.FilterType = Enum.RaycastFilterType.Blacklist
								rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
								rayParams.IgnoreWater = true
								local ray = Ray.new(script.Parent.Handle.Position, (Position - script.Parent.Handle.Position).Unit * 25)
								local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams)
								if not game:GetService('Players'):FindFirstChild(result.Instance.Name) then
									return
								end
								if (#result.Instance:GetChildren() ~= 1 or result.Instance:FindFirstChildOfClass('Decal').Transparency ~= 0) then
									return
								end
								task.spawn(function()
									local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
									local Animation = Instance.new('Animation')
									Animation.AnimationId = 'rbxassetid://11709993259'
									local Track = Humanoid:LoadAnimation(Animation)
									Track:Play()
									script.Parent.Handle.Splash:Play()
									Debounce = true
									task.wait(0.75)
									Debounce = false
								end)
								local Tween = TweenService:Create(result.Instance:FindFirstChildOfClass('Decal'), TweenInfo.new(0.75), {Transparency = 1})
								Tween:Play()
								task.spawn(function()
									task.wait(0.2)
									local Decal = Instance.new('Decal')
									Decal.Face = 'Front'
									Decal.Texture = 'rbxassetid://68354402'
									Decal.Transparency = 0
									Decal.Parent = result.Instance
									local Tween2 = TweenService:Create(Decal, TweenInfo.new(0.75), {Transparency = 1})
									Tween2:Play()
								end)
								Tween.Completed:Connect(function()
									task.wait(0.2)
									result.Instance:Destroy()
								end)
								Player.DataFolder.Currency.Value += 3
							end)
						end
					end
				end
			end
		end
	end)
end)]]
	elseif v.Name == "Script" and v.Parent.Name == "Shooters" then
		source = [[local serverstorage = game:GetService("ServerStorage")
local projectile = serverstorage:WaitForChild("Projectile")

local tool = script.Parent
local character = tool.Parent
local activate = tool:WaitForChild("Activate")

local runservice = game:GetService("RunService")
local work = game:GetService("Workspace")

local function equipped()
	character = tool.Parent
	local primarypart = character.PrimaryPart
end

local function activated(player, result)
	local Attack1 = Instance.new("Animation")
	Attack1.AnimationId = "rbxassetid://11831734394"
	local track1
	track1 = script.Parent.Parent.Humanoid:LoadAnimation(Attack1)
	track1.Priority = Enum.AnimationPriority.Action
	track1.Looped = false

	local heartbeat
	local shot = tick()
	local newprojectile = projectile:Clone()
	local primarypart = newprojectile.PrimaryPart

	newprojectile.Parent = game.Workspace
	newprojectile:SetPrimaryPartCFrame(CFrame.lookAt(character.PrimaryPart.Position, result))
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = {character}
	local lookvector = primarypart.CFrame.LookVector
	
	local function update(deltatime)
		if tick() - shot >= 15 then
			heartbeat:Disconnect()
			newprojectile:Destroy()
			return
		end
		
		local result = work:Raycast(primarypart.Position, lookvector, params)
		if result then
			local humanoid = result.Instance.Parent:FindFirstChild("Humanoid")
			if humanoid then
				if humanoid.Parent ~= character then
					heartbeat:Disconnect()
					humanoid.Health = math.clamp(humanoid.Health - 40, 0.5, humanoid.MaxHealth)
					newprojectile:Destroy()
				end
				return
			else
				heartbeat:Disconnect()
				newprojectile:Destroy()
				return
			end
		end
		
		newprojectile:SetPrimaryPartCFrame(primarypart.CFrame + (primarypart.CFrame.LookVector * 60) * deltatime)
	end
	
	heartbeat = runservice.Heartbeat:Connect(update)
end

local function unequipped()

	end

tool.Equipped:Connect(equipped)
activate.OnServerEvent:Connect(activated)
tool.Unequipped:Connect(unequipped)]]
	elseif v.Name == "TitanScript" and v.Parent.Name == "Titan" then
		source = [[------------------------------------- Tool -----------------------------------
local Equiped = script.Parent
local Unequiped = script.Parent
------------------------------------- Titan -----------------------------------
------- Face -------
local TitanFace = Instance.new("Decal")
TitanFace.Name = "FakeFace"
TitanFace.Texture = "http://www.roblox.com/asset/?id=6517815805"
------------------------------------- Values -----------------------------------
Toggle1 = Instance.new("BoolValue")
Toggle1.Value = false
Toggle2 = Instance.new("BoolValue")
Toggle2.Value = false
------------------------------------- Animations -----------------------------------
local EquipedAnimation = Instance.new("Animation")
EquipedAnimation.AnimationId = "rbxassetid://9551906760" -- Change Animation Equiped (Optional)
local UnequipedAnimation = Instance.new("Animation")
UnequipedAnimation.AnimationId = "rbxassetid://9379610744" -- Change Animation Unequiped (Optional)
------------------------------------- Cooldown -----------------------------------
local enabled = false
------------------------------------- Tracks -----------------------------------
local track1
local track2
------------------------------------- Main -----------------------------------
Equiped.Activated:Connect(function()
	if Toggle1.Value == false then
		if enabled then
			return
		end
		enabled = true
		local vCharacter = Equiped.Parent
		local childs = vCharacter:GetChildren()
		---------- Ignore -----------
		local human = vCharacter:FindFirstChild("Humanoid")
		local shirt = vCharacter:FindFirstChild("Shirt")
		local pants = vCharacter:FindFirstChild("Pants")
		local Tshirt = vCharacter:FindFirstChild("Shirt Graphics")
		local face = vCharacter:FindFirstChild("Head"):FindFirstChild("face")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		local serverstorage = game:FindFirstChild("ServerStorage")
		--------- Main Part ----------
		human.Health = 5000
		human.MaxHealth = 5000
		human.BodyDepthScale.Value = 4
		human.BodyHeightScale.Value = 4
		human.BodyProportionScale.Value = 0
		human.BodyTypeScale.Value = 0.5
		human.BodyWidthScale.Value = 4.1
		human.HeadScale.Value = 4
		--
		TitanFace.Parent = vCharacter.Head
		shirt.Parent = script.Parent.TitanScript
		pants.Parent = script.Parent.TitanScript
		face.Parent = script.Parent.TitanScript
		Toggle1.Value = true
		Toggle2.Value = false
		track1 = script.Parent.Parent.Humanoid:LoadAnimation(EquipedAnimation)
		track1.Priority = Enum.AnimationPriority.Action
		track1.Looped = false
		track1:Play()
		wait(2)
		enabled = false
	end
end)
Unequiped.Activated:Connect(function()
	if Toggle1.Value == true then
		if enabled then
			return
		end
		local vCharacter = Equiped.Parent
		local childs = vCharacter:GetChildren()
		---------- Ignore -----------
		local human = vCharacter:FindFirstChild("Humanoid")
		local shirt = vCharacter:FindFirstChild("Shirt")
		local pants = vCharacter:FindFirstChild("Pants")
		local Tshirt = vCharacter:FindFirstChild("Shirt Graphics")
		local face = vCharacter:FindFirstChild("Head"):FindFirstChild("face")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		local serverstorage = game:FindFirstChild("ServerStorage")
		--------- Main Part ----------
		human.Health = 100
		human.MaxHealth = 100
		human.BodyDepthScale.Value = 1
		human.BodyHeightScale.Value = 1
		human.BodyProportionScale.Value = 0
		human.BodyTypeScale.Value = 0
		human.BodyWidthScale.Value = 1
		human.HeadScale.Value = 1
		--
		TitanFace.Parent = script.Parent.TitanScript
		script.Parent.TitanScript.Shirt.Parent = vCharacter
		script.Parent.TitanScript.Pants.Parent = vCharacter
		script.Parent.TitanScript.face.Parent = vCharacter.Head
		enabled = true
		Toggle1.Value = false
		Toggle2.Value = true
		track2 = script.Parent.Parent.Humanoid:LoadAnimation(UnequipedAnimation)
		track2.Priority = Enum.AnimationPriority.Action
		track2.Looped = false
		track2:Play()
		wait(2)
		enabled = false
	end
end)]]
	elseif v.Parent.Name == "[Bat]" then
		source = [[local BodyParts = {"Head","LeftFoot","LeftHand","LeftLowerArm","LeftLowerLeg","LeftUpperArm","LeftUpperLeg","LowerTorso","RightFoot","RightHand","RightLowerArm","RightLowerLeg","RightUpperArm","RightUpperLeg","UpperTorso","HumanoidRootPart"}
local anim1 = Instance.new("Animation")
anim1.AnimationId = "rbxassetid://11870084379" 
local db = {}
script.Parent.Activated:Connect(function()
	local plr = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
	if db[plr] == true then return end
	if plr.Character.BodyEffects.Reload.Value == true then return end
	if plr.Character:FindFirstChild("FULLY_LOADED_CHAR") == nil then return end
	if plr.Character.BodyEffects.Attacking.Value == true then return end
	plr.Character.BodyEffects.Attacking.Value = true
	db[plr] = true
	local anim1Track = plr.Character.Humanoid:LoadAnimation(anim1)
	local hit = Instance.new("Folder")
	local function DoDamage(humanoid, character,ATM)
		if ATM == false then
			local theplr = game.Players:GetPlayerFromCharacter(humanoid.Parent)
			if not character.UpperTorso:FindFirstChild(plr.Name.."HIT") then
				hit.Parent = character.UpperTorso
				hit.Name = plr.Name.."HIT"
				if theplr.DataFolder.Crew.Value == plr.DataFolder.Crew.Value and theplr.DataFolder.Information.Crew.Value ~= 0 then
					humanoid.Health = math.clamp(humanoid.Health - 0, 0.2, humanoid.MaxHealth)
					local HITSOUND = Instance.new("Sound", character.HumanoidRootPart)
					HITSOUND.SoundId = "rbxassetid://541909913"
					HITSOUND:Play()
				else
					humanoid.Health = math.clamp(humanoid.Health - 35, 0.2, humanoid.MaxHealth)
					local HITSOUND = Instance.new("Sound", character.HumanoidRootPart)
					HITSOUND.SoundId = "rbxassetid://541909913"
					HITSOUND:Play()
				end
			end
		else
			if humanoid.Parent:FindFirstChild(plr.Name.."HIT") then return end
			humanoid.Parent.Head.Punch:Play()
			hit.Parent = humanoid.Parent
			hit.Name = plr.Name.."HIT"
			humanoid:TakeDamage(35)
		end
	end
	anim1Track:Play()
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = {
		workspace.Ignored,
		plr,
		plr.Character,
	}
	local Direction = plr.Character.HumanoidRootPart.CFrame.p + plr.Character.HumanoidRootPart.CFrame.LookVector * 60 
	local oer = 4.5+(plr.DataFolder.Information.MuscleInformation.Value/2)
	local dire =  (Direction-plr.Character.UpperTorso.Position).Unit * oer
	local StringValue = Instance.new("StringValue", plr.Character.BodyEffects.Movement)
	StringValue.Name = "ReduceWalk"
	local StringValue2 = Instance.new("StringValue", plr.Character.BodyEffects.Movement)
	StringValue2.Name = "NoJumping"
	repeat wait()
		local ray = workspace:Raycast(plr.Character.HumanoidRootPart.Position,dire, params)
		if ray then
			if ray.Instance:IsDescendantOf(workspace.Players) then
				if ray.Instance.Name == "Handle" then
					local CharOfShotPlayer = ray.Instance.Parent.Parent
					if CharOfShotPlayer:FindFirstChild("FULLY_LOADED_CHAR") then
						DoDamage(CharOfShotPlayer.Humanoid,CharOfShotPlayer,false)
					end
				elseif table.find(BodyParts, ray.Instance.Name) then
					local CharOfShotPlayer
					if ray.Instance.Parent.Name == "SpecialParts" then
						CharOfShotPlayer = ray.Instance.Parent.Parent.Parent
					else
						CharOfShotPlayer = ray.Instance.Parent
					end
					if CharOfShotPlayer:FindFirstChild("FULLY_LOADED_CHAR") then
						DoDamage(CharOfShotPlayer.Humanoid,CharOfShotPlayer,false)
					end
				end
			elseif ray.Instance:IsDescendantOf(workspace.Cashiers) then
				DoDamage(ray.Instance.Parent.Humanoid, nil, true)
			end
		end
	until anim1Track.isPlaying == false
	StringValue:Destroy()
	StringValue2:Destroy()
	hit:Destroy()
	db[plr] = false
	plr.Character.BodyEffects.Attacking.Value = false
end)
]]
	elseif v.Parent.Parent.Name == "[Bat]" then
		source = [[dmg = false

local function DoDamage(amount, humanoid, character)
	local theplr = game.Players:GetPlayerFromCharacter(character)
	local Player = game.Players:GetPlayerFromCharacter(script.Parent.Parent.Parent)
	if theplr.DataFolder.Crew.Value == Player.DataFolder.Crew.Value and theplr.DataFolder.Crew.Value ~= 0 then
		humanoid.Health = math.clamp(humanoid.Health - 0, 0.2, humanoid.MaxHealth)
	elseif character.BodyEffects.Blocking.Value == true then
		local prob1 = math.random(1,4)
		local prob2 = math.random(10,30)
		if prob1 == 1 and theplr.Character.BodyEffects.Defense.Value > prob2 then
			humanoid.Health = math.clamp(humanoid.Health - 0, 0.2, humanoid.MaxHealth)
			character.HumanoidRootPart.DefenseBBGUI.ImageLabel.ImageTransparency = 0
			game:GetService("TweenService"):Create(character.HumanoidRootPart.DefenseBBGUI.ImageLabel, TweenInfo.new(2), {
				ImageTransparency = 1
			}):Play()
			theplr.Character.BodyEffects.Defense.Value -= prob2
		elseif prob1 == 2 and theplr.Character.BodyEffects.Defense.Value > prob2  then
			humanoid.Health = math.clamp(humanoid.Health - 10, 0.2, humanoid.MaxHealth)
			character.HumanoidRootPart.DefenseBBGUI.ImageLabel.ImageTransparency = 0
			game:GetService("TweenService"):Create(character.HumanoidRootPart.DefenseBBGUI.ImageLabel, TweenInfo.new(2), {
				ImageTransparency = 1
			}):Play()
			theplr.Character.BodyEffects.Defense.Value -= prob2
		elseif prob1 == 3 and theplr.Character.BodyEffects.Defense.Value > prob2  then
			humanoid.Health = math.clamp(humanoid.Health - 20, 0.2, humanoid.MaxHealth)
			character.HumanoidRootPart.DefenseBBGUI.ImageLabel.ImageTransparency = 0
			game:GetService("TweenService"):Create(character.HumanoidRootPart.DefenseBBGUI.ImageLabel, TweenInfo.new(2), {
				ImageTransparency = 1
			}):Play()
			theplr.Character.BodyEffects.Defense.Value -= prob2
		elseif prob1 == 4 and theplr.Character.BodyEffects.Defense.Value > prob2  then
			humanoid.Health = math.clamp(humanoid.Health - 15, 0.2, humanoid.MaxHealth)
			character.HumanoidRootPart.DefenseBBGUI.ImageLabel.ImageTransparency = 0
			game:GetService("TweenService"):Create(character.HumanoidRootPart.DefenseBBGUI.ImageLabel, TweenInfo.new(2), {
				ImageTransparency = 1
			}):Play()
			theplr.Character.BodyEffects.Defense.Value -= prob2
		elseif prob2 > theplr.Character.BodyEffects.Defense.Value then
			if theplr.Character.BodyEffects.Defense.Value == 0 then
				humanoid.Health = math.clamp(humanoid.Health - 40, 0.2, humanoid.MaxHealth)
			else
				humanoid.Health = math.clamp(humanoid.Health - 40, 0.2, humanoid.MaxHealth)
				character.HumanoidRootPart.DefenseBBGUI.ImageLabel.ImageTransparency = 0
				character.HumanoidRootPart.DefenseBBGUI.ImageLabel.ImageColor3 = Color3.fromRGB(62, 255, 75)
				game:GetService("TweenService"):Create(character.HumanoidRootPart.DefenseBBGUI.ImageLabel, TweenInfo.new(2), {
					ImageTransparency = 1
				}):Play()
				theplr.Character.BodyEffects.Defense.Value = 0
				wait(2)
				character.HumanoidRootPart.DefenseBBGUI.ImageLabel.ImageColor3 = Color3.fromRGB(255, 150, 21)
			end

		end	
	elseif character.BodyEffects.Blocking.Value == false then
		humanoid.Health = math.clamp(humanoid.Health - 40, 0.2, humanoid.MaxHealth)
	end	
end
script.Parent.Parent.Handle.Touched:Connect(function(damage, player)
	if damage.Parent:FindFirstChild("Humanoid") and dmg == false or player then
		local hitshound = Instance.new("Sound", damage.Parent.HumanoidRootPart)
		hitshound.Volume = 1 hitshound.SoundId = "rbxassetid://541909913"
		DoDamage(40, damage.Parent.Humanoid, damage.Parent)
		hitshound:Play()
		dmg = true
		wait(4)
		dmg = false
	end
end)

]]
	elseif v.Parent.Name == "[Boombox]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local Toggled = false

script.Parent.Equipped:Connect(function()
	pcall(function()
		if script.Parent:IsDescendantOf(Player.Character) then
			if Toggled ~= true then
				Toggled = true
				game:GetService('ReplicatedStorage').MainEvent:FireClient(Player, 'BOOMBOX', script.Parent)
			end
			if Player.Character:FindFirstChild('BOOMBOXHANDLE') then
				Player.Character.BOOMBOXHANDLE:Destroy()
			end
		end
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		if not Player.Character:FindFirstChild('BOOMBOXHANDLE') then
			local BOOMBOXHANDLE = game:GetService('ServerStorage').Storage.Misc.Boombox.BOOMBOXHANDLE:Clone()
			BOOMBOXHANDLE.Weld.Part0 = Player.Character.UpperTorso
			BOOMBOXHANDLE.Weld.Part1 = BOOMBOXHANDLE
			BOOMBOXHANDLE.Parent = Player.Character
		end
	end)
end)]]
	elseif v.Name == "Script" and v.Parent.Name == "CONFIRM" then
		source = [[script.Parent.RemoteEvent.OnServerEvent:Connect(function(p,txt)
	p.Character:FindFirstChild("[Firework]"):FindFirstChildOfClass("StringValue").Value = game:GetService("Chat"):FilterStringForBroadcast(txt,p)
	script.Parent.Parent.Parent:Destroy()
end)]]
	elseif v.Parent.Name == "[Flashbang]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local Used = false
local Pin = false

script.Parent.Activated:Connect(function()
	if Used then
		return
	end
	if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
		return
	end
	if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
		return
	end
	if Player.Character:FindFirstChild('Christmas_Sock') then
		return
	end
	if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
		return
	end
	if script.Parent:IsDescendantOf(Player.Character) then
		if Pin == false then
			Pin = true
			script.Parent.Handle.Pin:Play()
		else 
			if Used ~= true then
				game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.Flashbang:Fire(script.Parent.Handle:Clone(), Player)
				script.Parent:Destroy()
			end
		end
	end
end)]]
	elseif v.Parent.Name == "[Flashlight]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local Debounce = false

script.Parent.Activated:Connect(function()
	if Debounce then
		return
	end
	if script.Parent:IsDescendantOf(Player.Character) then
		pcall(function()
			if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
				return
			end
			if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
				return
			end
			if Player.Character:FindFirstChild('Christmas_Sock') then
				return
			end
			if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
				return
			end
			if Player.Character.BodyEffects.Reload.Value ~= false then
				return
			end
			task.spawn(function()
				Debounce = true
				task.wait(0.5)
				Debounce = false
			end)
			script.Parent.Handle.Sound:Play()
			script.Parent.Handle.SpotLight.Enabled = not script.Parent.Handle.SpotLight.Enabled
		end)
	end
end)]]
	elseif v.Parent.Name == "[Grenade]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local Used = false
local Pin = false

script.Parent.Activated:Connect(function()
	if Used then
		return
	end
	if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
		return
	end
	if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
		return
	end
	if Player.Character:FindFirstChild('Christmas_Sock') then
		return
	end
	if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
		return
	end
	if script.Parent:IsDescendantOf(Player.Character) then
		if Pin == false then
			Pin = true
			script.Parent.Handle.Pin:Play()
		else 
			if Used ~= true then
				game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.Grenade:Fire(script.Parent.Handle:Clone(), Player)
				script.Parent:Destroy()
			end
		end
	end
end)]]
	elseif v.Parent.Name == "[HeavyWeights]" then
		source = [[local Equipped = false
local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

script.Parent.Activated:Connect(function()
	if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
		return
	end
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
			return
		end
		if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
			return
		end
		if Player.Character:FindFirstChild('Christmas_Sock') then
			return
		end
		if Player.Character.BodyEffects.Reload.Value ~= false then
			return
		end
		_G.PlayerData.Players[Player].Debounces.Action.Action = true
		if not Player.DataFolder.Information:FindFirstChild('MuscleInformation') then
			local MuscleInformation = Instance.new('StringValue', Player.DataFolder.Information)
			MuscleInformation.Name = 'MuscleInformation'
			MuscleInformation.Value = tostring(2)
		else
			if tonumber(Player.DataFolder.Information.MuscleInformation.Value) + 2 < game:GetService('ReplicatedStorage').MaxMuscle.Value then
				Player.DataFolder.Information.MuscleInformation.Value = tostring(tonumber(Player.DataFolder.Information.MuscleInformation.Value) + 2)
			else
				Player.DataFolder.Information.MuscleInformation.Value = tostring(game:GetService('ReplicatedStorage').MaxMuscle.Value)
			end
		end
		local Animation = Instance.new('Animation')
		Animation.AnimationId = 'rbxassetid://11831738782'
		local AnimationTrack = Player.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(Animation)
		AnimationTrack:Play()
		task.wait(5)
		pcall(function()
			_G.PlayerData.Players[Player].Debounces.Action.Action = false
			AnimationTrack:Stop()
		end)
	end
end)

script.Parent.Equipped:Connect(function()
	Equipped = true
end)

script.Parent.Unequipped:Connect(function()
	Equipped = false
end)]]
	elseif v.Parent.Name == "[Key]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local Used = false

script.Parent.Equipped:Connect(function()
	pcall(function()
		if Used then
			return
		end
		if Player.Character.BodyEffects['K.O'].Value ~= false then
			return
		end
		if Player.Character.BodyEffects['Grabbed'].Value ~= nil then
			return
		end
		if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
			return
		end
		if Player.Character:FindFirstChild('Christmas_Sock') then
			return
		end
		if Player.DataFolder.Officer.Value ~= 0 then
			return
		end
		if script.Parent:IsDescendantOf(Player.Character) then
			if Player.DataFolder.Information:FindFirstChild('Jail') then
				local Jail = Player.DataFolder.Information.Jail
				if Player.Character.BodyEffects.Cuff.Value == true then
					if tonumber(Jail.Value) > 0 and tonumber(Jail.Value) <= 250 then
						Player.Character.BodyEffects.Cuff.Value = false 
						Player.Character.LeftLowerArm.CUFF.Transparency = 1
						Player.Character.RightLowerArm.CUFF.Transparency = 1
						Jail.Value = tostring(0)
						Used = true
						for i,v in pairs(Player.Character:FindFirstChildOfClass('Humanoid'):GetPlayingAnimationTracks()) do
							if v.Animation.AnimationId == 'rbxassetid://11831740805' then
								v:Stop()
								v:Destroy()
							end
						end
						script.Parent:Destroy()
					end
				end
			end
		end
	end)
end)

script.Parent.Activated:Connect(function()
	if Used then
		return
	end
	if Player.Character.BodyEffects['K.O'].Value ~= false then
		return
	end
	if Player.DataFolder.Officer.Value ~= 0 then
		return
	end
	pcall(function()
		if script.Parent:IsDescendantOf(Player.Character) then
			local HRP = Player.Character.HumanoidRootPart
			for i,v in pairs(workspace.Players:GetChildren()) do 
				if v:FindFirstChild('HumanoidRootPart') then
					if (HRP.Position - v.HumanoidRootPart.Position).magnitude < 10 then
						if v:FindFirstChild('BodyEffects') then
							if v.BodyEffects:FindFirstChild('Cuff') then
								if v.BodyEffects.Cuff.Value == true then
									local Plr = game:GetService('Players'):GetPlayerFromCharacter(v)
									if Plr then
										if Plr.DataFolder.Information:FindFirstChild('Jail') then
											local Jail = Plr.DataFolder.Information.Jail
											if tonumber(Jail.Value) > 0 and tonumber(Jail.Value) <= 250 then
												local Character = v
												Character.BodyEffects.Cuff.Value = false 
												Character.LeftLowerArm.CUFF.Transparency = 1
												Character.RightLowerArm.CUFF.Transparency = 1
												Jail.Value = tostring(0)
												Used = true
												for i,v in pairs(Character:FindFirstChildOfClass('Humanoid'):GetPlayingAnimationTracks()) do
													if v.Animation.AnimationId == 'rbxassetid://11703413428' then
														v:Stop()
														v:Destroy()
													end
												end
												script.Parent:Destroy()
												break
											end
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "[Knife]" then
		source = [[local BodyParts = {"Head","LeftFoot","LeftHand","LeftLowerArm","LeftLowerLeg","LeftUpperArm","LeftUpperLeg","LowerTorso","RightFoot","RightHand","RightLowerArm","RightLowerLeg","RightUpperArm","RightUpperLeg","UpperTorso","HumanoidRootPart"}
local anim1 = Instance.new("Animation")
anim1.AnimationId = "rbxassetid://11870085564" 
local db = {}
script.Parent.Activated:Connect(function()
	local plr = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
	if db[plr] == true then return end
	if plr.Character.BodyEffects.Reload.Value == true then return end
	if plr.Character:FindFirstChild("FULLY_LOADED_CHAR") == nil then return end
	if plr.Character.BodyEffects.Attacking.Value == true then return end
	plr.Character.BodyEffects.Attacking.Value = true
	db[plr] = true
	local anim1Track = plr.Character.Humanoid:LoadAnimation(anim1)
	local hit = Instance.new("Folder")
	local function DoDamage(humanoid, character,ATM)
		if ATM == false then
			local theplr = game.Players:GetPlayerFromCharacter(humanoid.Parent)
			if not character.UpperTorso:FindFirstChild(plr.Name.."HIT") then
				hit.Parent = character.UpperTorso
				hit.Name = plr.Name.."HIT"
				if theplr.DataFolder.Crew.Value == plr.DataFolder.Crew.Value and theplr.DataFolder.Information.Crew.Value ~= 0 then
					humanoid.Health = math.clamp(humanoid.Health - 0, 0.2, humanoid.MaxHealth)
					local HITSOUND = Instance.new("Sound", character.HumanoidRootPart)
					HITSOUND.SoundId = "rbxassetid://566593606"
					HITSOUND:Play()
				else
					humanoid.Health = math.clamp(humanoid.Health - 35, 0.2, humanoid.MaxHealth)
					local HITSOUND = Instance.new("Sound", character.HumanoidRootPart)
					HITSOUND.SoundId = "rbxassetid://566593606"
					HITSOUND:Play()
				end
			end
		else
			if humanoid.Parent:FindFirstChild(plr.Name.."HIT") then return end
			humanoid.Parent.Head.Punch:Play()
			hit.Parent = humanoid.Parent
			hit.Name = plr.Name.."HIT"
			humanoid:TakeDamage(35)
		end
	end
	anim1Track:Play()
	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist
	params.FilterDescendantsInstances = {
		workspace.Ignored,
		plr,
		plr.Character,
	}
	local Direction = plr.Character.HumanoidRootPart.CFrame.p + plr.Character.HumanoidRootPart.CFrame.LookVector * 60 
	local oer = 4.5+(plr.DataFolder.Information.MuscleInformation.Value/2)
	local dire =  (Direction-plr.Character.UpperTorso.Position).Unit * oer
	local StringValue = Instance.new("StringValue", plr.Character.BodyEffects.Movement)
	StringValue.Name = "ReduceWalk"
	local StringValue2 = Instance.new("StringValue", plr.Character.BodyEffects.Movement)
	StringValue2.Name = "NoJumping"
	repeat wait()
		local ray = workspace:Raycast(plr.Character.HumanoidRootPart.Position,dire, params)
		if ray then
			if ray.Instance:IsDescendantOf(workspace.Players) then
				if ray.Instance.Name == "Handle" then
					local CharOfShotPlayer = ray.Instance.Parent.Parent
					if CharOfShotPlayer:FindFirstChild("FULLY_LOADED_CHAR") then
						DoDamage(CharOfShotPlayer.Humanoid,CharOfShotPlayer,false)
					end
				elseif table.find(BodyParts, ray.Instance.Name) then
					local CharOfShotPlayer
					if ray.Instance.Parent.Name == "SpecialParts" then
						CharOfShotPlayer = ray.Instance.Parent.Parent.Parent
					else
						CharOfShotPlayer = ray.Instance.Parent
					end
					if CharOfShotPlayer:FindFirstChild("FULLY_LOADED_CHAR") then
						DoDamage(CharOfShotPlayer.Humanoid,CharOfShotPlayer,false)
					end
				end
			elseif ray.Instance:IsDescendantOf(workspace.Cashiers) then
				DoDamage(ray.Instance.Parent.Humanoid, nil, true)
			end
		end
	until anim1Track.isPlaying == false
	StringValue:Destroy()
	StringValue2:Destroy()
	hit:Destroy()
	db[plr] = false
	plr.Character.BodyEffects.Attacking.Value = false
end)
]]
	elseif v.Parent.Name == "[Lettuce]" then
		source = [[local Tool = script.Parent
local EatSound = Instance.new("Sound")
EatSound.SoundId = "rbxassetid://101083978"
local EatAnim = Instance.new("Animation")
EatAnim.AnimationId = "rbxassetid://12377226506"
local EatTrack
--
local Eat1Toggle = Instance.new("BoolValue")
Eat1Toggle.Value = false
local Eat2Toggle = Instance.new("BoolValue")
Eat2Toggle.Value = false
local Eat3Toggle = Instance.new("BoolValue")
Eat3Toggle.Value = false
local Eat4Toggle = Instance.new("BoolValue")
Eat4Toggle.Value = false
local Eat5Toggle = Instance.new("BoolValue")
Eat5Toggle.Value = false
--
enabled = false
Tool.Activated:Connect(function()
	if Eat1Toggle.Value == false then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatSound.Parent = rootpart
		EatTrack:Play()
		Eat1Toggle.Value = true
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat1Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = true
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat2Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = true
		Eat4Toggle.Value = false
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat3Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = true
		Eat5Toggle.Value = false
		hum.Health = hum.Health + 15
		wait(1)
		enabled = false
	end
end)
Tool.Activated:Connect(function()
	if Eat4Toggle.Value == true then
		if enabled then
			return
		end
		local vCharacter = Tool.Parent
		local hum = vCharacter:FindFirstChild("Humanoid")
		local rootpart = vCharacter:FindFirstChild("HumanoidRootPart")
		enabled = true
		EatTrack = script.Parent.Parent.Humanoid:LoadAnimation(EatAnim)
		EatTrack.Priority = Enum.AnimationPriority.Action
		EatTrack.Looped = false
		EatSound:Play()
		EatTrack:Play()
		Eat1Toggle.Value = false
		Eat2Toggle.Value = false
		Eat3Toggle.Value = false
		Eat4Toggle.Value = false
		Eat5Toggle.Value = true
		hum.Health = hum.Health + 15
		wait(1.5)
		Tool:Destroy()
		enabled = false
	end
end)

local Equipped = false
local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

script.Parent.Activated:Connect(function()
	if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
		return
	end
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
			return
		end
		if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
			return
		end
		if Player.Character:FindFirstChild('Christmas_Sock') then
			return
		end
		if Player.Character.BodyEffects.Reload.Value ~= false then
			return
		end
		_G.PlayerData.Players[Player].Debounces.Action.Action = true
		if not Player.DataFolder.Information:FindFirstChild('MuscleInformation') then
			local MuscleInformation = Instance.new('StringValue', Player.DataFolder.Information)
			MuscleInformation.Name = 'MuscleInformation'
			MuscleInformation.Value = '0'
			MuscleInformation.Value = tostring(75)
		else
			if tonumber(Player.DataFolder.Information.MuscleInformation.Value) - 15000 > -15000 then
				Player.DataFolder.Information.MuscleInformation.Value = tostring(tonumber(Player.DataFolder.Information.MuscleInformation.Value) - 15000)
			else
				Player.DataFolder.Information.MuscleInformation.Value = tostring(-15000)
			end
		end
		pcall(function()
			Player.Character:FindFirstChildOfClass('Humanoid').Health += 25
		end)
		local Animation = Instance.new('Animation')
		Animation.AnimationId = 'rbxassetid://11816201135'
		local AnimationTrack = Player.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(Animation)
		AnimationTrack:Play()
		local Sound = Instance.new('Sound', script.Parent.Handle)
		Sound.Name = 'Eat'
		Sound.Volume = 1
		Sound.SoundId = 'rbxassetid://101083978'
		Sound:Play()
		AnimationTrack.Stopped:Connect(function()
			task.wait(.1)
			_G.PlayerData.Players[Player].Debounces.Action.Action = false
			script.Parent:Destroy()
		end)
	end
end)

script.Parent.Equipped:Connect(function()
	Equipped = true
end)

script.Parent.Unequipped:Connect(function()
	Equipped = false
end)]]
	elseif v.Parent.Name == "[LockPicker]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local Debounce = false

script.Parent.Activated:Connect(function()
	if Debounce then
		return
	end
	if not Player:FindFirstChild('LOAD_SAVE_DATA') then
		return
	end
	if script.Parent:IsDescendantOf(Player.Character) then
		pcall(function()
			if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
				return
			end
			if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
				return
			end
			if Player.Character:FindFirstChild('Christmas_Sock') then
				return
			end
			if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
				return
			end
			if Player.Character.BodyEffects.Reload.Value ~= false then
				return
			end
			if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
				for i,v in pairs(workspace.MAP:GetDescendants()) do
					if v.Name == 'Door' and v:IsA('Model') then
						local Door = v 
						if Door:FindFirstChild('LOCKKK') then
							if Door:FindFirstChild('Lock') then
								if Door.Lock:IsA('Model') then
									if Door.Lock:FindFirstChild('Locker') then
										local Lock = Door.Lock.Locker
										if (script.Parent.Handle.Position - Lock.Position).magnitude < 2 then
											Debounce = true
											local Result = require(game:GetService('ReplicatedStorage').RemoteFunction).InvokeClient(nil, Player, 'LOCK_PICK')
											if Result == true then
												if Door:FindFirstChild('LOCKKK') then
													Door.LOCKKK.Name = 'UnLOCK'
													Door.Door.Lock:Play()
													Lock.CFrame = Lock.CFrame * CFrame.Angles(0, 0, math.rad(-90))
													script.Parent:Destroy()
												end
											end
											task.spawn(function()
												
												Debounce = false
											end)
										end
									end
								end
							end
						end
					end
				end
			end
		end)
	end
end)]]
	elseif v.Parent.Name == "[Money Gun]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local Equipped = false
local Debounce = false 
local Drops = _G.PlayerData.Players[Player].Stats.Misc.Data.Drops
local Changed

script.Parent.Activated:Connect(function()
	if Debounce == true then
		return
	end
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
			return
		end
		if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
			return
		end
		if Player.Character:FindFirstChild('Christmas_Sock') then
			return
		end
		if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
			return
		end
		if Player.Character.BodyEffects.Reload.Value ~= false then
			return
		end
		if Player.DataFolder.Currency.Value >= 100 then
			if #Drops < 10 then
				task.spawn(function()
					if Debounce ~= true then
						Debounce = true
						task.wait(10)
						Debounce = false
					end
				end)
				local Amount = 10 - #Drops 
				script.Parent.Handle.Shoot:Play()
				for i = 1, Amount do 
					if Player.DataFolder.Currency.Value >= 100 then
						local Money = game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.SpawnCash:Invoke(Player, 'Paid', script.Parent.Handle.CFrame * CFrame.new(-2.2, 0, 0), Vector3.new(0, 0.65, 0), 100, Player.Character.HumanoidRootPart.CFrame.LookVector * 24)
						table.insert(Drops, Money)
						task.wait(0.3)
					end
				end
				script.Parent.Handle.Shoot:Stop()
			end
		end
	end
end)

script.Parent.Equipped:Connect(function()
	Drops = _G.PlayerData.Players[Player].Stats.Misc.Data.Drops	
	Equipped = true
	script.Parent.Handle.BillboardGui.Enabled = true
	script.Parent.Handle.BillboardGui.TextLabel.Text = '$'..require(game:GetService('ReplicatedStorage').MainModule).AddComma(Player.DataFolder.Currency.Value)
	if Changed then
		Changed:Disconnect()
	end
	Changed = Player.DataFolder.Currency:GetPropertyChangedSignal('Value'):Connect(function()
		script.Parent.Handle.BillboardGui.TextLabel.Text = '$'..require(game:GetService('ReplicatedStorage').MainModule).AddComma(Player.DataFolder.Currency.Value)
	end)
end)

script.Parent.Unequipped:Connect(function()
	Equipped = false
	script.Parent.Handle.BillboardGui.Enabled = false
end)

workspace.Ignored.Drop.ChildRemoved:Connect(function(Child)
	if table.find(Drops, Child) then
		table.remove(Drops, table.find(Drops, Child))
	end
end)]]
	elseif v.Parent.Name == "[PepperSpray]" then
		source = [[local GunModule = require(game.ServerStorage.Modules.GunModule)

local GetPlayer = (script.Parent:FindFirstAncestorWhichIsA("Player") or script.Parent:FindFirstAncestorWhichIsA("Model"))
local Player = game:GetService("Players"):WaitForChild(GetPlayer.Name)

local OwnerTag = script.Parent.OwnerTag
GunModule.SetOwnerTag(OwnerTag, script.Parent, Player)


local DB = false
local val, blood, reducewalk, playanimation
local oldface = nil
local Character1
local Value = 0
local touched = false
script.Parent.Activated:Connect(function()
	if GunModule.Activated(Player, script.Parent) then
		if DB == false then
			DB = true
			script.Parent.Handle.Spray:Play()
			script.Parent.Handle.Smoke.Enabled = true
			script.Parent.Default.Touched:Connect(function(touched)
				if touched.Parent:FindFirstChild("Humanoid") and script.Parent.Handle.Smoke.Enabled == true then
					if touched.Name == "Head" then
						local Character = touched.Parent
						local BodyEffects = touched.Parent:FindFirstChild("BodyEffects")
						Character1 = Character
						touched = true
						if not BodyEffects:FindFirstChild("PepperSpray") then
							val = Instance.new("IntValue", BodyEffects)
							val.Name = "PepperSpray"
							reducewalk = Instance.new("IntValue", BodyEffects.Movement)
							reducewalk.Name = "ReduceWalk"
							
							if oldface == nil then
								oldface = Character.Head.face.Texture
							end
							Character.Head.face.Texture = "http://www.roblox.com/asset/?id=879265491"
							blood = Instance.new("Decal", Character.Head)
							blood.Texture = "rbxassetid://1927066320"
							blood.Transparency = 0.3
							playanimation = Character.Humanoid:LoadAnimation(game.StarterGui.Framework.FBAnimation)
							playanimation:Play()
							playanimation:AdjustSpeed(0.5)
							for i = 1, 10 do
								Value += 1
								if Value <= 10 then
									Character.Humanoid:TakeDamage(6)
								end
								wait(1)
							end 
						end
					end
				end
			end)
			task.wait(1.5)
			script.Parent.Handle.Spray:Stop()
			script.Parent.Handle.Smoke.Enabled = false
			task.wait(1)
			DB = false
		end
	end
end)
while true do
	if Value == 10 then
		val:Destroy()
		reducewalk:Destroy()
		blood:Destroy()
		playanimation:Stop()
		Character1.Head.face.Texture = oldface
		Value = 0
		touched = false
		oldface = nil
	end
	wait(1)
end]]
	elseif v.Parent.Name == "[SprayCan]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local TweenService = game:GetService('TweenService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local Module = require(ReplicatedStorage.MainModule)
local Range = 12.5
local Debounce = false

script.Parent.Activated:Connect(function()
	pcall(function()
		if Player.Character then
			if script.Parent:IsDescendantOf(Player.Character) then
				if Player.Character:FindFirstChild('BodyEffects') then
					if not Module.CheckInCrew(Player) then
						script.Parent:Destroy()
					end
					if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if Player.Character.BodyEffects.Reload.Value ~= false then
						return
					end
					local Graffiti = {}
					for i,v in pairs(workspace.MAP.Graffiti:GetChildren()) do
						if v.Name == Player.Name then
							table.insert(Graffiti, v)
						end
					end
					if Debounce then
						return
					end
					if #Graffiti < 8 then
						if Player.Character:FindFirstChild('HumanoidRootPart') then
							Debounce = true
							local Position = ReplicatedStorage.RemoteFunction.RemoteFunction:InvokeClient(Player, 'MOUSEPOS')
							if (Player.Character.HumanoidRootPart.Position - Position).magnitude <= Range then
								task.spawn(function()
									task.spawn(function()
										script.Parent.Handle.Spray:Play()
										script.Parent.Handle.Smoke.Enabled = true
										task.wait(1.5)
										script.Parent.Handle.Smoke.Enabled = false
									end)
									task.wait(2.5)
									Debounce = false
								end)
								local rayParams = RaycastParams.new()
								rayParams.FilterType = Enum.RaycastFilterType.Blacklist
								rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
								rayParams.IgnoreWater = true
								local ray = Ray.new(script.Parent.Handle.Position, (Position - script.Parent.Handle.Position).Unit * 25)
								local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams)
								local Image = Module.GroupImage(Player)
								local Template = game:GetService('ServerStorage').Storage.Misc.Graffiti.Template:Clone()
								Template.Name = Player.Name
								Template.Decal.Texture = Image
								Template.Decal.Transparency = 1
								Template.CFrame = CFrame.new(result.Position, result.Position + result.Normal)
								Template.Parent = workspace.MAP.Graffiti
								local Info = TweenInfo.new(1)
								local Tween = TweenService:Create(Template.Decal, Info, {Transparency = 0})
								Tween:Play()
								Player.DataFolder.Currency.Value += 4
							else 
								Debounce = false
							end
						end
					end
				end
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "[Surgeon Mask]" then
		source = [[local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

local Connection = nil

script.Parent.Activated:Connect(function()
	if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
		return
	end
	if script.Parent:IsDescendantOf(Player.Character) then
		pcall(function()
			if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
				return
			end
			if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
				return
			end
			if Player.Character:FindFirstChild('Christmas_Sock') then
				return
			end
			if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
				return
			end
			if Player.Character.BodyEffects.Reload.Value ~= false then
				return
			end
			task.spawn(function()
				_G.PlayerData.Players[Player].Debounces.Action.Action = true
				task.wait(1.25)
				_G.PlayerData.Players[Player].Debounces.Action.Action = false
			end)
			local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
			local Mask = Player.Character.BodyEffects.Mask.Value
			local Hat = game:GetService('ServerStorage').Storage.Tools.Misc.Masks["[Surgeon Mask]"]:FindFirstChildOfClass('Accessory'):Clone()
			local Weld1 = Hat.Handle.AccessoryWeld
			local Weld2 = Hat:FindFirstChildOfClass('Model').Weld
			Weld1.Part0 = Weld1.Parent
			Weld1.Part1 = Weld1.Parent.Parent:FindFirstChildOfClass('Model').Head
			Weld2.Part0 = Weld2.Parent.Head
			Weld2.Part1 = Player.Character.Head
			if Player.Character:FindFirstChild('In-gameMask') then
				if Connection ~= nil then
					Connection:Disconnect()
					Connection = nil
				end
				Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.Viewer
				Player.Character['In-gameMask']:Destroy()
				local Animation = Instance.new('Animation')
				Animation.AnimationId = 'rbxassetid://12377279227'
				local Track = Humanoid:LoadAnimation(Animation)
				Track:Play()
			else 
				if Connection ~= nil then
					Connection:Disconnect()
					Connection = nil
				end
				pcall(function()
					Hat:FindFirstChildOfClass('Model'):FindFirstChildOfClass('Humanoid').Health = Humanoid.Health
					Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
					Connection = Humanoid:GetPropertyChangedSignal('Health'):Connect(function()
						Hat:FindFirstChildOfClass('Model'):FindFirstChildOfClass('Humanoid').Health = Humanoid.Health
					end)
					Hat.Parent = Player.Character
				end)
				local Animation = Instance.new('Animation')
				Animation.AnimationId = 'rbxassetid://12377282666'
				local Track = Humanoid:LoadAnimation(Animation)
				Track:Play()
			end
		end)
	end
end)]]
	elseif v.Parent.Name == "[Weights]" then
		source = [[local Equipped = false
local Player

script.Parent:WaitForChild('OwnerTag')
Player = script.Parent.OwnerTag.Value

script.Parent.Activated:Connect(function()
	if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
		return
	end
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		if (Player.Character.BodyEffects.Cuff.Value ~= false or Player.Character.BodyEffects['K.O'].Value ~= false or Player.Character.BodyEffects['Grabbed'].Value ~= nil) then
			return
		end
		if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
			return
		end
		if Player.Character:FindFirstChild('Christmas_Sock') then
			return
		end
		if Player.Character.BodyEffects.Reload.Value ~= false then
			return
		end
		_G.PlayerData.Players[Player].Debounces.Action.Action = true
		if not Player.DataFolder.Information:FindFirstChild('MuscleInformation') then
			local MuscleInformation = Instance.new('StringValue', Player.DataFolder.Information)
			MuscleInformation.Name = 'MuscleInformation'
			MuscleInformation.Value = tostring(1)
		else
			if tonumber(Player.DataFolder.Information.MuscleInformation.Value) + 1 < game:GetService('ReplicatedStorage').MaxMuscle.Value then
				Player.DataFolder.Information.MuscleInformation.Value = tostring(tonumber(Player.DataFolder.Information.MuscleInformation.Value) + 1)
			else
				Player.DataFolder.Information.MuscleInformation.Value = tostring(game:GetService('ReplicatedStorage').MaxMuscle.Value)
			end
		end
		local Animation = Instance.new('Animation')
		Animation.AnimationId = 'rbxassetid://11831738782'
		local AnimationTrack = Player.Character:FindFirstChildOfClass('Humanoid'):LoadAnimation(Animation)
		AnimationTrack:Play()
		task.wait(5)
		pcall(function()
			_G.PlayerData.Players[Player].Debounces.Action.Action = false
			AnimationTrack:Stop()
		end)
	end
end)

script.Parent.Equipped:Connect(function()
	Equipped = true
end)

script.Parent.Unequipped:Connect(function()
	Equipped = false
end)]]
	elseif v.Parent.Name == "[AK47]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local Firing = false
local Loop = nil
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local Config = {
	Damage = 14,
	Cooldown = 1/8,
	Stopped = false,
	CooldownAfterStopped = 0.2,
	Range = 250,
	LastFX = 0,
	Color = 'Default'
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if script.Parent.Ammo.Value > 0 then
					if Config.Stopped == true then
						return
					end
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					if Loop ~= nil then
						return
					end
					Firing = true
					Loop = RunService.Heartbeat:Connect(function()
						if not script.Parent:IsDescendantOf(Player.Character) then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Reload.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Cuff.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['K.O'].Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['Grabbed'].Value ~= nil then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects:FindFirstChild('Block') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Attacking.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('Christmas_Sock') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.GunFiring.Value ~= false then
							return
						end
						script.Parent.Ammo.Value -= 1
						local Sound = script.Parent.Handle.ShootSound:Clone()
						Sound.Parent = script.Parent.Handle
						Sound:Play()
						Sound.Ended:Connect(function()
							Sound:Destroy()
						end)
						task.spawn(function()
							task.wait(.05)
							local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						end)
						local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
						BodyEffects.GunFiring.Value = true
						CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
						task.spawn(function()
							if tick() - Config.LastFX < 0.2 then
								Config.LastFX = tick()
								return
							end
							local last = tick()
							Config.LastFX = last
							task.wait(0.2)
							pcall(function()
								task.spawn(function()
									pcall(function()
										script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
										script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
										local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										task.spawn(function()
											local Check
											Check = RunService.Heartbeat:Connect(function()
												if last ~= Config.LastFX then
													Tween:Cancel()
													Check:Disconnect()
												end
											end)
										end)
										Tween.Completed:Connect(function()
											local Info = TweenInfo.new(0.1)
											local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
											Tween:Play()
											Tween.Completed:Connect(function()
												script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
											end)
										end)
									end)
								end)
							end)
						end)
						task.wait(Config.Cooldown)
						pcall(function()
							ReduceWalk:Destroy()
							BodyEffects.GunFiring.Value = false
						end)
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Deactivated:Connect(function()
	Firing = false
	if Loop then
		task.spawn(function()
			if Config.Stopped ~= true then
				Config.Stopped = true
				task.wait(Config.CooldownAfterStopped)
				Config.Stopped = false
			end
		end)
		Loop:Disconnect()
		Loop = nil
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
	pcall(function()
		local function Play(Humanoid)
			local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
			local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
			local Track = Humanoid:LoadAnimation(Animation)
			Track:Play()
			Track.Stopped:Connect(function()
				if script.Parent:IsDescendantOf(Player.Character) then
					Play()
				end
			end)
		end
		Play()
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
		local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
		for i,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
			if v.Animation.AnimationId == Animation.AnimationId then
				v:Stop()
				v:Destroy()
				break
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "[AR]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local Firing = false
local Loop = nil
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local Config = {
	Damage = 10,
	Cooldown = 1/10,
	Stopped = false,
	CooldownAfterStopped = 0.2,
	Range = 250,
	LastFX = 0,
	Color = 'Default',
	Particle = 'None'
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end		
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	if Config.Particle ~= 'None' then
		if Config.Particle == 'Halloween' then
			local Particles = game:GetService('ServerStorage').Storage.Misc.Particles.ShootFX.HalloweenAR:GetChildren()
			local Particle = Particles[math.random(1, #Particles)]:Clone()
			Particle.Parent = Attachment0
			Particle:Emit(4)
		end
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if script.Parent.Ammo.Value > 0 then
					if Config.Stopped == true then
						return
					end
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					if Loop ~= nil then
						return
					end
					Firing = true
					Loop = RunService.Heartbeat:Connect(function()
						if not script.Parent:IsDescendantOf(Player.Character) then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Reload.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Cuff.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['K.O'].Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['Grabbed'].Value ~= nil then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects:FindFirstChild('Block') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Attacking.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('Christmas_Sock') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.GunFiring.Value ~= false then
							return
						end
						script.Parent.Ammo.Value -= 1
						local Sound = script.Parent.Handle.ShootSound:Clone()
						Sound.Parent = script.Parent.Handle
						Sound:Play()
						Sound.Ended:Connect(function()
							Sound:Destroy()
						end)
						task.spawn(function()
							task.wait(.05)
							local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						end)
						local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
						BodyEffects.GunFiring.Value = true
						CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
						task.spawn(function()
							if tick() - Config.LastFX < 0.2 then
								Config.LastFX = tick()
								return
							end
							local last = tick()
							Config.LastFX = last
							task.wait(0.2)
							pcall(function()
								task.spawn(function()
									pcall(function()
										script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
										script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
										local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										task.spawn(function()
											local Check
											Check = RunService.Heartbeat:Connect(function()
												if last ~= Config.LastFX then
													Tween:Cancel()
													Check:Disconnect()
												end
											end)
										end)
										Tween.Completed:Connect(function()
											local Info = TweenInfo.new(0.1)
											local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
											Tween:Play()
											Tween.Completed:Connect(function()
												script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
											end)
										end)
									end)
								end)
							end)
						end)
						task.wait(Config.Cooldown)
						pcall(function()
							ReduceWalk:Destroy()
							BodyEffects.GunFiring.Value = false
						end)
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Deactivated:Connect(function()
	Firing = false
	if Loop then
		task.spawn(function()
			if Config.Stopped ~= true then
				Config.Stopped = true
				task.wait(Config.CooldownAfterStopped)
				Config.Stopped = false
			end
		end)
		Loop:Disconnect()
		Loop = nil
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	if typeof(Color) ~= 'table' then
		Config.Particle = 'None'
		Config.Color = Color
	else 
		if Color[1] == 'Halloween' then
			Config.Particle = Color[1]
			Config.Color = Color[2]
		end
	end
	pcall(function()
		local function Play(Humanoid)
			local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
			local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
			local Track = Humanoid:LoadAnimation(Animation)
			Track:Play()
			Track.Stopped:Connect(function()
				if script.Parent:IsDescendantOf(Player.Character) then
					Play()
				end
			end)
		end
		Play()
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
		local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
		for i,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
			if v.Animation.AnimationId == Animation.AnimationId then
				v:Stop()
				v:Destroy()
				break
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "[AUG]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local Config = {
	Damage = 16.25,
	Cooldown = 0.6,
	Burst = {
		Count = 3,
		Interval = 0.08
	},
	Range = 250,
	Color = 'Default'
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Reload.Value ~= false or Character.BodyEffects['K.O'].Value == true) then
					return
				end
				if (BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
					return
				end
				if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
					return
				end
				if Player.Character:FindFirstChild('Christmas_Sock') then
					return
				end
				if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
					return
				end
				if BodyEffects.Attacking.Value ~= false then
					return
				end
				if BodyEffects:FindFirstChild('Block') then
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
					return
				end
				if script.Parent.Ammo.Value >= Config.Burst.Count then
					local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
					for i = 1, Config.Burst.Count do
						script.Parent.Ammo.Value -= 1
						local Sound = script.Parent.Handle.ShootSound:Clone()
						Sound.Parent = script.Parent.Handle
						Sound:Play()
						Sound.Ended:Connect(function()
							Sound:Destroy()
						end)
						task.spawn(function()
							task.wait(.05)
							local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						end)
						BodyEffects.GunFiring.Value = true
						CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
						task.spawn(function()
							task.wait(0.2)
							pcall(function()
								task.spawn(function()
									pcall(function()
										script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
										script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										Tween.Completed:Connect(function()
											local Info = TweenInfo.new(0.1)
											local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
											Tween:Play()
											Tween.Completed:Connect(function()
												script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
											end)
										end)
									end)
								end)
							end)
						end)
						task.wait(Config.Burst.Interval)
					end
					task.wait(Config.Cooldown)
					pcall(function()
						ReduceWalk:Destroy()
						BodyEffects.GunFiring.Value = false
					end)
				else
					if script.Parent.Ammo.Value > 0 then
						local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
						for i = 1, script.Parent.Ammo.Value do
							script.Parent.Ammo.Value -= 1
							local Sound = script.Parent.Handle.ShootSound:Clone()
							Sound.Parent = script.Parent.Handle
							Sound:Play()
							Sound.Ended:Connect(function()
								Sound:Destroy()
							end)
							task.spawn(function()
								task.wait(.05)
								local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
							end)
							BodyEffects.GunFiring.Value = true
							CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
							task.spawn(function()
								task.wait(0.2)
								pcall(function()
									task.spawn(function()
										pcall(function()
											script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
											script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
											local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
											local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
											Tween:Play()
											Tween.Completed:Connect(function()
												local Info = TweenInfo.new(0.1)
												local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
												Tween:Play()
												Tween.Completed:Connect(function()
													script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
												end)
											end)
										end)
									end)
								end)
							end)
							task.wait(0.15)
						end
						task.wait(Config.Cooldown)
						pcall(function()
							ReduceWalk:Destroy()
							BodyEffects.GunFiring.Value = false
						end)
					else 
						if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
							return
						end
						if BodyEffects.Reload.Value ~= false then
							return
						end
						if BodyEffects.Attacking.Value ~= false then
							return
						end
						if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
							return
						end
						if Player.Character:FindFirstChild('Christmas_Sock') then
							return
						end
						if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
							return
						end
						if BodyEffects:FindFirstChild('Block') then
							script.Parent.Handle.NoAmmo:Play()
							RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
							BodyEffects.GunFiring.Value = true
							task.wait(0.3)
							pcall(function()
								BodyEffects.GunFiring.Value = false
							end)
							return
						end
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
					end
				end
			end
		end
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
	pcall(function()
		local function Play(Humanoid)
			local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
			local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
			local Track = Humanoid:LoadAnimation(Animation)
			Track:Play()
			Track.Stopped:Connect(function()
				if script.Parent:IsDescendantOf(Player.Character) then
					Play()
				end
			end)
		end
		Play()
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
		local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
		for i,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
			if v.Animation.AnimationId == Animation.AnimationId then
				v:Stop()
				v:Destroy()
				break
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "[Double-Barrel SG]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local RunService = game:GetService('RunService')
local Config = {
	Damage = 35,
	Cooldown = 0.3,
	Range = 250,
	CanShoot = true,
	ShowsStars = false,
	Color = 'Default',
	LastFX = 0
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(ActualMouse, Position, Mouse, RandomNum)
	local result = Raycast(Position, Mouse)
	local Distance = (ActualMouse - Position).magnitude
	local DMGMultiplier = 1
	if Distance < 5 then 
		DMGMultiplier = 1.5
	elseif Distance >= 5 and Distance < 15 then
		DMGMultiplier = 1
	elseif Distance >= 15 and Distance < 25 then
		DMGMultiplier = 0.6
	elseif Distance >= 25 then
		DMGMultiplier = 0.4
	end
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	if Config.ShowsStars == true then
		for i = 1, 2 do 
			local Stars = game:GetService('ServerStorage').Storage.Misc.Particles.ShootFX.StarDB.Stars:Clone()
			Stars.Name = 'ParticleEmitter'
			Stars.Parent = Attachment0
			Stars:Emit(1)
		end
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	local Damage = Config.Damage * DMGMultiplier
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Damage > 0 then
							Humanoid:TakeDamage(Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Damage
								if Humanoid.Health - (Damage) > 0 then
									Humanoid:TakeDamage(Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Damage > 0 then
								Humanoid:TakeDamage(Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Damage * 2
							if Humanoid.Health - (Damage * 2) > 0 then
								Humanoid:TakeDamage((Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Damage * 2 > 0 then
							Humanoid:TakeDamage(Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if Config.CanShoot ~= true then
					return
				end
				if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Reload.Value ~= false or Character.BodyEffects['K.O'].Value == true) then
					return
				end
				if (BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
					return
				end
				if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
					return
				end
				if Player.Character:FindFirstChild('Christmas_Sock') then
					return
				end
				if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
					return
				end
				if BodyEffects.Attacking.Value ~= false then
					return
				end
				if BodyEffects:FindFirstChild('Block') then
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
					return
				end
				if script.Parent.Ammo.Value > 0 then
					script.Parent.Ammo.Value -= 1
					local Sound = script.Parent.Handle.ShootSound:Clone()
					Sound.Parent = script.Parent.Handle
					Sound:Play()
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
					task.spawn(function()
						task.wait(.05)
						local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					end)	
					local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
					BodyEffects.GunFiring.Value = true
					local RandomNum = Random.new():NextNumber(0.3, 0.5)
					local Offsets = {
						{ 
							Vector3.new(0,0.09),
							Vector3.new(0,0.14),
							Vector3.new(0,-0.3),
							Vector3.new(0,-0.22),
							Vector3.new(0,0.2)
						},
						{ 
							Vector3.new(0,-0.15),
							Vector3.new(0,0.14),
							Vector3.new(0,-0.28),
							Vector3.new(0,-0.22),
							Vector3.new(0,0.2)
						},
						{ 
							Vector3.new(0.3,-0.045),
							Vector3.new(-0.38,-0.045),
							Vector3.new(-0.3,-0.045),
							Vector3.new(-0.22,-0.045),
							Vector3.new(0.2,-0.045)
						},
						{ 
							Vector3.new(0.3,0.045),
							Vector3.new(-0.38,0.045),
							Vector3.new(-0.28,0.045),
							Vector3.new(-0.18,0.045),
							Vector3.new(0.2,0.045)
						},
						{
							Vector3.new(-0.23,-0.2),
							Vector3.new(-0.4,-0.33),
							Vector3.new(0.13,0.2),
							Vector3.new(0.05,0.12),
							Vector3.new(-0.32,-0.27)
						},
						{
							Vector3.new(-0.23,-0.2),
							Vector3.new(-0.32,-0.27),
							Vector3.new(0.13,0.2),
							Vector3.new(0.05,0.12),
							Vector3.new(0.2,0.27)
						},
						{
							Vector3.new(0.23,-0.2),
							Vector3.new(0.32,-0.27),
							Vector3.new(-0.13,0.2),
							Vector3.new(-0.05,0.12),
							Vector3.new(-0.2,0.27)
						},
						{
							Vector3.new(0.23,-0.2),
							Vector3.new(0.32,-0.28),
							Vector3.new(-0.13,0.2),
							Vector3.new(0.14,-0.12),
							Vector3.new(-0.2,0.27)
						}

					}
					local Offset = Offsets[math.random(1, #Offsets)]
					for i = 1,5 do 
						local Origin = script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace)
						CreateBullet(BodyEffects.MousePos.Value, Origin, (Origin + (BodyEffects.MousePos.Value - Origin).Unit * 5) - Offset[i], RandomNum)
					end
					task.spawn(function()
						if tick() - Config.LastFX < 0.75 then
							Config.LastFX = tick()
							return
						end
						local last = tick()
						Config.LastFX = last
						task.wait(0.2)
						pcall(function()
							task.spawn(function()
								pcall(function()
									script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
									script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
									local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
									local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
									Tween:Play()
									task.spawn(function()
										local Check
										Check = RunService.Heartbeat:Connect(function()
											if last ~= Config.LastFX then
												Tween:Cancel()
												Check:Disconnect()
											end
										end)
									end)
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.1)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										Tween.Completed:Connect(function()
											script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
										end)
									end)
								end)
							end)
						end)
					end)
					task.wait(Config.Cooldown)
					pcall(function()
						ReduceWalk:Destroy()
						BodyEffects.GunFiring.Value = false
					end)
				else
					if Config.CanShoot ~= true then
						return
					end
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Equipped:Connect(function()
	local Skin = _G.ApplySkin(Player, script.Parent)
	if Skin == true then
		Config.ShowsStars = Skin
		Config.Color = 'Default'
	else 
		Config.ShowsStars = false
		Config.Color = Skin
	end
end)

script.Parent:WaitForChild('Ammo'):GetPropertyChangedSignal('Value'):Connect(function()
	local Ammo = script.Parent.Ammo
	if Ammo.Value == 0 then
		task.spawn(function()
			Config.CanShoot = false
			task.wait(2)
			Config.CanShoot = true
		end)
	end
end)]]
	elseif v.Parent.Name == "[DrumGun]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local Firing = false
local Fired = 0
local Loop = nil
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local Config = {
	Damage = 10,
	Cooldown = 1/11,
	Stopped = false,
	CooldownAfterStopped = 0.2,
	Range = 250,
	LastFX = 0,
	Color = 'Default'
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if script.Parent.Ammo.Value > 0 then
					if Config.Stopped == true then
						return
					end
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					if Loop ~= nil then
						return
					end
					Firing = true
					Loop = RunService.Heartbeat:Connect(function()
						if not script.Parent:IsDescendantOf(Player.Character) then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Reload.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Cuff.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['K.O'].Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['Grabbed'].Value ~= nil then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects:FindFirstChild('Block') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Attacking.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('Christmas_Sock') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.GunFiring.Value ~= false then
							return
						end
						script.Parent.Ammo.Value -= 1
						local Sound = script.Parent.Handle.ShootSound:Clone()
						Sound.Parent = script.Parent.Handle
						Sound:Play()
						Sound.Ended:Connect(function()
							Sound:Destroy()
						end)
						task.spawn(function()
							task.wait(.05)
							local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						end)
						local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
						BodyEffects.GunFiring.Value = true
						CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
						task.spawn(function()
							if tick() - Config.LastFX < 0.2 then
								Config.LastFX = tick()
								return
							end
							local last = tick()
							Config.LastFX = last
							task.wait(0.2)
							pcall(function()
								task.spawn(function()
									pcall(function()
										script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
										script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
										local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										task.spawn(function()
											local Check
											Check = RunService.Heartbeat:Connect(function()
												if last ~= Config.LastFX then
													Tween:Cancel()
													Check:Disconnect()
												end
											end)
										end)
										Tween.Completed:Connect(function()
											local Info = TweenInfo.new(0.1)
											local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
											Tween:Play()
											Tween.Completed:Connect(function()
												script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
											end)
										end)
									end)
								end)
							end)
						end)
						task.wait(Config.Cooldown)
						pcall(function()
							ReduceWalk:Destroy()
							BodyEffects.GunFiring.Value = false
						end)
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Deactivated:Connect(function()
	Firing = false
	if Loop then
		task.spawn(function()
			if Config.Stopped ~= true then
				Config.Stopped = true
				task.wait(Config.CooldownAfterStopped)
				Config.Stopped = false
			end
		end)
		Loop:Disconnect()
		Loop = nil
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
end)]]
	elseif v.Parent.Name == "[Flamethrower]" then
		source = [[local debounce = .1
local equipped = false
local beginning = false
local began = "NotStarted"
local AmmoT = "KeepAmmo"
local Handle = script.Parent.Handle

local Config = {
	Color = 'Default',
	LastFX = 0
}

local db = {}

local IgnoredConcrete = {"medium stone grey","dark grey metallic","fossil","seashell"}
local BlackListedMaterials = {"Enum.Material.CorrodedMetal","Enum.Material.Plastic","Enum.Material.DiamondPlate","Enum.Material.Grass","Enum.Material.Slate","Enum.Material.Slate","Enum.Material.Wood"}

local function checkPartMaterial(part)
	if part:IsDescendantOf(workspace.MAP) or part:IsDescendantOf(workspace.Ignored) then
		if part.Material == Enum.Material.Concrete then
			if table.find(IgnoredConcrete,string.lower(tostring(part.BrickColor))) == nil then
				return true;	
			end
		elseif not table.find(BlackListedMaterials,tostring(part.Material)) then
			return true;
		end
		return nil;
	end
	return nil;
end

function NoAmmo(plr)
	plr.Character.BodyEffects.GunFiring.Value = true
	Handle.NoAmmo:Play()
	local StringValue = Instance.new("StringValue", plr.Character.BodyEffects.Movement)
	StringValue.Name = "ReduceWalk"
	game.Debris:AddItem(StringValue, .1)
	wait(.1)
	plr.Character.BodyEffects.GunFiring.Value = false
end
script.Parent.Activated:Connect(function()
	local plr = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
	if not require(game.ReplicatedStorage.MainModule).Activate(plr.Character.BodyEffects) then return end
	if script.Parent.Ammo.Value == 0 then return NoAmmo(plr) end
	if db[plr] ~= nil then return end
	db[plr] = true
	equipped = true

	local function HP(humanoid,dmg)
		humanoid.Health = math.clamp(humanoid.Health - dmg, 0.2, humanoid.MaxHealth)
	end
	repeat wait()
		if require(game.ReplicatedStorage.MainModule).Activate(plr.Character.BodyEffects) then
			if AmmoT == "KeepAmmo" then
				AmmoT = "RemoveAmmo"
			elseif AmmoT == "RemoveAmmo" then
				AmmoT = "KeepAmmo"
				script.Parent.Ammo.Value -= 1
			end
			if beginning == false then
				beginning = true
				began = "Started"
				Handle.BeginSound:Play()
				script.Parent.Part.Flame:Emit(1)
			end
			if began == "Started" then
				began = "Flaming"
				Handle.ShootSound:Play()
			end
			script.Parent.Part.Flame.Rate = 500
			local params = RaycastParams.new()
			params.FilterType = Enum.RaycastFilterType.Blacklist
			params.FilterDescendantsInstances = {plr.Character,workspace.Ignored}
			local direction = (plr.Character.UpperTorso.CFrame.LookVector * 100).Unit*30
			local result = workspace:Raycast(script.Parent.Part.Position,direction,params)
			if result then
				script.Parent.Part.Flame.Speed = NumberRange.new((result.Position - script.Parent.Part.Position).Magnitude*2)
				local Humanoid
				if result.Instance:IsDescendantOf(workspace.Players) then
					Humanoid = result.Instance.Parent:FindFirstChild("Humanoid") or (result.Instance.Parent.Parent:FindFirstChild("Humanoid") or result.Instance.Parent.Parent.Parent:FindFirstChild("Humanoid"))
					local Character = Humanoid.Parent
					HP(Humanoid,10)
					if not Character.UpperTorso:FindFirstChild("Fire") then
						local FireParticle = game.ServerStorage.Storage.Misc.Particles.FireParticle:Clone()
						FireParticle.Name = "Fire"
						FireParticle.Parent = Character.UpperTorso
						game.Debris:AddItem(FireParticle,7)
					end
				else
					local FlamedPart = result.Instance
					if checkPartMaterial(FlamedPart) then
						if not FlamedPart:FindFirstChild("Fire") then
							local FireParticle = game.ServerStorage.Storage.Misc.Particles.FireParticle:Clone()
							FireParticle.Name = "Fire"
							FireParticle.Parent = FlamedPart
							local FlamedPartSize = Instance.new("Vector3Value")
							FlamedPartSize.Value  = FlamedPart.Size
							local FlamedPartColor = Instance.new("Color3Value")
							FlamedPartColor.Value = FlamedPart.Color
							local ColorTween = game:GetService("TweenService"):Create(FlamedPart,TweenInfo.new(5,Enum.EasingStyle.Linear,Enum.EasingDirection.In,0,false,3),{Color = Color3.fromRGB(255,0,0)})
							ColorTween:Play()
							ColorTween.Completed:Connect(function()
								wait()
								local FlameDestroyTween = game:GetService("TweenService"):Create(FlamedPart,TweenInfo.new(2,Enum.EasingStyle.Linear,Enum.EasingDirection.InOut,0),{Size = Vector3.new(0,0,0)})
								FlameDestroyTween:Play()
								FlameDestroyTween.Completed:Connect(function()
									local Signal = Instance.new("ObjectValue",game.ServerStorage.FlamedParts)
									Signal.Name = FlamedPart.name
									FlamedPartSize.Name = "SIZE"
									FlamedPartColor.Parent = Signal
									FlamedPartColor.Name = "COLOR"
									FlamedPartSize.Parent = Signal
									Signal.Value = FlamedPart
									FireParticle:Destroy()
								end)
							end)
						end
					end
				end
			else
				script.Parent.Part.Flame.Speed = NumberRange.new(60)
			end
			plr.Character:WaitForChild("BodyEffects").GunShotChanges.Value += 1
			local StringValue = Instance.new("StringValue", plr.Character.BodyEffects.Movement)
			StringValue.Name = "ReduceWalk"
			game.Debris:AddItem(StringValue, .1)
			plr.Character.BodyEffects.GunFiring.Value = true
		else
			script.Parent.Part.Flame.Rate = 0
			began = "Started"
			Handle.ShootSound:Stop()
		end
	until script.Parent.Ammo.Value == 0 or equipped == false
	script.Parent.Part.Flame.Rate = 0
	plr.Character.BodyEffects.GunFiring.Value = false
	began = "NotStarted"
	beginning = false
	Handle.ShootSound:stop()
	wait(.3)
	db[plr] = nil
end)

script.Parent.Deactivated:Connect(function()
	equipped = false
end)

script.Parent.Unequipped:Connect(function()
	equipped = false
	began = "NotStarted"
	beginning = false
end)


script.Parent.Equipped:Connect(function()
	local plr = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
	local Color = _G.ApplySkin(plr, script.Parent)
	Config.Color = Color
end)

while wait() do
	if script.Parent.Default.TextureID == "rbxassetid://9400558000" then
		local new = Instance.new("Color3Value")
		new.Value = Color3.new(0.173022, 0.290806, 1)
		script.Parent.Part.Flame.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, new.Value),
			ColorSequenceKeypoint.new(1,new.Value)
		}
	elseif script.Parent.Default.TextureID == "rbxassetid://9400503673" then
		local new = Instance.new("Color3Value")
		new.Value = Color3.new(0.925948, 0.225986, 0.195468)
		script.Parent.Part.Flame.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, new.Value),
			ColorSequenceKeypoint.new(1,new.Value)
		}
	else
		local new = Instance.new("Color3Value")
		new.Value = Color3.new(0.965728, 0.512245, 0.279225)
		script.Parent.Part.Flame.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0, new.Value),
			ColorSequenceKeypoint.new(1,new.Value)
		}
	end
end]]
	elseif v.Parent.Name == "[Glock]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local RunService = game:GetService('RunService')
local Config = {
	Damage = 35,
	Cooldown = 0.5,
	Range = 250,
	Color = 'Default',
	LastFX = 0
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Reload.Value ~= false or Character.BodyEffects['K.O'].Value == true) then
					return
				end
				if (BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
					return
				end
				if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
					return
				end
				if Player.Character:FindFirstChild('Christmas_Sock') then
					return
				end
				if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
					return
				end
				if BodyEffects.Attacking.Value ~= false then
					return
				end
				if BodyEffects:FindFirstChild('Block') then
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
					return
				end
				if script.Parent.Ammo.Value > 0 then
					script.Parent.Ammo.Value -= 1
					local Sound = script.Parent.Handle.ShootSound:Clone()
					Sound.Parent = script.Parent.Handle
					Sound:Play()
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
					task.spawn(function()
						task.wait(.05)
						local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					end)
					local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
					BodyEffects.GunFiring.Value = true
					CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
					task.spawn(function()
						if tick() - Config.LastFX < 0.75 then
							Config.LastFX = tick()
							return
						end
						local last = tick()
						Config.LastFX = last
						task.wait(0.2)
						pcall(function()
							task.spawn(function()
								pcall(function()
									script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
									script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
									local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
									local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
									Tween:Play()
									task.spawn(function()
										local Check
										Check = RunService.Heartbeat:Connect(function()
											if last ~= Config.LastFX then
												Tween:Cancel()
												Check:Disconnect()
											end
										end)
									end)
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.1)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										Tween.Completed:Connect(function()
											script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
										end)
									end)
								end)
							end)
						end)
					end)
					task.wait(Config.Cooldown)
					pcall(function()
						ReduceWalk:Destroy()
						BodyEffects.GunFiring.Value = false
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
end)]]
	elseif v.Parent.Name == "[LMG]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local Firing = false
local Loop = nil
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local Config = {
	Damage = 9,
	Cooldown = 1/11,
	Stopped = false,
	CooldownAfterStopped = 0.2,
	Range = 250,
	LastFX = 0,
	Color = 'Default'
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if script.Parent.Ammo.Value > 0 then
					if Config.Stopped == true then
						return
					end
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					if Loop ~= nil then
						return
					end
					Firing = true
					Loop = RunService.Heartbeat:Connect(function()
						if not script.Parent:IsDescendantOf(Player.Character) then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Reload.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Cuff.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['K.O'].Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['Grabbed'].Value ~= nil then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects:FindFirstChild('Block') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Attacking.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('Christmas_Sock') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.GunFiring.Value ~= false then
							return
						end
						script.Parent.Ammo.Value -= 1
						local Sound = script.Parent.Handle.ShootSound:Clone()
						Sound.Parent = script.Parent.Handle
						Sound:Play()
						Sound.Ended:Connect(function()
							Sound:Destroy()
						end)
						task.spawn(function()
							task.wait(.05)
							local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						end)
						local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
						BodyEffects.GunFiring.Value = true
						CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
						task.spawn(function()
							if tick() - Config.LastFX < 0.2 then
								Config.LastFX = tick()
								return
							end
							local last = tick()
							Config.LastFX = last
							task.wait(0.2)
							pcall(function()
								task.spawn(function()
									pcall(function()
										script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
										script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
										local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										task.spawn(function()
											local Check
											Check = RunService.Heartbeat:Connect(function()
												if last ~= Config.LastFX then
													Tween:Cancel()
													Check:Disconnect()
												end
											end)
										end)
										Tween.Completed:Connect(function()
											local Info = TweenInfo.new(0.1)
											local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
											Tween:Play()
											Tween.Completed:Connect(function()
												script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
											end)
										end)
									end)
								end)
							end)
						end)
						task.wait(Config.Cooldown)
						pcall(function()
							ReduceWalk:Destroy()
							BodyEffects.GunFiring.Value = false
						end)
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Deactivated:Connect(function()
	Firing = false
	if Loop then
		task.spawn(function()
			if Config.Stopped ~= true then
				Config.Stopped = true
				task.wait(Config.CooldownAfterStopped)
				Config.Stopped = false
			end
		end)
		Loop:Disconnect()
		Loop = nil
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
	pcall(function()
		local function Play(Humanoid)
			local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
			local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
			local Track = Humanoid:LoadAnimation(Animation)
			Track:Play()
			Track.Stopped:Connect(function()
				if script.Parent:IsDescendantOf(Player.Character) then
					Play()
				end
			end)
		end
		Play()
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
		local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
		for i,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
			if v.Animation.AnimationId == Animation.AnimationId then
				v:Stop()
				v:Destroy()
				break
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "[P90]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local Firing = false
local Loop = nil
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local Config = {
	Damage = 6.25,
	Cooldown = 1/13,
	Stopped = false,
	CooldownAfterStopped = 0.2,
	Range = 250,
	LastFX = 0,
	Color = 'Default'
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if script.Parent.Ammo.Value > 0 then
					if Config.Stopped == true then
						return
					end
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					if Loop ~= nil then
						return
					end
					Firing = true
					Loop = RunService.Heartbeat:Connect(function()
						if not script.Parent:IsDescendantOf(Player.Character) then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Reload.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Cuff.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['K.O'].Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['Grabbed'].Value ~= nil then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects:FindFirstChild('Block') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Attacking.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('Christmas_Sock') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.GunFiring.Value ~= false then
							return
						end
						script.Parent.Ammo.Value -= 1
						local Sound = script.Parent.Handle.ShootSound:Clone()
						Sound.Parent = script.Parent.Handle
						Sound:Play()
						Sound.Ended:Connect(function()
							Sound:Destroy()
						end)
						task.spawn(function()
							task.wait(.05)
							local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						end)
						local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
						BodyEffects.GunFiring.Value = true
						CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
						task.spawn(function()
							if tick() - Config.LastFX < 0.2 then
								Config.LastFX = tick()
								return
							end
							local last = tick()
							Config.LastFX = last
							task.wait(0.2)
							pcall(function()
								task.spawn(function()
									pcall(function()
										script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
										script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
										local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										task.spawn(function()
											local Check
											Check = RunService.Heartbeat:Connect(function()
												if last ~= Config.LastFX then
													Tween:Cancel()
													Check:Disconnect()
												end
											end)
										end)
										Tween.Completed:Connect(function()
											local Info = TweenInfo.new(0.1)
											local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
											Tween:Play()
											Tween.Completed:Connect(function()
												script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
											end)
										end)
									end)
								end)
							end)
						end)
						task.wait(Config.Cooldown)
						pcall(function()
							ReduceWalk:Destroy()
							BodyEffects.GunFiring.Value = false
						end)
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Deactivated:Connect(function()
	Firing = false
	if Loop then
		task.spawn(function()
			if Config.Stopped ~= true then
				Config.Stopped = true
				task.wait(Config.CooldownAfterStopped)
				Config.Stopped = false
			end
		end)
		Loop:Disconnect()
		Loop = nil
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
end)]]
	elseif v.Parent.Name == "[RPG]" then
		source = [[local Config = {
	Color = 'Default',
	LastFX = 0
}

local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]

local db = {}



script.Parent.Activated:Connect(function()
	local plr = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
	if plr.Character:FindFirstChild("FULLY_LOADED_CHAR") == nil then return end
	if db[plr] == true then return end
	db[plr] = true
	if script.Parent.Ammo.Value >= 1 then
		script.Parent.Ammo.Value -= 1
		plr.Character.BodyEffects.GunShotChanges.Value += 0
		local Rocket = script.Parent.Launcher:Clone()
		script.Parent.Launcher.Transparency = 1
		Rocket.Parent = workspace.Ignored
		local ShootSound = Instance.new("Sound",Rocket)
		ShootSound.SoundId = "rbxassetid://12222095"
		ShootSound.Looped = true
		ShootSound:Play()
		local ToLookAt = plr.Character.BodyEffects.MousePos.Value
		Rocket.CFrame = CFrame.lookAt(script.Parent.Launcher.Position,plr.Character.BodyEffects.MousePos.Value)
		local VEL = Instance.new("BodyVelocity",Rocket)
		local String = Instance.new("StringValue",plr.Character.BodyEffects.Movement)
		String.Name = "ReduceWalk"
		game.Debris:AddItem(String,.6)
		VEL.Velocity = (Vector3.new(plr.Character.BodyEffects.MousePos.Value.x,plr.Character.BodyEffects.MousePos.Value.y,plr.Character.BodyEffects.MousePos.Value.z)-Rocket.Position).Unit*50
		local waited = 0
		local maxWaitTime = 25
		local Exploding = true
		local par = RaycastParams.new()
		par.FilterType = Enum.RaycastFilterType.Blacklist
		par.FilterDescendantsInstances = {Rocket,workspace.Ignored,script.Parent,plr.Character}
		while wait() do
			if waited > maxWaitTime then
				Exploding = false
				break
			end
			waited += .1
			Rocket.CFrame = CFrame.lookAt(Rocket.Position,ToLookAt)
			local result = workspace:Raycast(Rocket.Position,(Rocket.CFrame.p + Rocket.CFrame.LookVector * 60).Unit*5,par)
			if result then
				break
			else
				if (Rocket.Position-ToLookAt).Magnitude < 3 then
					break
				end
			end
		end
		db[plr] = nil
		if Exploding == true then
			game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.Explosion:Fire(plr, Rocket.Position)
			ShootSound:Destroy()
		end
		Rocket:Destroy()
	else
		script.Parent.Handle.NoAmmo:Play()
		wait(.4)
		db[plr] = nil
	end
end)
script.Parent.Ammo.Changed:Connect(function()
	if script.Parent.Ammo.Value == 1 then
		script.Parent.Launcher.Transparency = 0
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
end)

script.Parent:WaitForChild('Ammo'):GetPropertyChangedSignal('Value'):Connect(function()
	local Ammo = script.Parent.Ammo
	if Ammo.Value == 0 then
		task.spawn(function()
			Config.CanShoot = false
			task.wait(6)
			Config.CanShoot = true
		end)
	end
end)]]
	elseif v.Parent.Name == "[Revolver]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local RunService = game:GetService('RunService')
local Config = {
	Damage = 35,
	Cooldown = 0.2,
	Range = 250,
	Color = 'Default',
	LastFX = 0
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Reload.Value ~= false or Character.BodyEffects['K.O'].Value == true) then
					return
				end
				if (BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
					return
				end
				if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
					return
				end
				if Player.Character:FindFirstChild('Christmas_Sock') then
					return
				end
				if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
					return
				end
				if BodyEffects.Attacking.Value ~= false then
					return
				end
				if BodyEffects:FindFirstChild('Block') then
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
					return
				end
				if script.Parent.Ammo.Value > 0 then
					script.Parent.Ammo.Value -= 1
					local Sound = script.Parent.Handle.ShootSound:Clone()
					Sound.Parent = script.Parent.Handle
					Sound:Play()
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
					task.spawn(function()
						task.wait(.05)
						local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					end)	
					local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
					BodyEffects.GunFiring.Value = true
					CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
					task.spawn(function()
						if tick() - Config.LastFX < 0.75 then
							Config.LastFX = tick()
							return
						end
						local last = tick()
						Config.LastFX = last
						task.wait(0.2)
						pcall(function()
							task.spawn(function()
								pcall(function()
									script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
									script.Parent.Handle.ShootBBGUI.Shoot.ImageTransparency = 0
									script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0.015, 0, 0.015, 0)
									local Tween1 = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot, TweenInfo.new(0.015), {Size = UDim2.new(0.004, 0, 0.004, 0)})
									local Tween2 = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot, TweenInfo.new(0.035), {Size = UDim2.new(0.06, 0, 0.06, 0)})
									local Tween3 = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot, TweenInfo.new(0.045), {Size = UDim2.new(0.004, 0, 0.004, 0)})
									local Tween4 = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot, TweenInfo.new(0.065), {Size = UDim2.new(0.25, 0, 0.25, 0)})
									local Tween5 = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot, TweenInfo.new(0.075), {Size = UDim2.new(0.03, 0, 0.03, 0)})
									local Tween6 = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot, TweenInfo.new(0.075), {Size = UDim2.new(0.03, 0, 0.03, 0)})
									local Tween7 = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot, TweenInfo.new(0.15, Enum.EasingStyle.Circular), {Size = UDim2.new(1, 0, 1, 0)})
									Tween1:Play()
									Tween1.Completed:Connect(function()
										Tween2:Play() 
										Tween2.Completed:Connect(function()
											Tween3:Play()
											Tween3.Completed:Connect(function()
												Tween4:Play()
												Tween4.Completed:Connect(function()
													Tween5:Play()
													Tween5.Completed:Connect(function()
														Tween6:Play()
														Tween6.Completed:Connect(function()
															Tween7:Play()
															Tween7.Completed:Connect(function()
																script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
															end)
														end)
													end)
												end)
											end)
										end)
									end)
									task.spawn(function()
										local Check
										Check = RunService.Heartbeat:Connect(function()
											if last ~= Config.LastFX then
												Tween1:Cancel()
												Tween2:Cancel()
												Tween3:Cancel()
												Tween4:Cancel()
												Tween5:Cancel()
												Tween6:Cancel()
												Tween7:Cancel()
												Check:Disconnect()
											end
										end)
									end)
									--[[Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.1)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										Tween.Completed:Connect(function()
											script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
										end)
									end)]
	end)
	end)
	end)
	end)
	task.wait(Config.Cooldown)
pcall(function()
	ReduceWalk:Destroy()
	BodyEffects.GunFiring.Value = false
end)
else
	if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
		return
	end
	if BodyEffects.Reload.Value ~= false then
		return
	end
	if BodyEffects.Attacking.Value ~= false then
		return
	end
	if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
		return
	end
	if Player.Character:FindFirstChild('Christmas_Sock') then
		return
	end
	if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
		return
	end
	if BodyEffects:FindFirstChild('Block') then
		script.Parent.Handle.NoAmmo:Play()
		RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
		BodyEffects.GunFiring.Value = true
		task.wait(0.3)
		pcall(function()
			BodyEffects.GunFiring.Value = false
		end)
		return
	end
	script.Parent.Handle.NoAmmo:Play()
	RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
	BodyEffects.GunFiring.Value = true
	task.wait(0.3)
	pcall(function()
		BodyEffects.GunFiring.Value = false
	end)
end
end
end
end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
end)]]
	elseif v.Parent.Name == "[Rifle]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local RunService = game:GetService('RunService')
local Config = {
	Damage = 99,
	Cooldown = 2,
	Range = 250,
	Color = 'Default',
	LastFX = 0
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Reload.Value ~= false or Character.BodyEffects['K.O'].Value == true) then
					return
				end
				if (BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
					return
				end
				if BodyEffects.Reload.Value ~= false then
					return
				end
				if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
					return
				end
				if Player.Character:FindFirstChild('Christmas_Sock') then
					return
				end
				if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
					return
				end
				if BodyEffects.Attacking.Value ~= false then
					return
				end
				if BodyEffects:FindFirstChild('Block') then
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
					return
				end
				if script.Parent.Ammo.Value > 0 then
					script.Parent.Ammo.Value -= 1
					local Sound = script.Parent.Handle.ShootSound:Clone()
					Sound.Parent = script.Parent.Handle
					Sound:Play()
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
					task.spawn(function()
						task.wait(.05)
						local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					end)
					local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
					BodyEffects.GunFiring.Value = true
					CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
					task.spawn(function()
						if tick() - Config.LastFX < 0.75 then
							Config.LastFX = tick()
							return
						end
						local last = tick()
						Config.LastFX = last
						task.wait(0.2)
						pcall(function()
							task.spawn(function()
								pcall(function()
									script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
									script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
									local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
									local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
									Tween:Play()
									task.spawn(function()
										local Check
										Check = RunService.Heartbeat:Connect(function()
											if last ~= Config.LastFX then
												Tween:Cancel()
												Check:Disconnect()
											end
										end)
									end)
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.1)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										Tween.Completed:Connect(function()
											script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
										end)
									end)
								end)
							end)
						end)
					end)
					task.wait(Config.Cooldown)
					pcall(function()
						ReduceWalk:Destroy()
						BodyEffects.GunFiring.Value = false
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
	pcall(function()
		local function Play(Humanoid)
			local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
			local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
			local Track = Humanoid:LoadAnimation(Animation)
			Track:Play()
			Track.Stopped:Connect(function()
				if script.Parent:IsDescendantOf(Player.Character) then
					Play()
				end
			end)
		end
		Play()
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
		local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
		for i,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
			if v.Animation.AnimationId == Animation.AnimationId then
				v:Stop()
				v:Destroy()
				break
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "[SMG]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local Firing = false
local Loop = nil
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local Config = {
	Damage = 9,
	Cooldown = 1/13,
	Stopped = false,
	CooldownAfterStopped = 0.2,
	Range = 250,
	LastFX = 0,
	Color = 'Default'
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if script.Parent.Ammo.Value > 0 then
					if Config.Stopped == true then
						return
					end
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					if Loop ~= nil then
						return
					end
					Firing = true
					Loop = RunService.Heartbeat:Connect(function()
						if not script.Parent:IsDescendantOf(Player.Character) then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Reload.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Cuff.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['K.O'].Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['Grabbed'].Value ~= nil then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects:FindFirstChild('Block') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Attacking.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('Christmas_Sock') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.GunFiring.Value ~= false then
							return
						end
						script.Parent.Ammo.Value -= 1
						local Sound = script.Parent.Handle.ShootSound:Clone()
						Sound.Parent = script.Parent.Handle
						Sound:Play()
						Sound.Ended:Connect(function()
							Sound:Destroy()
						end)
						task.spawn(function()
							task.wait(.05)
							local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						end)
						local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
						BodyEffects.GunFiring.Value = true
						CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
						task.spawn(function()
							if tick() - Config.LastFX < 0.2 then
								Config.LastFX = tick()
								return
							end
							local last = tick()
							Config.LastFX = last
							task.wait(0.2)
							pcall(function()
								task.spawn(function()
									pcall(function()
										script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
										script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
										local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										task.spawn(function()
											local Check
											Check = RunService.Heartbeat:Connect(function()
												if last ~= Config.LastFX then
													Tween:Cancel()
													Check:Disconnect()
												end
											end)
										end)
										Tween.Completed:Connect(function()
											local Info = TweenInfo.new(0.1)
											local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
											Tween:Play()
											Tween.Completed:Connect(function()
												script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
											end)
										end)
									end)
								end)
							end)
						end)
						task.wait(Config.Cooldown)
						pcall(function()
							ReduceWalk:Destroy()
							BodyEffects.GunFiring.Value = false
						end)
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Deactivated:Connect(function()
	Firing = false
	if Loop then
		task.spawn(function()
			if Config.Stopped ~= true then
				Config.Stopped = true
				task.wait(Config.CooldownAfterStopped)
				Config.Stopped = false
			end
		end)
		Loop:Disconnect()
		Loop = nil
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
end)]]
	elseif v.Parent.Name == "[Shotgun]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local RunService = game:GetService('RunService')
local Config = {
	Damage = 25,
	Cooldown = 1.25,
	Range = 100,
	Color = 'Default',
	LastFX = 0
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(ActualMouse, Position, Mouse, RandomNum)
	local result = Raycast(Position, Mouse)
	local Distance = (ActualMouse - Position).magnitude
	local DMGMultiplier = 1
	if Distance < 5 then 
		DMGMultiplier = 1.5
	elseif Distance >= 5 and Distance < 15 then
		DMGMultiplier = 1
	elseif Distance >= 15 and Distance < 25 then
		DMGMultiplier = 0.6
	elseif Distance >= 25 then
		DMGMultiplier = 0.4
	end
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	local Damage = Config.Damage * DMGMultiplier
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Damage > 0 then
							Humanoid:TakeDamage(Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Damage
								if Humanoid.Health - (Damage) > 0 then
									Humanoid:TakeDamage(Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Damage > 0 then
								Humanoid:TakeDamage(Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Damage * 2
							if Humanoid.Health - (Damage * 2) > 0 then
								Humanoid:TakeDamage((Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Damage * 2 > 0 then
							Humanoid:TakeDamage(Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Reload.Value ~= false or Character.BodyEffects['K.O'].Value == true) then
					return
				end
				if (BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
					return
				end
				if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
					return
				end
				if Player.Character:FindFirstChild('Christmas_Sock') then
					return
				end
				if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
					return
				end
				if BodyEffects.Attacking.Value ~= false then
					return
				end
				if BodyEffects:FindFirstChild('Block') then
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
					return
				end
				if script.Parent.Ammo.Value > 0 then
					script.Parent.Ammo.Value -= 1
					local Sound = script.Parent.Handle.ShootSound:Clone()
					Sound.Parent = script.Parent.Handle
					Sound:Play()
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
					task.spawn(function()
						task.wait(.05)
						local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					end)
					local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
					BodyEffects.GunFiring.Value = true
					local RandomNum = Random.new():NextNumber(0.3, 0.5)
					local Offsets = {
						{ 
							Vector3.new(0,0.09),
							Vector3.new(0,0.14),
							Vector3.new(0,-0.3),
							Vector3.new(0,-0.22),
							Vector3.new(0,0.2)
						},
						{ 
							Vector3.new(0,-0.15),
							Vector3.new(0,0.14),
							Vector3.new(0,-0.28),
							Vector3.new(0,-0.22),
							Vector3.new(0,0.2)
						},
						{ 
							Vector3.new(0.3,-0.045),
							Vector3.new(-0.38,-0.045),
							Vector3.new(-0.3,-0.045),
							Vector3.new(-0.22,-0.045),
							Vector3.new(0.2,-0.045)
						},
						{ 
							Vector3.new(0.3,0.045),
							Vector3.new(-0.38,0.045),
							Vector3.new(-0.28,0.045),
							Vector3.new(-0.18,0.045),
							Vector3.new(0.2,0.045)
						},
						{
							Vector3.new(-0.23,-0.2),
							Vector3.new(-0.4,-0.33),
							Vector3.new(0.13,0.2),
							Vector3.new(0.05,0.12),
							Vector3.new(-0.32,-0.27)
						},
						{
							Vector3.new(-0.23,-0.2),
							Vector3.new(-0.32,-0.27),
							Vector3.new(0.13,0.2),
							Vector3.new(0.05,0.12),
							Vector3.new(0.2,0.27)
						},
						{
							Vector3.new(0.23,-0.2),
							Vector3.new(0.32,-0.27),
							Vector3.new(-0.13,0.2),
							Vector3.new(-0.05,0.12),
							Vector3.new(-0.2,0.27)
						},
						{
							Vector3.new(0.23,-0.2),
							Vector3.new(0.32,-0.28),
							Vector3.new(-0.13,0.2),
							Vector3.new(0.14,-0.12),
							Vector3.new(-0.2,0.27)
						}

					}
					local Offset = Offsets[math.random(1, #Offsets)]
					for i = 1,5 do 
						local Origin = script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace)
						CreateBullet(BodyEffects.MousePos.Value, Origin, (Origin + (BodyEffects.MousePos.Value - Origin).Unit * 5) - Offset[i], RandomNum)
					end
					task.spawn(function()
						if tick() - Config.LastFX < 0.75 then
							Config.LastFX = tick()
							return
						end
						local last = tick()
						Config.LastFX = last
						task.wait(0.2)
						pcall(function()
							task.spawn(function()
								pcall(function()
									script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
									script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
									local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
									local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
									Tween:Play()
									task.spawn(function()
										local Check
										Check = RunService.Heartbeat:Connect(function()
											if last ~= Config.LastFX then
												Tween:Cancel()
												Check:Disconnect()
											end
										end)
									end)
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.1)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										Tween.Completed:Connect(function()
											script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
										end)
									end)
								end)
							end)
						end)
					end)
					task.wait(Config.Cooldown)
					pcall(function()
						ReduceWalk:Destroy()
						BodyEffects.GunFiring.Value = false
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
	pcall(function()
		local function Play(Humanoid)
			local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
			local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
			local Track = Humanoid:LoadAnimation(Animation)
			Track:Play()
			Track.Stopped:Connect(function()
				if script.Parent:IsDescendantOf(Player.Character) then
					Play()
				end
			end)
		end
		Play()
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
		local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
		for i,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
			if v.Animation.AnimationId == Animation.AnimationId then
				v:Stop()
				v:Destroy()
				break
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "[SilencerAR]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local Firing = false
local Loop = nil
local RunService = game:GetService('RunService')
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local Config = {
	Damage = 10,
	Cooldown = 1/10,
	Stopped = false,
	CooldownAfterStopped = 0.2,
	Range = 250,
	LastFX = 0,
	Color = 'Default'
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if script.Parent.Ammo.Value > 0 then
					if Config.Stopped == true then
						return
					end
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					if Loop ~= nil then
						return
					end
					Firing = true
					Loop = RunService.Heartbeat:Connect(function()
						if not script.Parent:IsDescendantOf(Player.Character) then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Reload.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Cuff.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['K.O'].Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects['Grabbed'].Value ~= nil then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects:FindFirstChild('Block') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.Attacking.Value ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if Player.Character:FindFirstChild('Christmas_Sock') then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if script.Parent.Ammo.Value <= 0 then
							Loop:Disconnect()
							Loop = nil
							return
						end
						if BodyEffects.GunFiring.Value ~= false then
							return
						end
						script.Parent.Ammo.Value -= 1
						local Sound = script.Parent.Handle.ShootSound:Clone()
						Sound.Parent = script.Parent.Handle
						Sound:Play()
						Sound.Ended:Connect(function()
							Sound:Destroy()
						end)
						task.spawn(function()
							task.wait(.05)
							local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						end)
						local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
						BodyEffects.GunFiring.Value = true
						CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
						task.spawn(function()
							if tick() - Config.LastFX < 0.2 then
								Config.LastFX = tick()
								return
							end
							local last = tick()
							Config.LastFX = last
							task.wait(0.2)
							pcall(function()
								task.spawn(function()
									pcall(function()
										script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
										script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
										local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										task.spawn(function()
											local Check
											Check = RunService.Heartbeat:Connect(function()
												if last ~= Config.LastFX then
													Tween:Cancel()
													Check:Disconnect()
												end
											end)
										end)
										Tween.Completed:Connect(function()
											local Info = TweenInfo.new(0.1)
											local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
											Tween:Play()
											Tween.Completed:Connect(function()
												script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
											end)
										end)
									end)
								end)
							end)
						end)
						task.wait(Config.Cooldown)
						pcall(function()
							ReduceWalk:Destroy()
							BodyEffects.GunFiring.Value = false
						end)
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Deactivated:Connect(function()
	Firing = false
	if Loop then
		task.spawn(function()
			if Config.Stopped ~= true then
				Config.Stopped = true
				task.wait(Config.CooldownAfterStopped)
				Config.Stopped = false
			end
		end)
		Loop:Disconnect()
		Loop = nil
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
	pcall(function()
		local function Play(Humanoid)
			local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
			local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
			local Track = Humanoid:LoadAnimation(Animation)
			Track:Play()
			Track.Stopped:Connect(function()
				if script.Parent:IsDescendantOf(Player.Character) then
					Play()
				end
			end)
		end
		Play()
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
		local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
		for i,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
			if v.Animation.AnimationId == Animation.AnimationId then
				v:Stop()
				v:Destroy()
				break
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "[Silencer]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local RunService = game:GetService('RunService')
local Config = {
	Damage = 35,
	Cooldown = 0.5,
	Range = 250,
	Color = 'Default',
	LastFX = 0
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(Position, Mouse)
	local RandomNum = Random.new():NextNumber(0.3, 0.5)
	local result = Raycast(Position, Mouse)
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Config.Damage > 0 then
							Humanoid:TakeDamage(Config.Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage
								if Humanoid.Health - (Config.Damage) > 0 then
									Humanoid:TakeDamage(Config.Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Config.Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Config.Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Config.Damage > 0 then
								Humanoid:TakeDamage(Config.Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Config.Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Config.Damage * 2
							if Humanoid.Health - (Config.Damage * 2) > 0 then
								Humanoid:TakeDamage((Config.Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Config.Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Config.Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Config.Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Config.Damage * 2 > 0 then
							Humanoid:TakeDamage(Config.Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Config.Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Reload.Value ~= false or Character.BodyEffects['K.O'].Value == true) then
					return
				end
				if (BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
					return
				end
				if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
					return
				end
				if Player.Character:FindFirstChild('Christmas_Sock') then
					return
				end
				if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
					return
				end
				if BodyEffects.Attacking.Value ~= false then
					return
				end
				if BodyEffects:FindFirstChild('Block') then
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
					return
				end
				if script.Parent.Ammo.Value > 0 then
					script.Parent.Ammo.Value -= 1
					local Sound = script.Parent.Handle.ShootSound:Clone()
					Sound.Parent = script.Parent.Handle
					Sound:Play()
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
					task.spawn(function()
						task.wait(.05)
						local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					end)
					local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
					BodyEffects.GunFiring.Value = true
					CreateBullet(script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace), BodyEffects.MousePos.Value)
					task.spawn(function()
						if tick() - Config.LastFX < 0.75 then
							Config.LastFX = tick()
							return
						end
						local last = tick()
						Config.LastFX = last
						task.wait(0.2)
						pcall(function()
							task.spawn(function()
								pcall(function()
									script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
									script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
									local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
									local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
									Tween:Play()
									task.spawn(function()
										local Check
										Check = RunService.Heartbeat:Connect(function()
											if last ~= Config.LastFX then
												Tween:Cancel()
												Check:Disconnect()
											end
										end)
									end)
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.1)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										Tween.Completed:Connect(function()
											script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
										end)
									end)
								end)
							end)
						end)
					end)
					task.wait(Config.Cooldown)
					pcall(function()
						ReduceWalk:Destroy()
						BodyEffects.GunFiring.Value = false
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
end)]]
	elseif v.Parent.Name == "[TacticalShotgun]" then
		source = [[local Player

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local TweenService = game:GetService('TweenService')
local RemoteFunction = require(game:GetService('ReplicatedStorage').RemoteFunction)
local RunService = game:GetService('RunService')
local Config = {
	Damage = 20,
	Cooldown = 0.6,
	Range = 70,
	Color = 'Default',
	LastFX = 0
}

function Raycast(Position, Mouse)
	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Blacklist
	rayParams.FilterDescendantsInstances = {Player.Character, script.Parent}
	rayParams.IgnoreWater = true
	local ray = Ray.new(Position, (Mouse - Position).Unit * Config.Range)
	local result = workspace:Raycast(ray.Origin, ray.Direction, rayParams) or (ray.Origin + ray.Direction)
	return result
end

function CreateBullet(ActualMouse, Position, Mouse, RandomNum)
	local result = Raycast(Position, Mouse)
	local Distance = (ActualMouse - Position).magnitude
	local DMGMultiplier = 1
	if Distance < 5 then 
		DMGMultiplier = 1.5
	elseif Distance >= 5 and Distance < 15 then
		DMGMultiplier = 1
	elseif Distance >= 15 and Distance < 25 then
		DMGMultiplier = 0.6
	elseif Distance >= 25 then
		DMGMultiplier = 0.4
	end
	local Part = Instance.new('Part', workspace.Ignored)
	Part.Name = 'BULLET_RAYS'
	Part.Transparency = 1
	Part.Size = Vector3.new(0.001, 0.001, 0.001)
	Part.Position = Position
	Part.Anchored = true
	Part.CanCollide = false
	local Beam = Instance.new('Beam', Part)
	Beam.Name = 'GunBeam'
	Beam.Brightness = 1
	Beam.TextureLength = 0.5
	if Config.Color == 'Default' then
		Beam.Color = ColorSequence.new{
			ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 242, 90)),
			ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 209, 41))		
		}
		Beam.LightEmission = 1
	else 
		if Config.Color ~= 'Patriot' then
			Beam.Color = ColorSequence.new(Config.Color)
		else 
			Beam.Color = ColorSequence.new{
				ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
				ColorSequenceKeypoint.new(0.509, Color3.fromRGB(25, 163, 255)),
				ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 19, 23))
			}
		end
		if Config.Color == Color3.fromRGB(25, 59, 255) then
			Beam.LightEmission = 0.2
		else 
			if Config.Color == Color3.fromRGB(255, 60, 46) or Config.Color == 'Patriot' then
				Beam.LightEmission = 0.9
			else
				Beam.LightEmission = 1
			end
		end
	end	
	Beam.LightInfluence = 0.1
	Beam.Segments = 5
	Beam.Texture = 'rbxassetid://1215691065'
	Beam.Transparency = NumberSequence.new(0.819, 0.225)
	Beam.Width0 = 0
	Beam.Width1 = 0.1
	Beam.FaceCamera = true
	local Light = Instance.new('PointLight', Part)
	Light.Brightness = 0.5
	Light.Range = 14.766
	Light.Shadows = true
	local Tween = TweenService:Create(Light, TweenInfo.new(0.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.In), {Range = 0})
	Tween:Play()
	local Attachment0 = Instance.new('Attachment', Part)
	local Attachment1 = Instance.new('Attachment', Part)
	Beam.Attachment0 = Attachment0
	Beam.Attachment1 = Attachment1
	Attachment0.WorldCFrame = CFrame.new(Position)
	if typeof(result) ~= 'Vector3' then
		Attachment1.WorldCFrame = CFrame.new(result.Position)
	else
		Attachment1.WorldCFrame = CFrame.new(result)
	end
	game:GetService('Debris'):AddItem(Part, RandomNum)
	local Damage = Config.Damage * DMGMultiplier
	task.spawn(function()
		if typeof(result) ~= 'Vector3' and result.Instance then
			if result.Instance.Parent.Parent ~= workspace.Cashiers and (result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')) then
				local Humanoid = result.Instance.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent:FindFirstChildOfClass('Humanoid') or result.Instance.Parent.Parent.Parent:FindFirstChildOfClass('Humanoid')
				local Plr = game:GetService('Players'):GetPlayerFromCharacter(Humanoid.Parent)
				if Plr == nil then
					return
				end
				if not Plr:FindFirstChild('LOAD_SAVE_DATA') then
					return
				end
				task.spawn(function()
					local Sound = Instance.new('Sound', result.Instance)
					Sound.Name = 'BloodSplatter'
					Sound.Volume = 0.5
					Sound.SoundId = 'rbxassetid://330595293'
					Sound:Play()
					local Particle = Instance.new('ParticleEmitter', result.Instance)
					Particle.Name = 'BloodParticle'
					Particle.LightEmission = 0
					Particle.Size = NumberSequence.new(0.3, 2)
					Particle.Texture = 'rbxassetid://2271208303'
					Particle.Transparency = NumberSequence.new(0.5, 1)
					Particle.ZOffset = 0.5
					Particle.Lifetime = NumberRange.new(0.5)
					Particle.Rate = 100
					Particle.Rotation = NumberRange.new(-360, 360)
					Particle.Speed = NumberRange.new(9)
					Particle.Enabled = false
					Particle.Acceleration = Vector3.new(Random.new():NextNumber(-25, 25), Random.new():NextNumber(-100, -50), Random.new():NextNumber(-25, 25))
					Particle:Emit(5)
					game:GetService('Debris'):AddItem(Particle, 1)
					game:GetService('ReplicatedStorage').MainEvent:FireClient(Plr, 'ShotFrom', Player.Character.LowerTorso.Position)
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
				end)
				local MainModule = require(game:GetService('ReplicatedStorage').MainModule)
				if MainModule.CheckTeam(Plr, Player, nil) ~= false then
					return
				end
				if (Plr.Backpack:FindFirstChild('Fly') or Plr.Character:FindFirstChild('Fly')) then
					return
				end
				if Humanoid.Parent.BodyEffects['K.O'].Value == true then
					return
				end
				if result.Instance.Name ~= 'Head' and (not result.Instance:FindFirstChild('FaceFrontAttachment') and not result.Instance:FindFirstChild('HairAttachment')) then
					if Humanoid.Parent.BodyEffects.Armor.Value <= 0 then
						if Humanoid.Health - Damage > 0 then
							Humanoid:TakeDamage(Damage)
						else
							Humanoid.Health = 0.5
						end
					else
						if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
							if Humanoid.Parent.BodyEffects.Armor.Value - (Damage) > 0 then
								Humanoid.Parent.BodyEffects.Armor.Value -= Damage
								if Humanoid.Health - (Damage) > 0 then
									Humanoid:TakeDamage(Damage/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							else
								local LeftoverDamage = Damage - Humanoid.Parent.BodyEffects.Armor.Value
								Humanoid.Parent.BodyEffects.Armor.Value = 0
								if Humanoid.Health - (Damage/10 + LeftoverDamage) > 0 then
									Humanoid:TakeDamage((Damage + LeftoverDamage)/10)
								else
									Humanoid.Health = 0.5
								end	
								pcall(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
									Tween:Play()
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.25)
										local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
										Tween:Play()
									end)
								end)
							end
						else 
							if Humanoid.Health - Damage > 0 then
								Humanoid:TakeDamage(Damage)
							else
								Humanoid.Health = 0.5
							end
						end
					end
				else
					if Humanoid.Parent.BodyEffects.Armor.Value > 0 then
						if Humanoid.Parent.BodyEffects.Armor.Value - (Damage * 2) > 0 then
							Humanoid.Parent.BodyEffects.Armor.Value -= Damage * 2
							if Humanoid.Health - (Damage * 2) > 0 then
								Humanoid:TakeDamage((Damage * 2)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						else
							local LeftoverDamage = Damage - Humanoid.Parent.BodyEffects.Armor.Value
							Humanoid.Parent.BodyEffects.Armor.Value = 0
							if Humanoid.Health - ((Damage/10 * 2) + LeftoverDamage) > 0 then
								Humanoid:TakeDamage(((Damage * 2) + LeftoverDamage)/10)
							else
								Humanoid.Health = 0.5
							end	
							pcall(function()
								local Info = TweenInfo.new(0.25)
								local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=0.2})
								Tween:Play()
								Tween.Completed:Connect(function()
									local Info = TweenInfo.new(0.25)
									local Tween = TweenService:Create(Humanoid.Parent.HumanoidRootPart.DefenseBBGUI.Vest,Info,{ImageTransparency=1})
									Tween:Play()
								end)
							end)
						end						
					else 
						if Humanoid.Health - Damage * 2 > 0 then
							Humanoid:TakeDamage(Damage * 2)
						else
							Humanoid.Health = 0.5
						end
					end
				end
			else 
				if result.Instance.Parent.Parent == workspace.Cashiers then
					game:GetService('ServerStorage').Storage.Misc.Server.BindableEvents.ATM:Fire(Player, result.Instance.Parent:FindFirstChildOfClass('Humanoid'), Damage)
				end
			end
		end
	end)
end

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		local Character = Player.Character
		if Character:FindFirstChild('BodyEffects') then
			local BodyEffects = Character.BodyEffects
			if Character:FindFirstChildOfClass('Humanoid') and BodyEffects:FindFirstChild('MousePos') and BodyEffects:FindFirstChild('Reload') and BodyEffects:FindFirstChild('GunFiring') and BodyEffects:FindFirstChild('Movement') and BodyEffects:FindFirstChild('GunShotChanges') then
				if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Reload.Value ~= false or Character.BodyEffects['K.O'].Value == true) then
					return
				end
				if (BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
					return
				end
				if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
					return
				end
				if Player.Character:FindFirstChild('Christmas_Sock') then
					return
				end
				if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
					return
				end
				if BodyEffects.Attacking.Value ~= false then
					return
				end
				if BodyEffects:FindFirstChild('Block') then
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
					return
				end
				if script.Parent.Ammo.Value > 0 then
					script.Parent.Ammo.Value -= 1
					local Sound = script.Parent.Handle.ShootSound:Clone()
					Sound.Parent = script.Parent.Handle
					Sound:Play()
					Sound.Ended:Connect(function()
						Sound:Destroy()
					end)
					task.spawn(function()
						task.wait(.05)
						local Hit = RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					end)
					local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 5)
					BodyEffects.GunFiring.Value = true
					local RandomNum = Random.new():NextNumber(0.3, 0.5)
					local Offsets = {
						{ 
							Vector3.new(0,0.09),
							Vector3.new(0,0.14),
							Vector3.new(0,-0.3),
							Vector3.new(0,-0.22),
							Vector3.new(0,0.2)
						},
						{ 
							Vector3.new(0,-0.15),
							Vector3.new(0,0.14),
							Vector3.new(0,-0.28),
							Vector3.new(0,-0.22),
							Vector3.new(0,0.2)
						},
						{ 
							Vector3.new(0.3,-0.045),
							Vector3.new(-0.38,-0.045),
							Vector3.new(-0.3,-0.045),
							Vector3.new(-0.22,-0.045),
							Vector3.new(0.2,-0.045)
						},
						{ 
							Vector3.new(0.3,0.045),
							Vector3.new(-0.38,0.045),
							Vector3.new(-0.28,0.045),
							Vector3.new(-0.18,0.045),
							Vector3.new(0.2,0.045)
						},
						{
							Vector3.new(-0.23,-0.2),
							Vector3.new(-0.4,-0.33),
							Vector3.new(0.13,0.2),
							Vector3.new(0.05,0.12),
							Vector3.new(-0.32,-0.27)
						},
						{
							Vector3.new(-0.23,-0.2),
							Vector3.new(-0.32,-0.27),
							Vector3.new(0.13,0.2),
							Vector3.new(0.05,0.12),
							Vector3.new(0.2,0.27)
						},
						{
							Vector3.new(0.23,-0.2),
							Vector3.new(0.32,-0.27),
							Vector3.new(-0.13,0.2),
							Vector3.new(-0.05,0.12),
							Vector3.new(-0.2,0.27)
						},
						{
							Vector3.new(0.23,-0.2),
							Vector3.new(0.32,-0.28),
							Vector3.new(-0.13,0.2),
							Vector3.new(0.14,-0.12),
							Vector3.new(-0.2,0.27)
						}

					}
					local Offset = Offsets[math.random(1, #Offsets)]
					for i = 1,5 do 
						local Origin = script.Parent.Handle.Position + script.Parent.Handle.CFrame:VectorToWorldSpace(script.Parent.Handle.ShootBBGUI.StudsOffsetWorldSpace)
						CreateBullet(BodyEffects.MousePos.Value, Origin, (Origin + (BodyEffects.MousePos.Value - Origin).Unit * 5) - Offset[i], RandomNum)
					end
					task.spawn(function()
						if tick() - Config.LastFX < 0.75 then
							Config.LastFX = tick()
							return
						end
						local last = tick()
						Config.LastFX = last
						task.wait(0.2)
						pcall(function()
							task.spawn(function()
								pcall(function()
									script.Parent.Handle.ShootBBGUI.Shoot.Visible = true
									script.Parent.Handle.ShootBBGUI.Shoot.Size = UDim2.new(0, 0, 0, 0)
									local Info = TweenInfo.new(0.4, Enum.EasingStyle.Circular)
									local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=0.4, Size = UDim2.new(1, 0, 1, 0)})
									Tween:Play()
									task.spawn(function()
										local Check
										Check = RunService.Heartbeat:Connect(function()
											if last ~= Config.LastFX then
												Tween:Cancel()
												Check:Disconnect()
											end
										end)
									end)
									Tween.Completed:Connect(function()
										local Info = TweenInfo.new(0.1)
										local Tween = TweenService:Create(script.Parent.Handle.ShootBBGUI.Shoot,Info,{ImageTransparency=1, Size = UDim2.new(1, 0, 1, 0)})
										Tween:Play()
										Tween.Completed:Connect(function()
											script.Parent.Handle.ShootBBGUI.Shoot.Visible = false
										end)
									end)
								end)
							end)
						end)
					end)
					task.wait(Config.Cooldown)
					pcall(function()
						ReduceWalk:Destroy()
						BodyEffects.GunFiring.Value = false
					end)
				else
					if (BodyEffects.GunFiring.Value ~= false or BodyEffects.Cuff.Value ~= false or BodyEffects['K.O'].Value ~= false or BodyEffects['Grabbed'].Value ~= nil) then
						return
					end
					if BodyEffects.Reload.Value ~= false then
						return
					end
					if BodyEffects.Attacking.Value ~= false then
						return
					end
					if Player.Character:FindFirstChild('GRABBING_CONSTRAINT') then
						return
					end
					if Player.Character:FindFirstChild('Christmas_Sock') then
						return
					end
					if _G.PlayerData.Players[Player].Debounces.Action.Action ~= false then
						return
					end
					if BodyEffects:FindFirstChild('Block') then
						script.Parent.Handle.NoAmmo:Play()
						RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
						BodyEffects.GunFiring.Value = true
						task.wait(0.3)
						pcall(function()
							BodyEffects.GunFiring.Value = false
						end)
						return
					end
					script.Parent.Handle.NoAmmo:Play()
					RemoteFunction.InvokeClient(Player.Character, Player, 'Aim', script.Parent.Handle.Position)
					BodyEffects.GunFiring.Value = true
					task.wait(0.3)
					pcall(function()
						BodyEffects.GunFiring.Value = false
					end)
				end
			end
		end
	end
end)

script.Parent.Equipped:Connect(function()
	local Color = _G.ApplySkin(Player, script.Parent)
	Config.Color = Color
	pcall(function()
		local function Play(Humanoid)
			local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
			local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
			local Track = Humanoid:LoadAnimation(Animation)
			Track:Play()
			Track.Stopped:Connect(function()
				if script.Parent:IsDescendantOf(Player.Character) then
					Play()
				end
			end)
		end
		Play()
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		local Humanoid = Player.Character:FindFirstChildOfClass('Humanoid')
		local Animation = game:GetService('ReplicatedStorage').ClientAnimations.SmallGunAim 
		for i,v in pairs(Humanoid:GetPlayingAnimationTracks()) do
			if v.Animation.AnimationId == Animation.AnimationId then
				v:Stop()
				v:Destroy()
				break
			end
		end
	end)
end)]]
	elseif v.Parent.Name == "Wallet" and v.Name == "wallet" then
		source = [[local Player
	Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local Equipped = false
local Debounce = false
local Changed

script.Parent.Activated:Connect(function()
	if Player.Character and script.Parent:IsDescendantOf(Player.Character) then
		if Player.PlayerGui:FindFirstChild('MainScreenGui') then
			if Debounce == false then
				game:GetService('ReplicatedStorage').MainEvent:FireClient(Player, 'DropMoney')
				Debounce = true
				wait(0.1)
				Debounce = false
			end
		end
		end
end)

script.Parent.Equipped:Connect(function()
	pcall(function()
		Equipped = true
		Player = game:GetService('Players')[script.Parent.Parent.Name]
		script.Parent.Handle.BillboardGui.Enabled = true
		script.Parent.Handle.BillboardGui.TextLabel.Text = '$'..require(game:GetService('ReplicatedStorage').MainModule).AddComma(Player.DataFolder.Currency.Value)
		if Changed then
			Changed:Disconnect()
		end
		Changed = Player.DataFolder.Currency:GetPropertyChangedSignal('Value'):Connect(function()
			script.Parent.Handle.BillboardGui.TextLabel.Text = '$'..require(game:GetService('ReplicatedStorage').MainModule).AddComma(Player.DataFolder.Currency.Value)
		end)
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		Equipped = false
		game:GetService('ReplicatedStorage').MainEvent:FireClient(Player, 'DropMoney', false)
		script.Parent.Handle.BillboardGui.Enabled = false
	end)
end)]]
	elseif v.Parent.Name == "[Katana]" and v.Name == "Assets" then
		source = [[local dmg = false
script.Parent.Handle.Touched:Connect(function(damage, player)
	if damage.Parent:FindFirstChild("Humanoid") and dmg == false or player then
		local humanoid = damage.Parent.Humanoid
		local function DoDamage()
			humanoid.Health = math.clamp(humanoid.Health - 21, 0.5, humanoid.MaxHealth)
		end
		
		DoDamage(humanoid.MaxHealth,humanoid)
		script.Parent.Handle.Slash:Play()
		dmg = true

	end
end)
]]
	elseif v.Parent.Name == "[Katana]" and v.Name == "Code" then
		source = [[script.Parent.Assets.Disabled = true
local Slash1 = Instance.new("Sound")
Slash1.SoundId = "rbxassetid://260430060"
local tool = script.Parent
local tool2 = script.Parent
Attack1Toggle = Instance.new("BoolValue")
Attack1Toggle.Value = false
Attack2Toggle = Instance.new("BoolValue")
Attack2Toggle.Value = false

Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
local Character = Player.Character
local BodyEffects = Character.BodyEffects
local Attack1 = Instance.new("Animation")
Attack1.AnimationId = "rbxassetid://12377210471"
local Attack2 = Instance.new("Animation")
Attack2.AnimationId = "rbxassetid://12377214387"
local slowdown = 8
local slowdown2 = 8
local normalSpeed = 16
local normalSpeed2 = 16
local enabled = false
local track1
local track2
tool.Activated:Connect(function()
	if Attack1Toggle.Value == false then
		local player = game.Players:FindFirstChild(tool.Parent.Name)
		if enabled then
			return
		end
		enabled = true
		Attack1Toggle.Value = true
		Attack2Toggle.Value = false

		track1 = script.Parent.Parent.Humanoid:LoadAnimation(Attack1)
		track1.Priority = Enum.AnimationPriority.Action
		track1.Looped = false
		local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 10)
		track1:Play()
		script.Parent.Handle.SFX_Slash:Play()
		script.Parent.Assets.Disabled = false
		wait(0.97)
		script.Parent.Assets.Disabled = true
        wait(0.3)
        ReduceWalk:Destroy()
		enabled = false
	end
end)
tool2.Activated:Connect(function()
	if Attack1Toggle.Value == true then
		local player = game.Players:FindFirstChild(tool.Parent.Name)
		if enabled then
			return
		end
		enabled = true
		Attack1Toggle.Value = false
		Attack2Toggle.Value = true

		track2 = script.Parent.Parent.Humanoid:LoadAnimation(Attack2)
		track2.Priority = Enum.AnimationPriority.Action
		track2.Looped = false
		local ReduceWalk = require(game:GetService('ReplicatedStorage').MainModule).MovementChange(BodyEffects.Movement, 'ReduceWalk', 10)
		track2:Play()
		script.Parent.Handle.SFX_Slash:Play()
		script.Parent.Assets.Disabled = false

		wait(0.98)
		script.Parent.Assets.Disabled = true
		wait(0.3)
        ReduceWalk:Destroy()
		enabled = false
	end
end)


]]
	elseif v.Parent.Name == "[Phone]" then
		source = [[local Player
Player = game:GetService('Players')[script.Parent.Parent.Parent.Name]
script.Parent.Equipped:Connect(function()
	if Player.DataFolder.Information:FindFirstChild('NewPhone') then
		if Player.DataFolder.Information.NewPhone.Value == '[iPhone]' then
			pcall(function()
				script.Parent['[iPhone]'].Transparency = 0
				script.Parent['[iPhone]'].TextureID = 'rbxassetid://430345284'
				for i,v in pairs(script.Parent:GetChildren()) do
					if v.Name ~= '[iPhone]' then
						pcall(function()
							v.Transparency = 1
						end)
					end
				end
				for i,v in pairs(script.Parent.Handle:GetDescendants()) do
					pcall(function()
						v.Transparency = 1
					end)
				end
			end)
		elseif Player.DataFolder.Information.NewPhone.Value == '[iPhoneB]' then
			pcall(function()
				script.Parent['[iPhone]'].Transparency = 0
				script.Parent['[iPhone]'].TextureID = 'rbxassetid://3188884604'
				for i,v in pairs(script.Parent:GetChildren()) do
					if v.Name ~= '[iPhone]' then
						pcall(function()
							v.Transparency = 1
						end)
					end
				end
				for i,v in pairs(script.Parent.Handle:GetDescendants()) do
					pcall(function()
						v.Transparency = 1
					end)
				end
			end)
		elseif Player.DataFolder.Information.NewPhone.Value == '[iPhoneG]' then
			pcall(function()
				script.Parent['[iPhone]'].Transparency = 0
				script.Parent['[iPhone]'].TextureID = 'rbxassetid://3188884779'
				for i,v in pairs(script.Parent:GetChildren()) do
					if v.Name ~= '[iPhone]' then
						pcall(function()
							v.Transparency = 1
						end)
					end
				end
				for i,v in pairs(script.Parent.Handle:GetDescendants()) do
					pcall(function()
						v.Transparency = 1
					end)
				end
			end)
		elseif Player.DataFolder.Information.NewPhone.Value == '[iPhoneP]' then
			pcall(function()
				script.Parent['[iPhone]'].Transparency = 0
				script.Parent['[iPhone]'].TextureID = 'rbxassetid://3188884956'
				for i,v in pairs(script.Parent:GetChildren()) do
					if v.Name ~= '[iPhone]' then
						pcall(function()
							v.Transparency = 1
						end)
					end
				end
				for i,v in pairs(script.Parent.Handle:GetDescendants()) do
					pcall(function()
						v.Transparency = 1
					end)
				end
			end)
		elseif Player.DataFolder.Information.NewPhone.Value == '[PinkPhone]' then
			pcall(function()
				script.Parent['[PinkPhone]'].Transparency = 0
				for i,v in pairs(script.Parent:GetChildren()) do
					if v.Name ~= '[PinkPhone]' then
						pcall(function()
							v.Transparency = 1
						end)
					end
				end
				for i,v in pairs(script.Parent.Handle:GetDescendants()) do
					pcall(function()
						v.Transparency = 1
					end)
				end
			end)
		elseif Player.DataFolder.Information.NewPhone.Value == '[Old Phone]' then
			pcall(function()
				script.Parent['[Old Phone]'].Transparency = 0
				for i,v in pairs(script.Parent:GetChildren()) do
					if v.Name ~= '[Old Phone]' then
						pcall(function()
							v.Transparency = 1
						end)
					end
				end
				for i,v in pairs(script.Parent.Handle:GetDescendants()) do
					pcall(function()
						v.Transparency = 1
					end)
				end
			end)
		elseif Player.DataFolder.Information.NewPhone.Value == '[Orange Phone]' then
			pcall(function()
				script.Parent['[Orange Phone]'].Transparency = 0
				for i,v in pairs(script.Parent:GetChildren()) do
					if v.Name ~= '[Orange Phone]' then
						pcall(function()
							v.Transparency = 1
						end)
					end
				end
				for i,v in pairs(script.Parent.Handle:GetDescendants()) do
					pcall(function()
						v.Transparency = 1
					end)
				end
			end)
		elseif Player.DataFolder.Information.NewPhone.Value == '[Original Phone]' then
			pcall(function()
				script.Parent.Handle.Transparency = 0
				for i,v in pairs(script.Parent:GetChildren()) do
					if v.Name ~= 'Handle' then
						pcall(function()
							v.Transparency = 1
						end)
					end
				end
				for i,v in pairs(script.Parent.Handle:GetDescendants()) do
					pcall(function()
						v.Transparency = 0
					end)
				end
			end)
		end
	else 
		pcall(function()
			script.Parent.Handle.Transparency = 0
			for i,v in pairs(script.Parent:GetChildren()) do
				if v.Name ~= 'Handle' then
					pcall(function()
						v.Transparency = 1
					end)
				end
			end
			for i,v in pairs(script.Parent.Handle:GetDescendants()) do
				pcall(function()
					v.Transparency = 0
				end)
			end
		end)
	end
	pcall(function()
		if Player.Character then
			if Player.Character:FindFirstChild('BodyEffects') then
				if Player.Character.BodyEffects:FindFirstChild('Calling') and Player.Character.BodyEffects:FindFirstChild('CallFrom') then
					if Player.Character.BodyEffects.CallFrom.Value ~= nil then
						local Player2 = Player.Character.BodyEffects.CallFrom.Value
						if Player.Character.BodyEffects.Calling.Value == true then
							return
						end
						Player.Character.BodyEffects.Calling.Value = true
						if Player2.Character:FindFirstChild('[Phone]') then
							Player2.Character.BodyEffects.Calling.Value = true
							Player2.Character.BodyEffects.CallFrom.Value = Player
							Player.Character['[Phone]'].Handle.PickUp:Play()
							Player2.Character['[Phone]'].Handle.PickUp:Play()
							game:GetService('Chat'):Chat(Player.Character['[Phone]'].Handle, '*pick up*', Enum.ChatColor.Green)
							game:GetService('Chat'):Chat(Player2.Character['[Phone]'].Handle, '*pick up*', Enum.ChatColor.Green)
						end
					end
				end
			end
		end
	end)
end)

script.Parent.Unequipped:Connect(function()
	pcall(function()
		if Player.Character then
			if Player.Character then
				if Player.Character:FindFirstChild('BodyEffects') then
					if Player.Character.BodyEffects:FindFirstChild('Calling') and Player.Character.BodyEffects:FindFirstChild('CallFrom') then
						pcall(function()
							if Player.Character.BodyEffects.CallFrom.Value ~= nil then
								local Player2 = Player.Character.BodyEffects.CallFrom.Value
								if Player2.Character:FindFirstChild('[Phone]') then
									Player2.Character.BodyEffects.Calling.Value = false 
									Player2.Character.BodyEffects.CallFrom.Value = nil
									script.Parent.Handle.EndCalls:Play()
									Player2.Character['[Phone]'].Handle.EndCalls:Play()
									game:GetService('Chat'):Chat(Player2.Character['[Phone]'].Handle, '*beep*', Enum.ChatColor.Red)
								end
							end
						end)
						Player.Character.BodyEffects.Calling.Value = false 
						Player.Character.BodyEffects.CallFrom.Value = nil
					end
				end
			end
		end
	end)
end)]]
	elseif v.Name == "FerrisWheelScript" then
		source = [[local CD = script.Parent:FindFirstChildOfClass('ClickDetector')
local Activated = false

CD.MouseClick:Connect(function(Player)
	pcall(function()
		if not Player:FindFirstChild('LOAD_SAVE_DATA') then
			return
		end
		if Activated then
			return
		end
		if Player:DistanceFromCharacter(script.Parent.Position) <= CD.MaxActivationDistance then
			Activated = true
			for i = 1, 4 do
				game:GetService('ReplicatedStorage').MainEvent:FireAllClients('FerrisWheelUPDATE', script.Parent.Parent.Parent, script.Parent.Parent.Parent.Wheel.Center.CFrame * CFrame.Angles(math.rad(90 * i), 0, 0), 10)
				task.wait(15)
			end
			task.wait(15)
			Activated = false
		end
	end)
end)]]
	elseif v.Name == "Kill brick" then
		source = [[--Variables--
local Brick = script.Parent
--End--

--Code--
local function PlayerTouched(Part)
	local Parent = Part.Parent
	if game.Players:GetPlayerFromCharacter(Parent) then
		Parent.Humanoid.Health = 0
	end
end

Brick.Touched:connect(PlayerTouched)]]
	elseif v.Name == "AdPortalEffectsController" then
		source = [[local portalModel = script.Parent.Parent
local stateDependent = script.Parent:WaitForChild("StateDependent")
local blockerFolder = stateDependent:WaitForChild("Blocker")
local fxFolder = stateDependent:WaitForChild("FX")
local basePortalPackage = portalModel:WaitForChild("BasePortal")
local adPortal = basePortalPackage:WaitForChild("Door"):WaitForChild("AdPortal")
local function configureBlockerEffect(instance: Instance, isActive: boolean)
	if instance:IsA("Part") then
		instance.Transparency = if isActive then 1 else 0
		instance.CanCollide = not isActive
	end
end
local function configureVisualEffect(instance: Instance, isActive: boolean)
	if instance:IsA("ParticleEmitter") or instance:IsA("Light") or instance:IsA("Beam") then
		instance.Enabled = isActive
	elseif instance:IsA("UnionOperation") then
		instance.Transparency = if isActive then 0 else 1
		-- Don't update CanCollide property for Arrow unions
		if instance.Name ~= "Arrow" then
			instance.CanCollide = isActive
		end
	elseif instance:IsA("Sound") then
		if isActive then
			instance:Play()
		else
			instance:Stop()
		end
	end
end
local function onAdStatusChange()
	local isActive = (adPortal.Status == Enum.AdUnitStatus.Active)
	-- Configure Blocker parts based on the AdPortalStatus
	for _, instance in pairs(blockerFolder:GetDescendants()) do
		configureBlockerEffect(instance, isActive)
	end
	-- Configure other visual effects based on the AdPortalStatus
	for _, instance in pairs(fxFolder:GetDescendants()) do
		configureVisualEffect(instance, isActive)
	end
end
-- Update when the Status signal changes
adPortal:GetPropertyChangedSignal("Status"):Connect(onAdStatusChange)
-- Catch any Blocker unloaded descendants
blockerFolder.DescendantAdded:Connect(function(instance)
	configureBlockerEffect(instance, adPortal.Status == Enum.AdUnitStatus.Active)
end)
-- Catch any FX unloaded descendants
fxFolder.DescendantAdded:Connect(function(instance)
	configureVisualEffect(instance, adPortal.Status == Enum.AdUnitStatus.Active)
end)
-- Set the portal effects based on the initial Status value
onAdStatusChange()]]
	end
	return source
end

function medaldecompile(scr)
    local ScriptBytecode = getscriptbytecode(Script)
    if ScriptBytecode then
        local Output = request({
            Url = 'https://decompiler.ashore.rip/decompile',
            Method = "POST",
            Body = ScriptBytecode
        })
        if Output.StatusCode == 200 then
            return Output.Body
        end
        return
    end
end

function krampusdecompile(scr)
	local httpService = game:GetService("HttpService")
	local s, bytecode = pcall(getscriptbytecode, scr)
    	if not s then
        	return
    	end
	
    	local response = request({
        	Url = 'https://unluau.lonegladiator.dev/unluau/decompile',
        	Method = 'POST',
        	Headers = {
 	           ['Content-Type'] = 'application/json',
 	       },
   	     Body = httpService:JSONEncode({
  	          version = 5,
   	          bytecode = crypt.base64.encode(bytecode)
  	     })
  	  })
	
   	 local decoded = httpService:JSONDecode(response.Body)
   	 if decoded.status ~= 'ok' then
   	     return
  	 end
	
  	 return decoded.output
end

function simpledecompile(scr)
	local _decompilefunc = loadstring(game:HttpGet("https://scriptblox.com/raw/Universal-Script-SimpleDecompile-V2-12641"))()
	return _decompilefunc(scr)
end

local nodes = {}
local selection
local cloneref = cloneref or function(...) return ... end

local EmbeddedModules = {
Explorer = function()
--[[
	Explorer App Module
	
	The main explorer interface
]]

-- Common Locals
local Main,Lib,Apps,Settings -- Main Containers
local Explorer, Properties, ScriptViewer, Notebook -- Major Apps
local API,RMD,env,service,plr,create,createSimple -- Main Locals

local function initDeps(data)
	Main = data.Main
	Lib = data.Lib
	Apps = data.Apps
	Settings = data.Settings

	API = data.API
	RMD = data.RMD
	env = data.env
	service = data.service
	plr = data.plr
	create = data.create
	createSimple = data.createSimple
end

local function initAfterMain()
	Explorer = Apps.Explorer
	Properties = Apps.Properties
	ScriptViewer = Apps.ScriptViewer
	Notebook = Apps.Notebook
end

local function main()
	local Explorer = {}
	local tree,listEntries,explorerOrders,searchResults,specResults = {},{},{},{},{}
	local expanded
	local entryTemplate,treeFrame,toolBar,descendantAddedCon,descendantRemovingCon,itemChangedCon
	local ffa = game.FindFirstAncestorWhichIsA
	local getDescendants = game.GetDescendants
	local getTextSize = service.TextService.GetTextSize
	local updateDebounce,refreshDebounce = false,false
	local nilNode = {Obj = Instance.new("Folder")}
	local idCounter = 0
	local scrollV,scrollH,clipboard
	local renameBox,renamingNode,searchFunc
	local sortingEnabled,autoUpdateSearch
	local table,math = table,math
	local nilMap,nilCons = {},{}
	local connectSignal = game.DescendantAdded.Connect
	local addObject,removeObject,moveObject = nil,nil,nil

	addObject = function(root)
		if nodes[root] then return end

		local isNil = false
		local rootParObj = ffa(root,"Instance")
		local par = nodes[rootParObj]

		-- Nil Handling
		if not par then
			if nilMap[root] then
				nilCons[root] = nilCons[root] or {
					connectSignal(root.ChildAdded,addObject),
					connectSignal(root.AncestryChanged,moveObject),
				}
				par = nilNode
				isNil = true
			else
				return
			end
		elseif nilMap[rootParObj] or par == nilNode then
			nilMap[root] = true
			nilCons[root] = nilCons[root] or {
				connectSignal(root.ChildAdded,addObject),
				connectSignal(root.AncestryChanged,moveObject),
			}
			isNil = true
		end

		local newNode = {Obj = root, Parent = par}
		nodes[root] = newNode

		-- Automatic sorting if expanded
		if sortingEnabled and expanded[par] and par.Sorted then
			local left,right = 1,#par
			local floor = math.floor
			local sorter = Explorer.NodeSorter
			local pos = (right == 0 and 1)

			if not pos then
				while true do
					if left >= right then
						if sorter(newNode,par[left]) then
							pos = left
						else
							pos = left+1
						end
						break
					end

					local mid = floor((left+right)/2)
					if sorter(newNode,par[mid]) then
						right = mid-1
					else
						left = mid+1
					end
				end
			end

			table.insert(par,pos,newNode)
		else
			par[#par+1] = newNode
			par.Sorted = nil
		end

		local insts = getDescendants(root)
		for i = 1,#insts do
			local obj = insts[i]
			if nodes[obj] then continue end -- Deferred
			
			local par = nodes[ffa(obj,"Instance")]
			if not par then continue end
			local newNode = {Obj = obj, Parent = par}
			nodes[obj] = newNode
			par[#par+1] = newNode

			-- Nil Handling
			if isNil then
				nilMap[obj] = true
				nilCons[obj] = nilCons[obj] or {
					connectSignal(obj.ChildAdded,addObject),
					connectSignal(obj.AncestryChanged,moveObject),
				}
			end
		end

		if searchFunc and autoUpdateSearch then
			searchFunc({newNode})
		end

		if not updateDebounce and Explorer.IsNodeVisible(par) then
			if expanded[par] then
				Explorer.PerformUpdate()
			elseif not refreshDebounce then
				Explorer.PerformRefresh()
			end
		end
	end

	removeObject = function(root)
		local node = nodes[root]
		if not node then return end

		-- Nil Handling
		if nilMap[node.Obj] then
			moveObject(node.Obj)
			return
		end

		local par = node.Parent
		if par then
			par.HasDel = true
		end

		local function recur(root)
			for i = 1,#root do
				local node = root[i]
				if not node.Del then
					nodes[node.Obj] = nil
					if #node > 0 then recur(node) end
				end
			end
		end
		recur(node)
		node.Del = true
		nodes[root] = nil

		if par and not updateDebounce and Explorer.IsNodeVisible(par) then
			if expanded[par] then
				Explorer.PerformUpdate()
			elseif not refreshDebounce then
				Explorer.PerformRefresh()
			end
		end
	end

	moveObject = function(obj)
		local node = nodes[obj]
		if not node then return end

		local oldPar = node.Parent
		local newPar = nodes[ffa(obj,"Instance")]
		if oldPar == newPar then return end

		-- Nil Handling
		if not newPar then
			if nilMap[obj] then
				newPar = nilNode
			else
				return
			end
		elseif nilMap[newPar.Obj] or newPar == nilNode then
			nilMap[obj] = true
			nilCons[obj] = nilCons[obj] or {
				connectSignal(obj.ChildAdded,addObject),
				connectSignal(obj.AncestryChanged,moveObject),
			}
		end

		if oldPar then
			local parPos = table.find(oldPar,node)
			if parPos then table.remove(oldPar,parPos) end
		end

		node.Id = nil
		node.Parent = newPar

		if sortingEnabled and expanded[newPar] and newPar.Sorted then
			local left,right = 1,#newPar
			local floor = math.floor
			local sorter = Explorer.NodeSorter
			local pos = (right == 0 and 1)

			if not pos then
				while true do
					if left >= right then
						if sorter(node,newPar[left]) then
							pos = left
						else
							pos = left+1
						end
						break
					end

					local mid = floor((left+right)/2)
					if sorter(node,newPar[mid]) then
						right = mid-1
					else
						left = mid+1
					end
				end
			end

			table.insert(newPar,pos,node)
		else
			newPar[#newPar+1] = node
			newPar.Sorted = nil
		end

		if searchFunc and searchResults[node] then
			local currentNode = node.Parent
			while currentNode and (not searchResults[currentNode] or expanded[currentNode] == 0) do
				expanded[currentNode] = true
				searchResults[currentNode] = true
				currentNode = currentNode.Parent
			end
		end

		if not updateDebounce and (Explorer.IsNodeVisible(newPar) or Explorer.IsNodeVisible(oldPar)) then
			if expanded[newPar] or expanded[oldPar] then
				Explorer.PerformUpdate()
			elseif not refreshDebounce then
				Explorer.PerformRefresh()
			end
		end
	end

	Explorer.ViewWidth = 0
	Explorer.Index = 0
	Explorer.EntryIndent = 20
	Explorer.FreeWidth = 32
	Explorer.GuiElems = {}

	Explorer.InitRenameBox = function()
		renameBox = create({{1,"TextBox",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderColor3=Color3.new(0.062745101749897,0.51764708757401,1),BorderMode=2,ClearTextOnFocus=false,Font=3,Name="RenameBox",PlaceholderColor3=Color3.new(0.69803923368454,0.69803923368454,0.69803923368454),Position=UDim2.new(0,26,0,2),Size=UDim2.new(0,200,0,16),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,TextXAlignment=0,Visible=false,ZIndex=2}}})

		renameBox.Parent = Explorer.Window.GuiElems.Content.List

		renameBox.FocusLost:Connect(function()
			if not renamingNode then return end

			pcall(function() renamingNode.Obj.Name = renameBox.Text end)
			renamingNode = nil
			Explorer.Refresh()
		end)

		renameBox.Focused:Connect(function()
			renameBox.SelectionStart = 1
			renameBox.CursorPosition = #renameBox.Text + 1
		end)
	end

	Explorer.SetRenamingNode = function(node)
		renamingNode = node
		renameBox.Text = tostring(node.Obj)
		renameBox:CaptureFocus()
		Explorer.Refresh()
	end

	Explorer.SetSortingEnabled = function(val)
		sortingEnabled = val
		Settings.Explorer.Sorting = val
	end

	Explorer.UpdateView = function()
		local maxNodes = math.ceil(treeFrame.AbsoluteSize.Y / 20)
		local maxX = treeFrame.AbsoluteSize.X
		local totalWidth = Explorer.ViewWidth + Explorer.FreeWidth

		scrollV.VisibleSpace = maxNodes
		scrollV.TotalSpace = #tree + 1
		scrollH.VisibleSpace = maxX
		scrollH.TotalSpace = totalWidth

		scrollV.Gui.Visible = #tree + 1 > maxNodes
		scrollH.Gui.Visible = totalWidth > maxX

		local oldSize = treeFrame.Size
		treeFrame.Size = UDim2.new(1,(scrollV.Gui.Visible and -16 or 0),1,(scrollH.Gui.Visible and -39 or -23))
		if oldSize ~= treeFrame.Size then
			Explorer.UpdateView()
		else
			scrollV:Update()
			scrollH:Update()

			renameBox.Size = UDim2.new(0,maxX-100,0,16)

			if scrollV.Gui.Visible and scrollH.Gui.Visible then
				scrollV.Gui.Size = UDim2.new(0,16,1,-39)
				scrollH.Gui.Size = UDim2.new(1,-16,0,16)
				Explorer.Window.GuiElems.Content.ScrollCorner.Visible = true
			else
				scrollV.Gui.Size = UDim2.new(0,16,1,-23)
				scrollH.Gui.Size = UDim2.new(1,0,0,16)
				Explorer.Window.GuiElems.Content.ScrollCorner.Visible = false
			end

			Explorer.Index = scrollV.Index
		end
	end

	Explorer.NodeSorter = function(a,b)
		if a.Del or b.Del then return false end -- Ghost node

		local aClass = a.Class
		local bClass = b.Class
		if not aClass then aClass = a.Obj.ClassName a.Class = aClass end
		if not bClass then bClass = b.Obj.ClassName b.Class = bClass end

		local aOrder = explorerOrders[aClass]
		local bOrder = explorerOrders[bClass]
		if not aOrder then aOrder = RMD.Classes[aClass] and tonumber(RMD.Classes[aClass].ExplorerOrder) or 9999 explorerOrders[aClass] = aOrder end
		if not bOrder then bOrder = RMD.Classes[bClass] and tonumber(RMD.Classes[bClass].ExplorerOrder) or 9999 explorerOrders[bClass] = bOrder end

		if aOrder ~= bOrder then
			return aOrder < bOrder
		else
			local aName,bName = tostring(a.Obj),tostring(b.Obj)
			if aName ~= bName then
				return aName < bName
			elseif aClass ~= bClass then
				return aClass < bClass
			else
				local aId = a.Id if not aId then aId = idCounter idCounter = (idCounter+0.001)%999999999 a.Id = aId end
				local bId = b.Id if not bId then bId = idCounter idCounter = (idCounter+0.001)%999999999 b.Id = bId end
				return aId < bId
			end
		end
	end

	Explorer.Update = function()
		table.clear(tree)
		local maxNameWidth,maxDepth,count = 0,1,1
		local nameCache = {}
		local font = Enum.Font.SourceSans
		local size = Vector2.new(math.huge,20)
		local useNameWidth = Settings.Explorer.UseNameWidth
		local tSort = table.sort
		local sortFunc = Explorer.NodeSorter
		local isSearching = (expanded == Explorer.SearchExpanded)
		local textServ = service.TextService

		local function recur(root,depth)
			if depth > maxDepth then maxDepth = depth end
			depth = depth + 1
			if sortingEnabled and not root.Sorted then
				tSort(root,sortFunc)
				root.Sorted = true
			end
			for i = 1,#root do
				local n = root[i]

				if (isSearching and not searchResults[n]) or n.Del then continue end

				if useNameWidth then
					local nameWidth = n.NameWidth
					if not nameWidth then
						local objName = tostring(n.Obj)
						nameWidth = nameCache[objName]
						if not nameWidth then
							nameWidth = getTextSize(textServ,objName,14,font,size).X
							nameCache[objName] = nameWidth
						end
						n.NameWidth = nameWidth
					end
					if nameWidth > maxNameWidth then
						maxNameWidth = nameWidth
					end
				end

				tree[count] = n
				count = count + 1
				if expanded[n] and #n > 0 then
					recur(n,depth)
				end
			end
		end

		recur(nodes[game],1)

		-- Nil Instances
		if env.getnilinstances then
			if not (isSearching and not searchResults[nilNode]) then
				tree[count] = nilNode
				count = count + 1
				if expanded[nilNode] then
					recur(nilNode,2)
				end
			end
		end

		Explorer.MaxNameWidth = maxNameWidth
		Explorer.MaxDepth = maxDepth
		Explorer.ViewWidth = useNameWidth and Explorer.EntryIndent*maxDepth + maxNameWidth + 26 or Explorer.EntryIndent*maxDepth + 226
		Explorer.UpdateView()
	end

	Explorer.StartDrag = function(offX,offY)
		if Explorer.Dragging then return end
		Explorer.Dragging = true

		local dragTree = treeFrame:Clone()
		dragTree:ClearAllChildren()

		for i,v in pairs(listEntries) do
			local node = tree[i + Explorer.Index]
			if node and selection.Map[node] then
				local clone = v:Clone()
				clone.Active = false
				clone.Indent.Expand.Visible = false
				clone.Parent = dragTree
			end
		end

		local newGui = Instance.new("ScreenGui")
		newGui.DisplayOrder = Main.DisplayOrders.Menu
		dragTree.Parent = newGui
		Lib.ShowGui(newGui)

		local dragOutline = create({
			{1,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Name="DragSelect",Size=UDim2.new(1,0,1,0),}},
			{2,"Frame",{BackgroundColor3=Color3.new(1,1,1),BorderSizePixel=0,Name="Line",Parent={1},Size=UDim2.new(1,0,0,1),ZIndex=2,}},
			{3,"Frame",{BackgroundColor3=Color3.new(1,1,1),BorderSizePixel=0,Name="Line",Parent={1},Position=UDim2.new(0,0,1,-1),Size=UDim2.new(1,0,0,1),ZIndex=2,}},
			{4,"Frame",{BackgroundColor3=Color3.new(1,1,1),BorderSizePixel=0,Name="Line",Parent={1},Size=UDim2.new(0,1,1,0),ZIndex=2,}},
			{5,"Frame",{BackgroundColor3=Color3.new(1,1,1),BorderSizePixel=0,Name="Line",Parent={1},Position=UDim2.new(1,-1,0,0),Size=UDim2.new(0,1,1,0),ZIndex=2,}},
		})
		dragOutline.Parent = treeFrame


		local mouse = Main.Mouse or service.Players.LocalPlayer:GetMouse()
		local function move()
			local posX = mouse.X - offX
			local posY = mouse.Y - offY
			dragTree.Position = UDim2.new(0,posX,0,posY)

			for i = 1,#listEntries do
				local entry = listEntries[i]
				if Lib.CheckMouseInGui(entry) then
					dragOutline.Position = UDim2.new(0,entry.Indent.Position.X.Offset-scrollH.Index,0,entry.Position.Y.Offset)
					dragOutline.Size = UDim2.new(0,entry.Size.X.Offset-entry.Indent.Position.X.Offset,0,20)
					dragOutline.Visible = true
					return
				end
			end
			dragOutline.Visible = false
		end
		move()

		local input = service.UserInputService
		local mouseEvent,releaseEvent

		mouseEvent = input.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				move()
			end
		end)

		releaseEvent = input.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				releaseEvent:Disconnect()
				mouseEvent:Disconnect()
				newGui:Destroy()
				dragOutline:Destroy()
				Explorer.Dragging = false

				for i = 1,#listEntries do
					if Lib.CheckMouseInGui(listEntries[i]) then
						local node = tree[i + Explorer.Index]
						if node then
							if selection.Map[node] then return end
							local newPar = node.Obj
							local sList = selection.List
							for i = 1,#sList do
								local n = sList[i]
								pcall(function() n.Obj.Parent = newPar end)
							end
							Explorer.ViewNode(sList[1])
						end
						break
					end
				end
			end
		end)
	end

	Explorer.NewListEntry = function(index)
		local newEntry = entryTemplate:Clone()
		newEntry.Position = UDim2.new(0,0,0,20*(index-1))

		local isRenaming = false

		newEntry.InputBegan:Connect(function(input)
			local node = tree[index + Explorer.Index]
			if not node or selection.Map[node] or input.UserInputType ~= Enum.UserInputType.MouseMovement then return end

			newEntry.Indent.BackgroundColor3 = Settings.Theme.Button
			newEntry.Indent.BorderSizePixel = 0
			newEntry.Indent.BackgroundTransparency = 0
		end)

		newEntry.InputEnded:Connect(function(input)
			local node = tree[index + Explorer.Index]
			if not node or selection.Map[node] or input.UserInputType ~= Enum.UserInputType.MouseMovement then return end

			newEntry.Indent.BackgroundTransparency = 1
		end)

		newEntry.MouseButton1Down:Connect(function()

		end)

		newEntry.MouseButton1Up:Connect(function()

		end)

		newEntry.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 then
				local releaseEvent,mouseEvent

				local mouse = Main.Mouse or plr:GetMouse()
				local startX = mouse.X
				local startY = mouse.Y

				local listOffsetX = startX - treeFrame.AbsolutePosition.X
				local listOffsetY = startY - treeFrame.AbsolutePosition.Y

				releaseEvent = cloneref(game:GetService("UserInputService")).InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						releaseEvent:Disconnect()
						mouseEvent:Disconnect()
					end
				end)

				mouseEvent = cloneref(game:GetService("UserInputService")).InputChanged:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						local deltaX = mouse.X - startX
						local deltaY = mouse.Y - startY
						local dist = math.sqrt(deltaX^2 + deltaY^2)

						if dist > 5 then
							releaseEvent:Disconnect()
							mouseEvent:Disconnect()
							isRenaming = false
							Explorer.StartDrag(listOffsetX,listOffsetY)
						end
					end
				end)
			end
		end)

		newEntry.MouseButton2Down:Connect(function()

		end)

		newEntry.Indent.Expand.InputBegan:Connect(function(input)
			local node = tree[index + Explorer.Index]
			if not node or input.UserInputType ~= Enum.UserInputType.MouseMovement then return end

			Explorer.MiscIcons:DisplayByKey(newEntry.Indent.Expand.Icon, expanded[node] and "Collapse_Over" or "Expand_Over")
		end)

		newEntry.Indent.Expand.InputEnded:Connect(function(input)
			local node = tree[index + Explorer.Index]
			if not node or input.UserInputType ~= Enum.UserInputType.MouseMovement then return end

			Explorer.MiscIcons:DisplayByKey(newEntry.Indent.Expand.Icon, expanded[node] and "Collapse" or "Expand")
		end)

		newEntry.Indent.Expand.MouseButton1Down:Connect(function()
			local node = tree[index + Explorer.Index]
			if not node or #node == 0 then return end

			expanded[node] = not expanded[node]
			Explorer.Update()
			Explorer.Refresh()
		end)

		newEntry.Parent = treeFrame
		return newEntry
	end

	Explorer.Refresh = function()
		local maxNodes = math.max(math.ceil((treeFrame.AbsoluteSize.Y) / 20),0)	
		local renameNodeVisible = false
		local isa = game.IsA

		for i = 1,maxNodes do
			local entry = listEntries[i]
			if not listEntries[i] then entry = Explorer.NewListEntry(i) listEntries[i] = entry Explorer.ClickSystem:Add(entry) end

			local node = tree[i + Explorer.Index]
			if node then
				local obj = node.Obj
				local depth = Explorer.EntryIndent*Explorer.NodeDepth(node)

				entry.Visible = true
				entry.Position = UDim2.new(0,-scrollH.Index,0,entry.Position.Y.Offset)
				entry.Size = UDim2.new(0,Explorer.ViewWidth,0,20)
				entry.Indent.EntryName.Text = tostring(node.Obj)
				entry.Indent.Position = UDim2.new(0,depth,0,0)
				entry.Indent.Size = UDim2.new(1,-depth,1,0)

				entry.Indent.EntryName.TextTruncate = (Settings.Explorer.UseNameWidth and Enum.TextTruncate.None or Enum.TextTruncate.AtEnd)

				if (isa(obj,"LocalScript") or isa(obj,"Script")) and obj.Disabled then
					Explorer.MiscIcons:DisplayByKey(entry.Indent.Icon, isa(obj,"LocalScript") and "LocalScript_Disabled" or "Script_Disabled")
				else
					local rmdEntry = RMD.Classes[obj.ClassName]
					Explorer.ClassIcons:Display(entry.Indent.Icon, rmdEntry and rmdEntry.ExplorerImageIndex or 0)
				end

				if selection.Map[node] then
					entry.Indent.BackgroundColor3 = Settings.Theme.ListSelection
					entry.Indent.BorderSizePixel = 0
					entry.Indent.BackgroundTransparency = 0
				else
					if Lib.CheckMouseInGui(entry) then
						entry.Indent.BackgroundColor3 = Settings.Theme.Button
					else
						entry.Indent.BackgroundTransparency = 1
					end
				end

				if node == renamingNode then
					renameNodeVisible = true
					renameBox.Position = UDim2.new(0,depth+25-scrollH.Index,0,entry.Position.Y.Offset+2)
					renameBox.Visible = true
				end

				if #node > 0 and expanded[node] ~= 0 then
					if Lib.CheckMouseInGui(entry.Indent.Expand) then
						Explorer.MiscIcons:DisplayByKey(entry.Indent.Expand.Icon, expanded[node] and "Collapse_Over" or "Expand_Over")
					else
						Explorer.MiscIcons:DisplayByKey(entry.Indent.Expand.Icon, expanded[node] and "Collapse" or "Expand")
					end
					entry.Indent.Expand.Visible = true
				else
					entry.Indent.Expand.Visible = false
				end
			else
				entry.Visible = false
			end
		end

		if not renameNodeVisible then
			renameBox.Visible = false
		end

		for i = maxNodes+1, #listEntries do
			Explorer.ClickSystem:Remove(listEntries[i])
			listEntries[i]:Destroy()
			listEntries[i] = nil
		end
	end

	Explorer.PerformUpdate = function(instant)
		updateDebounce = true
		Lib.FastWait(not instant and 0.1)
		if not updateDebounce then return end
		updateDebounce = false
		if not Explorer.Window:IsVisible() then return end
		Explorer.Update()
		Explorer.Refresh()
	end

	Explorer.ForceUpdate = function(norefresh)
		updateDebounce = false
		Explorer.Update()
		if not norefresh then Explorer.Refresh() end
	end

	Explorer.PerformRefresh = function()
		refreshDebounce = true
		Lib.FastWait(0.1)
		refreshDebounce = false
		if updateDebounce or not Explorer.Window:IsVisible() then return end
		Explorer.Refresh()
	end

	Explorer.IsNodeVisible = function(node)
		if not node then return end

		local curNode = node.Parent
		while curNode do
			if not expanded[curNode] then return false end
			curNode = curNode.Parent
		end
		return true
	end

	Explorer.NodeDepth = function(node)
		local depth = 0

		if node == nilNode then
			return 1
		end

		local curNode = node.Parent
		while curNode do
			if curNode == nilNode then depth = depth + 1 end
			curNode = curNode.Parent
			depth = depth + 1
		end
		return depth
	end

	Explorer.SetupConnections = function()
		if descendantAddedCon then descendantAddedCon:Disconnect() end
		if descendantRemovingCon then descendantRemovingCon:Disconnect() end
		if itemChangedCon then itemChangedCon:Disconnect() end

		if Main.Elevated then
			descendantAddedCon = game.DescendantAdded:Connect(addObject)
			descendantRemovingCon = game.DescendantRemoving:Connect(removeObject)
		else
			descendantAddedCon = game.DescendantAdded:Connect(function(obj) pcall(addObject,obj) end)
			descendantRemovingCon = game.DescendantRemoving:Connect(function(obj) pcall(removeObject,obj) end)
		end

		if Settings.Explorer.UseNameWidth then
			itemChangedCon = game.ItemChanged:Connect(function(obj,prop)
				if prop == "Parent" and nodes[obj] then
					moveObject(obj)
				elseif prop == "Name" and nodes[obj] then
					nodes[obj].NameWidth = nil
				end
			end)
		else
			itemChangedCon = game.ItemChanged:Connect(function(obj,prop)
				if prop == "Parent" and nodes[obj] then
					moveObject(obj)
				end
			end)
		end
	end

	Explorer.ViewNode = function(node)
		if not node then return end

		Explorer.MakeNodeVisible(node)
		Explorer.ForceUpdate(true)
		local visibleSpace = scrollV.VisibleSpace

		for i,v in next,tree do
			if v == node then
				local relative = i - 1
				if Explorer.Index > relative then
					scrollV.Index = relative
				elseif Explorer.Index + visibleSpace - 1 <= relative then
					scrollV.Index = relative - visibleSpace + 2
				end
			end
		end

		scrollV:Update() Explorer.Index = scrollV.Index
		Explorer.Refresh()
	end

	Explorer.ViewObj = function(obj)
		Explorer.ViewNode(nodes[obj])
	end

	Explorer.MakeNodeVisible = function(node,expandRoot)
		if not node then return end

		local hasExpanded = false

		if expandRoot and not expanded[node] then
			expanded[node] = true
			hasExpanded = true
		end

		local currentNode = node.Parent
		while currentNode do
			hasExpanded = true
			expanded[currentNode] = true
			currentNode = currentNode.Parent
		end

		if hasExpanded and not updateDebounce then
			coroutine.wrap(Explorer.PerformUpdate)(true)
		end
	end

	Explorer.ShowRightClick = function()
		local context = Explorer.RightClickContext
		context:Clear()

		local sList = selection.List
		local sMap = selection.Map
		local emptyClipboard = #clipboard == 0
		local presentClasses = {}
		local apiClasses = API.Classes

		for i = 1, #sList do
			local node = sList[i]
			local class = node.Class
			if not class then class = node.Obj.ClassName node.Class = class end
			local curClass = apiClasses[class]
			while curClass and not presentClasses[curClass.Name] do
				presentClasses[curClass.Name] = true
				curClass = curClass.Superclass
			end
		end

		context:AddRegistered("CUT")
		context:AddRegistered("COPY")
		context:AddRegistered("PASTE", emptyClipboard)
		context:AddRegistered("DUPLICATE")
		context:AddRegistered("DELETE")
		context:AddRegistered("RENAME", #sList ~= 1)

		context:AddDivider()
		context:AddRegistered("GROUP")
		context:AddRegistered("UNGROUP")
		context:AddRegistered("SELECT_CHILDREN")
		context:AddRegistered("JUMP_TO_PARENT")
		context:AddRegistered("EXPAND_ALL")
		context:AddRegistered("COLLAPSE_ALL")

		context:AddDivider()
		if expanded == Explorer.SearchExpanded then context:AddRegistered("CLEAR_SEARCH_AND_JUMP_TO") end
		if env.setclipboard then context:AddRegistered("COPY_PATH") end
		context:AddRegistered("INSERT_OBJECT")
		-- context:AddRegistered("SAVE_INST")
		-- context:AddRegistered("CALL_FUNCTION")
		-- context:AddRegistered("VIEW_CONNECTIONS")
		-- context:AddRegistered("GET_REFERENCES")
		-- context:AddRegistered("VIEW_API")
		
		context:QueueDivider()

		if presentClasses["BasePart"] or presentClasses["Model"] then
			context:AddRegistered("TELEPORT_TO")
			context:AddRegistered("VIEW_OBJECT")
		end

		if presentClasses["TouchTransmitter"] then context:AddRegistered("FIRE_TOUCHTRANSMITTER", firetouchinterest == nil) end
		if presentClasses["ClickDetector"] then context:AddRegistered("FIRE_CLICKDETECTOR", fireclickdetector == nil) end
		if presentClasses["ProximityPrompt"] then context:AddRegistered("FIRE_PROXIMITYPROMPT", fireproximityprompt == nil) end
		if presentClasses["Player"] then context:AddRegistered("SELECT_CHARACTER") end
		if presentClasses["Players"] then context:AddRegistered("SELECT_LOCAL_PLAYER") end
		if presentClasses["LuaSourceContainer"] then context:AddRegistered("VIEW_SCRIPT") end

		if sMap[nilNode] then
			context:AddRegistered("REFRESH_NIL")
			context:AddRegistered("HIDE_NIL")
		end

		Explorer.LastRightClickX, Explorer.LastRightClickY = Main.Mouse.X, Main.Mouse.Y
		context:Show()
	end

	Explorer.InitRightClick = function()
		local context = Lib.ContextMenu.new()

		context:Register("CUT",{Name = "Cut", IconMap = Explorer.MiscIcons, Icon = "Cut", DisabledIcon = "Cut_Disabled", Shortcut = "Ctrl+Z", OnClick = function()
			local destroy,clone = game.Destroy,game.Clone
			local sList,newClipboard = selection.List,{}
			local count = 1
			for i = 1,#sList do
				local inst = sList[i].Obj
				local s,cloned = pcall(clone,inst)
				if s and cloned then
					newClipboard[count] = cloned
					count = count + 1
				end
				pcall(destroy,inst)
			end
			clipboard = newClipboard
			selection:Clear()
		end})

		context:Register("COPY",{Name = "Copy", IconMap = Explorer.MiscIcons, Icon = "Copy", DisabledIcon = "Copy_Disabled", Shortcut = "Ctrl+C", OnClick = function()
			local clone = game.Clone
			local sList,newClipboard = selection.List,{}
			local count = 1
			for i = 1,#sList do
				local inst = sList[i].Obj
				local s,cloned = pcall(clone,inst)
				if s and cloned then
					newClipboard[count] = cloned
					count = count + 1
				end
			end
			clipboard = newClipboard
		end})

		context:Register("PASTE",{Name = "Paste Into", IconMap = Explorer.MiscIcons, Icon = "Paste", DisabledIcon = "Paste_Disabled", Shortcut = "Ctrl+Shift+V", OnClick = function()
			local sList = selection.List
			local newSelection = {}
			local count = 1
			for i = 1,#sList do
				local node = sList[i]
				local inst = node.Obj
				Explorer.MakeNodeVisible(node,true)
				for c = 1,#clipboard do
					local cloned = clipboard[c]:Clone()
					if cloned then
						cloned.Parent = inst
						local clonedNode = nodes[cloned]
						if clonedNode then newSelection[count] = clonedNode count = count + 1 end
					end
				end
			end
			selection:SetTable(newSelection)

			if #newSelection > 0 then
				Explorer.ViewNode(newSelection[1])
			end
		end})

		context:Register("DUPLICATE",{Name = "Duplicate", IconMap = Explorer.MiscIcons, Icon = "Copy", DisabledIcon = "Copy_Disabled", Shortcut = "Ctrl+D", OnClick = function()
			local clone = game.Clone
			local sList = selection.List
			local newSelection = {}
			local count = 1
			for i = 1,#sList do
				local node = sList[i]
				local inst = node.Obj
				local instPar = node.Parent and node.Parent.Obj
				Explorer.MakeNodeVisible(node)
				local s,cloned = pcall(clone,inst)
				if s and cloned then
					cloned.Parent = instPar
					local clonedNode = nodes[cloned]
					if clonedNode then newSelection[count] = clonedNode count = count + 1 end
				end
			end

			selection:SetTable(newSelection)
			if #newSelection > 0 then
				Explorer.ViewNode(newSelection[1])
			end
		end})

		context:Register("DELETE",{Name = "Delete", IconMap = Explorer.MiscIcons, Icon = "Delete", DisabledIcon = "Delete_Disabled", Shortcut = "Del", OnClick = function()
			local destroy = game.Destroy
			local sList = selection.List
			for i = 1,#sList do
				pcall(destroy,sList[i].Obj)
			end
			selection:Clear()
		end})

		context:Register("RENAME",{Name = "Rename", IconMap = Explorer.MiscIcons, Icon = "Rename", DisabledIcon = "Rename_Disabled", Shortcut = "F2", OnClick = function()
			local sList = selection.List
			if sList[1] then
				Explorer.SetRenamingNode(sList[1])
			end
		end})

		context:Register("GROUP",{Name = "Group", IconMap = Explorer.MiscIcons, Icon = "Group", DisabledIcon = "Group_Disabled", Shortcut = "Ctrl+G", OnClick = function()
			local sList = selection.List
			if #sList == 0 then return end

			local model = Instance.new("Model",sList[#sList].Obj.Parent)
			for i = 1,#sList do
				pcall(function() sList[i].Obj.Parent = model end)
			end

			if nodes[model] then
				selection:Set(nodes[model])
				Explorer.ViewNode(nodes[model])
			end
		end})

		context:Register("UNGROUP",{Name = "Ungroup", IconMap = Explorer.MiscIcons, Icon = "Ungroup", DisabledIcon = "Ungroup_Disabled", Shortcut = "Ctrl+U", OnClick = function()
			local newSelection = {}
			local count = 1
			local isa = game.IsA

			local function ungroup(node)
				local par = node.Parent.Obj
				local ch = {}
				local chCount = 1

				for i = 1,#node do
					local n = node[i]
					newSelection[count] = n
					ch[chCount] = n
					count = count + 1
					chCount = chCount + 1
				end

				for i = 1,#ch do
					pcall(function() ch[i].Obj.Parent = par end)
				end

				node.Obj:Destroy()
			end

			for i,v in next,selection.List do
				if isa(v.Obj,"Model") then
					ungroup(v)
				end
			end

			selection:SetTable(newSelection)
			if #newSelection > 0 then
				Explorer.ViewNode(newSelection[1])
			end
		end})

		context:Register("SELECT_CHILDREN",{Name = "Select Children", IconMap = Explorer.MiscIcons, Icon = "SelectChildren", DisabledIcon = "SelectChildren_Disabled", OnClick = function()
			local newSelection = {}
			local count = 1
			local sList = selection.List

			for i = 1,#sList do
				local node = sList[i]
				for ind = 1,#node do
					local cNode = node[ind]
					if ind == 1 then Explorer.MakeNodeVisible(cNode) end

					newSelection[count] = cNode
					count = count + 1
				end
			end

			selection:SetTable(newSelection)
			if #newSelection > 0 then
				Explorer.ViewNode(newSelection[1])
			else
				Explorer.Refresh()
			end
		end})

		context:Register("JUMP_TO_PARENT",{Name = "Jump to Parent", IconMap = Explorer.MiscIcons, Icon = "JumpToParent", OnClick = function()
			local newSelection = {}
			local count = 1
			local sList = selection.List

			for i = 1,#sList do
				local node = sList[i]
				if node.Parent then
					newSelection[count] = node.Parent
					count = count + 1
				end
			end

			selection:SetTable(newSelection)
			if #newSelection > 0 then
				Explorer.ViewNode(newSelection[1])
			else
				Explorer.Refresh()
			end
		end})

		context:Register("TELEPORT_TO",{Name = "Teleport To", IconMap = Explorer.MiscIcons, Icon = "TeleportTo", OnClick = function()
			local sList = selection.List
			local isa = game.IsA

			local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
			if not hrp then return end

			for i = 1,#sList do
				local node = sList[i]

				if isa(node.Obj,"BasePart") then
					hrp.CFrame = node.Obj.CFrame + Settings.Explorer.TeleportToOffset
					break
				elseif isa(node.Obj,"Model") then
					if node.Obj.PrimaryPart then
						hrp.CFrame = node.Obj.PrimaryPart.CFrame + Settings.Explorer.TeleportToOffset
						break
					else
						local part = node.Obj:FindFirstChildWhichIsA("BasePart",true)
						if part and nodes[part] then
							hrp.CFrame = nodes[part].Obj.CFrame + Settings.Explorer.TeleportToOffset
						end
					end
				end
			end
		end})

		context:Register("EXPAND_ALL",{Name = "Expand All", OnClick = function()
			local sList = selection.List

			local function expand(node)
				expanded[node] = true
				for i = 1,#node do
					if #node[i] > 0 then
						expand(node[i])
					end
				end
			end

			for i = 1,#sList do
				expand(sList[i])
			end

			Explorer.ForceUpdate()
		end})

		context:Register("COLLAPSE_ALL",{Name = "Collapse All", OnClick = function()
			local sList = selection.List

			local function expand(node)
				expanded[node] = nil
				for i = 1,#node do
					if #node[i] > 0 then
						expand(node[i])
					end
				end
			end

			for i = 1,#sList do
				expand(sList[i])
			end

			Explorer.ForceUpdate()
		end})

		context:Register("CLEAR_SEARCH_AND_JUMP_TO",{Name = "Clear Search and Jump to", OnClick = function()
			local newSelection = {}
			local count = 1
			local sList = selection.List

			for i = 1,#sList do
				newSelection[count] = sList[i]
				count = count + 1
			end

			selection:SetTable(newSelection)
			Explorer.ClearSearch()
			if #newSelection > 0 then
				Explorer.ViewNode(newSelection[1])
			end
		end})

		local clth = function(str)
			if str:sub(1, 28) == "game:GetService(\"Workspace\")" then str = str:gsub("game:GetService%(\"Workspace\"%)", "workspace", 1) end
			if str:sub(1, 27 + #plr.Name) == "game:GetService(\"Players\")." .. plr.Name then str = str:gsub("game:GetService%(\"Players\"%)." .. plr.Name, "game:GetService(\"Players\").LocalPlayer", 1) end
			return str
		end

		context:Register("COPY_PATH",{Name = "Copy Path", OnClick = function()
			local sList = selection.List
			if #sList == 1 then
				env.setclipboard(clth(Explorer.GetInstancePath(sList[1].Obj)))
			elseif #sList > 1 then
				local resList = {"{"}
				local count = 2
				for i = 1,#sList do
					local path = "\t"..clth(Explorer.GetInstancePath(sList[i].Obj))..","
					if #path > 0 then
						resList[count] = path
						count = count+1
					end
				end
				resList[count] = "}"
				env.setclipboard(table.concat(resList,"\n"))
			end
		end})

		context:Register("INSERT_OBJECT",{Name = "Insert Object", IconMap = Explorer.MiscIcons, Icon = "InsertObject", OnClick = function()
			local mouse = Main.Mouse
			local x,y = Explorer.LastRightClickX or mouse.X, Explorer.LastRightClickY or mouse.Y
			Explorer.InsertObjectContext:Show(x,y)
		end})

		--[[context:Register("CALL_FUNCTION",{Name = "Call Function", IconMap = Explorer.ClassIcons, Icon = 66, OnClick = function()

		end})]]

		--[[context:Register("GET_REFERENCES",{Name = "Get Lua References", IconMap = Explorer.ClassIcons, Icon = 34, OnClick = function()

		end})]]

		--[[context:Register("SAVE_INST",{Name = "Save to File", IconMap = Explorer.MiscIcons, Icon = "Save", OnClick = function()

		end})]]

		--[[context:Register("VIEW_CONNECTIONS",{Name = "View Connections", OnClick = function()

		end})]]

		--[[context:Register("VIEW_API",{Name = "View API Page", IconMap = Explorer.MiscIcons, Icon = "Reference", OnClick = function()

		end})]]

		context:Register("VIEW_OBJECT",{Name = "View Object (Right click to reset)", IconMap = Explorer.ClassIcons, Icon = 5, OnClick = function()
			local sList = selection.List
			local isa = game.IsA

			for i = 1,#sList do
				local node = sList[i]

				if isa(node.Obj,"BasePart") or isa(node.Obj,"Model") then
					workspace.CurrentCamera.CameraSubject = node.Obj
					break
				end
			end
		end, OnRightClick = function()
			workspace.CurrentCamera.CameraSubject = plr.Character
		end})

		context:Register("FIRE_TOUCHTRANSMITTER",{Name = "Fire TouchTransmitter", IconMap = Explorer.ClassIcons, Icon = 37, OnClick = function()
			local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
			if not hrp then return end
			for _, v in ipairs(selection.List) do if v.Obj and v.Obj:IsA("TouchTransmitter") then firetouchinterest(hrp, v.Obj.Parent, 0) end end
		end})

		context:Register("FIRE_CLICKDETECTOR",{Name = "Fire ClickDetector", IconMap = Explorer.ClassIcons, Icon = 41, OnClick = function()
			local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
			if not hrp then return end
			for _, v in ipairs(selection.List) do if v.Obj and v.Obj:IsA("ClickDetector") then fireclickdetector(v.Obj) end end
		end})

		context:Register("FIRE_PROXIMITYPROMPT",{Name = "Fire ProximityPrompt", IconMap = Explorer.ClassIcons, Icon = 124, OnClick = function()
			local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
			if not hrp then return end
			for _, v in ipairs(selection.List) do if v.Obj and v.Obj:IsA("ProximityPrompt") then fireproximityprompt(v.Obj) end end
		end})

		context:Register("VIEW_SCRIPT",{Name = "View Script", IconMap = Explorer.MiscIcons, Icon = "ViewScript", OnClick = function()
			local scr = selection.List[1] and selection.List[1].Obj
			if scr then ScriptViewer.ViewScript(scr) end
		end})

		context:Register("SELECT_CHARACTER",{Name = "Select Character", IconMap = Explorer.ClassIcons, Icon = 9, OnClick = function()
			local newSelection = {}
			local count = 1
			local sList = selection.List
			local isa = game.IsA

			for i = 1,#sList do
				local node = sList[i]
				if isa(node.Obj,"Player") and nodes[node.Obj.Character] then
					newSelection[count] = nodes[node.Obj.Character]
					count = count + 1
				end
			end

			selection:SetTable(newSelection)
			if #newSelection > 0 then
				Explorer.ViewNode(newSelection[1])
			else
				Explorer.Refresh()
			end
		end})

		context:Register("SELECT_LOCAL_PLAYER",{Name = "Select Local Player", IconMap = Explorer.ClassIcons, Icon = 9, OnClick = function()
			pcall(function() if nodes[plr] then selection:Set(nodes[plr]) Explorer.ViewNode(nodes[plr]) end end)
		end})

		context:Register("REFRESH_NIL",{Name = "Refresh Nil Instances", OnClick = function()
			Explorer.RefreshNilInstances()
		end})
		
		context:Register("HIDE_NIL",{Name = "Hide Nil Instances", OnClick = function()
			Explorer.HideNilInstances()
		end})

		Explorer.RightClickContext = context
	end

	Explorer.HideNilInstances = function()
		table.clear(nilMap)
		
		local disconnectCon = Instance.new("Folder").ChildAdded:Connect(function() end).Disconnect
		for i,v in next,nilCons do
			disconnectCon(v[1])
			disconnectCon(v[2])
		end
		table.clear(nilCons)

		for i = 1,#nilNode do
			coroutine.wrap(removeObject)(nilNode[i].Obj)
		end

		Explorer.Update()
		Explorer.Refresh()
	end

	Explorer.RefreshNilInstances = function()
		if not env.getnilinstances then return end

		local nilInsts = env.getnilinstances()
		local game = game
		local getDescs = game.GetDescendants
		--local newNilMap = {}
		--local newNilRoots = {}
		--local nilRoots = Explorer.NilRoots
		--local connect = game.DescendantAdded.Connect
		--local disconnect
		--if not nilRoots then nilRoots = {} Explorer.NilRoots = nilRoots end

		for i = 1,#nilInsts do
			local obj = nilInsts[i]
			if obj ~= game then
				nilMap[obj] = true
				--newNilRoots[obj] = true

				local descs = getDescs(obj)
				for j = 1,#descs do
					nilMap[descs[j]] = true
				end
			end
		end

		-- Remove unmapped nil nodes
		--[[for i = 1,#nilNode do
			local node = nilNode[i]
			if not newNilMap[node.Obj] then
				nilMap[node.Obj] = nil
				coroutine.wrap(removeObject)(node)
			end
		end]]

		--nilMap = newNilMap

		for i = 1,#nilInsts do
			local obj = nilInsts[i]
			local node = nodes[obj]
			if not node then coroutine.wrap(addObject)(obj) end
		end

		--[[
		-- Remove old root connections
		for obj in next,nilRoots do
			if not newNilRoots[obj] then
				if not disconnect then disconnect = obj[1].Disconnect end
				disconnect(obj[1])
				disconnect(obj[2])
			end
		end
		
		for obj in next,newNilRoots do
			if not nilRoots[obj] then
				nilRoots[obj] = {
					connect(obj.DescendantAdded,addObject),
					connect(obj.DescendantRemoving,removeObject)
				}
			end
		end]]

		--nilMap = newNilMap
		--Explorer.NilRoots = newNilRoots

		Explorer.Update()
		Explorer.Refresh()
	end

	Explorer.GetInstancePath = function(obj)
		local ffc = game.FindFirstChild
		local getCh = game.GetChildren
		local path = ""
		local curObj = obj
		local ts = tostring
		local match = string.match
		local gsub = string.gsub
		local tableFind = table.find
		local useGetCh = Settings.Explorer.CopyPathUseGetChildren
		local formatLuaString = Lib.FormatLuaString

		while curObj do
			if curObj == game then
				path = "game"..path
				break
			end

			local className = curObj.ClassName
			local curName = ts(curObj)
			local indexName
			if match(curName,"^[%a_][%w_]*$") then
				indexName = "."..curName
			else
				local cleanName = formatLuaString(curName)
				indexName = '["'..cleanName..'"]'
			end

			local parObj = curObj.Parent
			if parObj then
				local fc = ffc(parObj,curName)
				if useGetCh and fc and fc ~= curObj then
					local parCh = getCh(parObj)
					local fcInd = tableFind(parCh,curObj)
					indexName = ":GetChildren()["..fcInd.."]"
				elseif parObj == game and API.Classes[className] and API.Classes[className].Tags.Service then
					indexName = ':GetService("'..className..'")'
				end
			elseif parObj == nil then
				local getnil = "local getNil = function(name, class) for _, v in next, getnilinstances() do if v.ClassName == class and v.Name == name then return v end end end"
				local gotnil = "\n\ngetNil(\"%s\", \"%s\")"
				indexName = getnil .. gotnil:format(curObj.Name, className)
			end

			path = indexName..path
			curObj = parObj
		end

		return path
	end

	Explorer.InitInsertObject = function()
		local context = Lib.ContextMenu.new()
		context.SearchEnabled = true
		context.MaxHeight = 400
		context:ApplyTheme({
			ContentColor = Settings.Theme.Main2,
			OutlineColor = Settings.Theme.Outline1,
			DividerColor = Settings.Theme.Outline1,
			TextColor = Settings.Theme.Text,
			HighlightColor = Settings.Theme.ButtonHover
		})

		local classes = {}
		for i,class in next,API.Classes do
			local tags = class.Tags
			if not tags.NotCreatable and not tags.Service then
				local rmdEntry = RMD.Classes[class.Name]
				classes[#classes+1] = {class,rmdEntry and rmdEntry.ClassCategory or "Uncategorized"}
			end
		end
		table.sort(classes,function(a,b)
			if a[2] ~= b[2] then
				return a[2] < b[2]
			else
				return a[1].Name < b[1].Name
			end
		end)

		local function onClick(className)
			local sList = selection.List
			local instNew = Instance.new
			for i = 1,#sList do
				local node = sList[i]
				local obj = node.Obj
				Explorer.MakeNodeVisible(node,true)
				pcall(instNew,className,obj)
			end
		end

		local lastCategory = ""
		for i = 1,#classes do
			local class = classes[i][1]
			local rmdEntry = RMD.Classes[class.Name]
			local iconInd = rmdEntry and tonumber(rmdEntry.ExplorerImageIndex) or 0
			local category = classes[i][2]

			if lastCategory ~= category then
				context:AddDivider(category)
				lastCategory = category
			end
			context:Add({Name = class.Name, IconMap = Explorer.ClassIcons, Icon = iconInd, OnClick = onClick})
		end

		Explorer.InsertObjectContext = context
	end

	--[[
		Headers, Setups, Predicate, ObjectDefs
	]]
	Explorer.SearchFilters = { -- TODO: Use data table (so we can disable some if funcs don't exist)
		Comparison = {
			["isa"] = function(argString)
				local lower = string.lower
				local find = string.find
				local classQuery = string.split(argString)[1]
				if not classQuery then return end
				classQuery = lower(classQuery)

				local className
				for class,_ in pairs(API.Classes) do
					local cName = lower(class)
					if cName == classQuery then
						className = class
						break
					elseif find(cName,classQuery,1,true) then
						className = class
					end
				end
				if not className then return end

				return {
					Headers = {"local isa = game.IsA"},
					Predicate = "isa(obj,'"..className.."')"
				}
			end,
			["remotes"] = function(argString)
				return {
					Headers = {"local isa = game.IsA"},
					Predicate = "isa(obj,'RemoteEvent') or isa(obj,'RemoteFunction')"
				}
			end,
			["bindables"] = function(argString)
				return {
					Headers = {"local isa = game.IsA"},
					Predicate = "isa(obj,'BindableEvent') or isa(obj,'BindableFunction')"
				}
			end,
			["rad"] = function(argString)
				local num = tonumber(argString)
				if not num then return end

				if not service.Players.LocalPlayer.Character or not service.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or not service.Players.LocalPlayer.Character.HumanoidRootPart:IsA("BasePart") then return end

				return {
					Headers = {"local isa = game.IsA", "local hrp = service.Players.LocalPlayer.Character.HumanoidRootPart"},
					Setups = {"local hrpPos = hrp.Position"},
					ObjectDefs = {"local isBasePart = isa(obj,'BasePart')"},
					Predicate = "(isBasePart and (obj.Position-hrpPos).Magnitude <= "..num..")"
				}
			end,
		},
		Specific = {
			["players"] = function()
				return function() return service.Players:GetPlayers() end
			end,
			["loadedmodules"] = function()
				return env.getloadedmodules
			end,
		},
		Default = function(argString,caseSensitive)
			local cleanString = argString:gsub("\"","\\\""):gsub("\n","\\n")
			if caseSensitive then
				return {
					Headers = {"local find = string.find"},
					ObjectDefs = {"local objName = tostring(obj)"},
					Predicate = "find(objName,\"" .. cleanString .. "\",1,true)"
				}
			else
				return {
					Headers = {"local lower = string.lower","local find = string.find","local tostring = tostring"},
					ObjectDefs = {"local lowerName = lower(tostring(obj))"},
					Predicate = "find(lowerName,\"" .. cleanString:lower() .. "\",1,true)"
				}
			end
		end,
		SpecificDefault = function(n)
			return {
				Headers = {},
				ObjectDefs = {"local isSpec"..n.." = specResults["..n.."][node]"},
				Predicate = "isSpec"..n
			}
		end,
	}

	Explorer.BuildSearchFunc = function(query)
		local specFilterList,specMap = {},{}
		local finalPredicate = ""
		local rep = string.rep
		local formatQuery = query:gsub("\\.","  "):gsub('".-"',function(str) return rep(" ",#str) end)
		local headers = {}
		local objectDefs = {}
		local setups = {}
		local find = string.find
		local sub = string.sub
		local lower = string.lower
		local match = string.match
		local ops = {
			["("] = "(",
			[")"] = ")",
			["||"] = " or ",
			["&&"] = " and "
		}
		local filterCount = 0
		local compFilters = Explorer.SearchFilters.Comparison
		local specFilters = Explorer.SearchFilters.Specific
		local init = 1
		local lastOp = nil

		local function processFilter(dat)
			if dat.Headers then
				local t = dat.Headers
				for i = 1,#t do
					headers[t[i]] = true
				end
			end

			if dat.ObjectDefs then
				local t = dat.ObjectDefs
				for i = 1,#t do
					objectDefs[t[i]] = true
				end
			end

			if dat.Setups then
				local t = dat.Setups
				for i = 1,#t do
					setups[t[i]] = true
				end
			end

			finalPredicate = finalPredicate..dat.Predicate
		end

		local found = {}
		local foundData = {}
		local find = string.find
		local sub = string.sub

		local function findAll(str,pattern)
			local count = #found+1
			local init = 1
			local sz = #pattern
			local x,y,extra = find(str,pattern,init,true)
			while x do
				found[count] = x
				foundData[x] = {sz,pattern}

				count = count+1
				init = y+1
				x,y,extra = find(str,pattern,init,true)
			end
		end
		local start = tick()
		findAll(formatQuery,'&&')
		findAll(formatQuery,"||")
		findAll(formatQuery,"(")
		findAll(formatQuery,")")
		table.sort(found)
		table.insert(found,#formatQuery+1)

		local function inQuotes(str)
			local len = #str
			if sub(str,1,1) == '"' and sub(str,len,len) == '"' then
				return sub(str,2,len-1)
			end
		end

		for i = 1,#found do
			local nextInd = found[i]
			local nextData = foundData[nextInd] or {1}
			local op = ops[nextData[2]]
			local term = sub(query,init,nextInd-1)
			term = match(term,"^%s*(.-)%s*$") or "" -- Trim

			if #term > 0 then
				if sub(term,1,1) == "!" then
					term = sub(term,2)
					finalPredicate = finalPredicate.."not "
				end

				local qTerm = inQuotes(term)
				if qTerm then
					processFilter(Explorer.SearchFilters.Default(qTerm,true))
				else
					local x,y = find(term,"%S+")
					if x then
						local first = sub(term,x,y)
						local specifier = sub(first,1,1) == "/" and lower(sub(first,2))
						local compFunc = specifier and compFilters[specifier]
						local specFunc = specifier and specFilters[specifier]

						if compFunc then
							local argStr = sub(term,y+2)
							local ret = compFunc(inQuotes(argStr) or argStr)
							if ret then
								processFilter(ret)
							else
								finalPredicate = finalPredicate.."false"
							end
						elseif specFunc then
							local argStr = sub(term,y+2)
							local ret = specFunc(inQuotes(argStr) or argStr)
							if ret then
								if not specMap[term] then
									specFilterList[#specFilterList + 1] = ret
									specMap[term] = #specFilterList
								end
								processFilter(Explorer.SearchFilters.SpecificDefault(specMap[term]))
							else
								finalPredicate = finalPredicate.."false"
							end
						else
							processFilter(Explorer.SearchFilters.Default(term))
						end
					end
				end				
			end

			if op then
				finalPredicate = finalPredicate..op
				if op == "(" and (#term > 0 or lastOp == ")") then -- Handle bracket glitch
					return
				else
					lastOp = op
				end
			end
			init = nextInd+nextData[1]
		end

		local finalSetups = ""
		local finalHeaders = ""
		local finalObjectDefs = ""

		for setup,_ in next,setups do finalSetups = finalSetups..setup.."\n" end
		for header,_ in next,headers do finalHeaders = finalHeaders..header.."\n" end
		for oDef,_ in next,objectDefs do finalObjectDefs = finalObjectDefs..oDef.."\n" end

		local template = [==[
local searchResults = searchResults
local nodes = nodes
local expandTable = Explorer.SearchExpanded
local specResults = specResults
local service = service

%s
local function search(root)	
%s
	
	local expandedpar = false
	for i = 1,#root do
		local node = root[i]
		local obj = node.Obj
		
%s
		
		if %s then
			expandTable[node] = 0
			searchResults[node] = true
			if not expandedpar then
				local parnode = node.Parent
				while parnode and (not searchResults[parnode] or expandTable[parnode] == 0) do
					expandTable[parnode] = true
					searchResults[parnode] = true
					parnode = parnode.Parent
				end
				expandedpar = true
			end
		end
		
		if #node > 0 then search(node) end
	end
end
return search]==]

		local funcStr = template:format(finalHeaders,finalSetups,finalObjectDefs,finalPredicate)
		local s,func = pcall(loadstring,funcStr)
		if not s or not func then return nil,specFilterList end

		local env = setmetatable({["searchResults"] = searchResults, ["nodes"] = nodes, ["Explorer"] = Explorer, ["specResults"] = specResults,
			["service"] = service},{__index = getfenv()})
		setfenv(func,env)

		return func(),specFilterList
	end

	Explorer.DoSearch = function(query)
		table.clear(Explorer.SearchExpanded)
		table.clear(searchResults)
		expanded = (#query == 0 and Explorer.Expanded or Explorer.SearchExpanded)
		searchFunc = nil

		if #query > 0 then	
			local expandTable = Explorer.SearchExpanded
			local specFilters

			local lower = string.lower
			local find = string.find
			local tostring = tostring

			local lowerQuery = lower(query)

			local function defaultSearch(root)
				local expandedpar = false
				for i = 1,#root do
					local node = root[i]
					local obj = node.Obj

					if find(lower(tostring(obj)),lowerQuery,1,true) then
						expandTable[node] = 0
						searchResults[node] = true
						if not expandedpar then
							local parnode = node.Parent
							while parnode and (not searchResults[parnode] or expandTable[parnode] == 0) do
								expanded[parnode] = true
								searchResults[parnode] = true
								parnode = parnode.Parent
							end
							expandedpar = true
						end
					end

					if #node > 0 then defaultSearch(node) end
				end
			end

			if Main.Elevated then
				local start = tick()
				searchFunc,specFilters = Explorer.BuildSearchFunc(query)
				--print("BUILD SEARCH",tick()-start)
			else
				searchFunc = defaultSearch
			end

			if specFilters then
				table.clear(specResults)
				for i = 1,#specFilters do -- Specific search filers that returns list of matches
					local resMap = {}
					specResults[i] = resMap
					local objs = specFilters[i]()
					for c = 1,#objs do
						local node = nodes[objs[c]]
						if node then
							resMap[node] = true
						end
					end
				end
			end

			if searchFunc then
				local start = tick()
				searchFunc(nodes[game])
				searchFunc(nilNode)
				--warn(tick()-start)
			end
		end

		Explorer.ForceUpdate()
	end

	Explorer.ClearSearch = function()
		Explorer.GuiElems.SearchBar.Text = ""
		expanded = Explorer.Expanded
		searchFunc = nil
	end

	Explorer.InitSearch = function()
		local searchBox = Explorer.GuiElems.ToolBar.SearchFrame.SearchBox
		Explorer.GuiElems.SearchBar = searchBox

		Lib.ViewportTextBox.convert(searchBox)

		searchBox.FocusLost:Connect(function()
			Explorer.DoSearch(searchBox.Text)
		end)
	end

	Explorer.InitEntryTemplate = function()
		entryTemplate = create({
			{1,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0,0,0),BackgroundTransparency=1,BorderColor3=Color3.new(0,0,0),Font=3,Name="Entry",Position=UDim2.new(0,1,0,1),Size=UDim2.new(0,250,0,20),Text="",TextSize=14,}},
			{2,"Frame",{BackgroundColor3=Color3.new(0.04313725605607,0.35294118523598,0.68627452850342),BackgroundTransparency=1,BorderColor3=Color3.new(0.33725491166115,0.49019610881805,0.73725491762161),BorderSizePixel=0,Name="Indent",Parent={1},Position=UDim2.new(0,20,0,0),Size=UDim2.new(1,-20,1,0),}},
			{3,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="EntryName",Parent={2},Position=UDim2.new(0,26,0,0),Size=UDim2.new(1,-26,1,0),Text="Workspace",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
			{4,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,ClipsDescendants=true,Font=3,Name="Expand",Parent={2},Position=UDim2.new(0,-20,0,0),Size=UDim2.new(0,20,0,20),Text="",TextSize=14,}},
			{5,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5642383285",ImageRectOffset=Vector2.new(144,16),ImageRectSize=Vector2.new(16,16),Name="Icon",Parent={4},Position=UDim2.new(0,2,0,2),ScaleType=4,Size=UDim2.new(0,16,0,16),}},
			{6,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxasset://textures/ClassImages.PNG",ImageRectOffset=Vector2.new(304,0),ImageRectSize=Vector2.new(16,16),Name="Icon",Parent={2},Position=UDim2.new(0,4,0,2),ScaleType=4,Size=UDim2.new(0,16,0,16),}},
		})

		local sys = Lib.ClickSystem.new()
		sys.AllowedButtons = {1,2}
		sys.OnDown:Connect(function(item,combo,button)
			local ind = table.find(listEntries,item)
			if not ind then return end
			local node = tree[ind + Explorer.Index]
			if not node then return end

			local entry = listEntries[ind]

			if button == 1 then
				if combo == 2 then
					if node.Obj:IsA("LuaSourceContainer") then
						ScriptViewer.ViewScript(node.Obj)
					elseif #node > 0 and expanded[node] ~= 0 then
						expanded[node] = not expanded[node]
						Explorer.Update()
					end
				end

				if Properties.SelectObject(node.Obj) then
					sys.IsRenaming = false
					return
				end

				sys.IsRenaming = selection.Map[node]

				if Lib.IsShiftDown() then
					if not selection.Piviot then return end

					local fromIndex = table.find(tree,selection.Piviot)
					local toIndex = table.find(tree,node)
					if not fromIndex or not toIndex then return end
					fromIndex,toIndex = math.min(fromIndex,toIndex),math.max(fromIndex,toIndex)

					local sList = selection.List
					for i = #sList,1,-1 do
						local elem = sList[i]
						if selection.ShiftSet[elem] then
							selection.Map[elem] = nil
							table.remove(sList,i)
						end
					end
					selection.ShiftSet = {}
					for i = fromIndex,toIndex do
						local elem = tree[i]
						if not selection.Map[elem] then
							selection.ShiftSet[elem] = true
							selection.Map[elem] = true
							sList[#sList+1] = elem
						end
					end
					selection.Changed:Fire()
				elseif Lib.IsCtrlDown() then
					selection.ShiftSet = {}
					if selection.Map[node] then selection:Remove(node) else selection:Add(node) end
					selection.Piviot = node
					sys.IsRenaming = false
				elseif not selection.Map[node] then
					selection.ShiftSet = {}
					selection:Set(node)
					selection.Piviot = node
				end
			elseif button == 2 then
				if Properties.SelectObject(node.Obj) then
					return
				end

				if not Lib.IsCtrlDown() and not selection.Map[node] then
					selection.ShiftSet = {}
					selection:Set(node)
					selection.Piviot = node
					Explorer.Refresh()
				end
			end

			Explorer.Refresh()
		end)

		sys.OnRelease:Connect(function(item,combo,button)
			local ind = table.find(listEntries,item)
			if not ind then return end
			local node = tree[ind + Explorer.Index]
			if not node then return end

			if button == 1 then
				if selection.Map[node] and not Lib.IsShiftDown() and not Lib.IsCtrlDown() then
					selection.ShiftSet = {}
					selection:Set(node)
					selection.Piviot = node
					Explorer.Refresh()
				end

				local id = sys.ClickId
				Lib.FastWait(sys.ComboTime)
				if combo == 1 and id == sys.ClickId and sys.IsRenaming and selection.Map[node] then
					Explorer.SetRenamingNode(node)
				end
			elseif button == 2 then
				Explorer.ShowRightClick()
			end
		end)
		Explorer.ClickSystem = sys
	end

	Explorer.InitDelCleaner = function()
		coroutine.wrap(function()
			local fw = Lib.FastWait
			while true do
				local processed = false
				local c = 0
				for _,node in next,nodes do
					if node.HasDel then
						local delInd
						for i = 1,#node do
							if node[i].Del then
								delInd = i
								break
							end
						end
						if delInd then
							for i = delInd+1,#node do
								local cn = node[i]
								if not cn.Del then
									node[delInd] = cn
									delInd = delInd+1
								end
							end
							for i = delInd,#node do
								node[i] = nil
							end
						end
						node.HasDel = false
						processed = true
						fw()
					end
					c = c + 1
					if c > 10000 then
						c = 0
						fw()
					end
				end
				if processed and not refreshDebounce then Explorer.PerformRefresh() end
				fw(0.5)
			end
		end)()
	end

	Explorer.UpdateSelectionVisuals = function()
		local holder = Explorer.SelectionVisualsHolder
		local isa = game.IsA
		local clone = game.Clone
		if not holder then
			holder = Instance.new("ScreenGui")
			holder.Name = "ExplorerSelections"
			holder.DisplayOrder = Main.DisplayOrders.Core
			Lib.ShowGui(holder)
			Explorer.SelectionVisualsHolder = holder
			Explorer.SelectionVisualCons = {}

			local guiTemplate = create({
				{1,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Size=UDim2.new(0,100,0,100),}},
				{2,"Frame",{BackgroundColor3=Color3.new(0.04313725605607,0.35294118523598,0.68627452850342),BorderSizePixel=0,Parent={1},Position=UDim2.new(0,-1,0,-1),Size=UDim2.new(1,2,0,1),}},
				{3,"Frame",{BackgroundColor3=Color3.new(0.04313725605607,0.35294118523598,0.68627452850342),BorderSizePixel=0,Parent={1},Position=UDim2.new(0,-1,1,0),Size=UDim2.new(1,2,0,1),}},
				{4,"Frame",{BackgroundColor3=Color3.new(0.04313725605607,0.35294118523598,0.68627452850342),BorderSizePixel=0,Parent={1},Position=UDim2.new(0,-1,0,0),Size=UDim2.new(0,1,1,0),}},
				{5,"Frame",{BackgroundColor3=Color3.new(0.04313725605607,0.35294118523598,0.68627452850342),BorderSizePixel=0,Parent={1},Position=UDim2.new(1,0,0,0),Size=UDim2.new(0,1,1,0),}},
			})
			Explorer.SelectionVisualGui = guiTemplate

			local boxTemplate = Instance.new("SelectionBox")
			boxTemplate.LineThickness = 0.03
			boxTemplate.Color3 = Color3.fromRGB(0, 170, 255)
			Explorer.SelectionVisualBox = boxTemplate
		end
		holder:ClearAllChildren()

		-- Updates theme
		for i,v in pairs(Explorer.SelectionVisualGui:GetChildren()) do
			v.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
		end

		local attachCons = Explorer.SelectionVisualCons
		for i = 1,#attachCons do
			attachCons[i].Destroy()
		end
		table.clear(attachCons)

		local partEnabled = Settings.Explorer.PartSelectionBox
		local guiEnabled = Settings.Explorer.GuiSelectionBox
		if not partEnabled and not guiEnabled then return end

		local svg = Explorer.SelectionVisualGui
		local svb = Explorer.SelectionVisualBox
		local attachTo = Lib.AttachTo
		local sList = selection.List
		local count = 1
		local boxCount = 0
		local workspaceNode = nodes[workspace]
		for i = 1,#sList do
			if boxCount > 1000 then break end
			local node = sList[i]
			local obj = node.Obj

			if node ~= workspaceNode then
				if isa(obj,"GuiObject") and guiEnabled then
					local newVisual = clone(svg)
					attachCons[count] = attachTo(newVisual,{Target = obj, Resize = true})
					count = count + 1
					newVisual.Parent = holder
					boxCount = boxCount + 1
				elseif isa(obj,"PVInstance") and partEnabled then
					local newBox = clone(svb)
					newBox.Adornee = obj
					newBox.Parent = holder
					boxCount = boxCount + 1
				end
			end
		end
	end

	Explorer.Init = function()
		Explorer.ClassIcons = Lib.IconMap.newLinear("rbxasset://textures/ClassImages.PNG",16,16)
		Explorer.MiscIcons = Main.MiscIcons

		clipboard = {}

		selection = Lib.Set.new()
		selection.ShiftSet = {}
		selection.Changed:Connect(Properties.ShowExplorerProps)
		Explorer.Selection = selection

		Explorer.InitRightClick()
		Explorer.InitInsertObject()
		Explorer.SetSortingEnabled(Settings.Explorer.Sorting)
		Explorer.Expanded = setmetatable({},{__mode = "k"})
		Explorer.SearchExpanded = setmetatable({},{__mode = "k"})
		expanded = Explorer.Expanded

		nilNode.Obj.Name = "Nil Instances"
		nilNode.Locked = true

		local explorerItems = create({
			{1,"Folder",{Name="ExplorerItems",}},
			{2,"Frame",{BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BorderSizePixel=0,Name="ToolBar",Parent={1},Size=UDim2.new(1,0,0,22),}},
			{3,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.1176470592618,0.1176470592618,0.1176470592618),BorderSizePixel=0,Name="SearchFrame",Parent={2},Position=UDim2.new(0,3,0,1),Size=UDim2.new(1,-6,0,18),}},
			{4,"TextBox",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,ClearTextOnFocus=false,Font=3,Name="SearchBox",Parent={3},PlaceholderColor3=Color3.new(0.39215689897537,0.39215689897537,0.39215689897537),PlaceholderText="Search workspace",Position=UDim2.new(0,4,0,0),Size=UDim2.new(1,-24,0,18),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,TextXAlignment=0,}},
			{5,"UICorner",{CornerRadius=UDim.new(0,2),Parent={3},}},
			{6,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Reset",Parent={3},Position=UDim2.new(1,-17,0,1),Size=UDim2.new(0,16,0,16),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,}},
			{7,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5034718129",ImageColor3=Color3.new(0.39215686917305,0.39215686917305,0.39215686917305),Parent={6},Size=UDim2.new(0,16,0,16),}},
			{8,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Refresh",Parent={2},Position=UDim2.new(1,-20,0,1),Size=UDim2.new(0,18,0,18),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,Visible=false,}},
			{9,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5642310344",Parent={8},Position=UDim2.new(0,3,0,3),Size=UDim2.new(0,12,0,12),}},
			{10,"Frame",{BackgroundColor3=Color3.new(0.15686275064945,0.15686275064945,0.15686275064945),BorderSizePixel=0,Name="ScrollCorner",Parent={1},Position=UDim2.new(1,-16,1,-16),Size=UDim2.new(0,16,0,16),Visible=false,}},
			{11,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,ClipsDescendants=true,Name="List",Parent={1},Position=UDim2.new(0,0,0,23),Size=UDim2.new(1,0,1,-23),}},
		})

		toolBar = explorerItems.ToolBar
		treeFrame = explorerItems.List

		Explorer.GuiElems.ToolBar = toolBar
		Explorer.GuiElems.TreeFrame = treeFrame

		scrollV = Lib.ScrollBar.new()		
		scrollV.WheelIncrement = 3
		scrollV.Gui.Position = UDim2.new(1,-16,0,23)
		scrollV:SetScrollFrame(treeFrame)
		scrollV.Scrolled:Connect(function()
			Explorer.Index = scrollV.Index
			Explorer.Refresh()
		end)

		scrollH = Lib.ScrollBar.new(true)
		scrollH.Increment = 5
		scrollH.WheelIncrement = Explorer.EntryIndent
		scrollH.Gui.Position = UDim2.new(0,0,1,-16)
		scrollH.Scrolled:Connect(function()
			Explorer.Refresh()
		end)

		local window = Lib.Window.new()
		Explorer.Window = window
		window:SetTitle("Explorer")
		window.GuiElems.Line.Position = UDim2.new(0,0,0,22)

		Explorer.InitEntryTemplate()
		toolBar.Parent = window.GuiElems.Content
		treeFrame.Parent = window.GuiElems.Content
		explorerItems.ScrollCorner.Parent = window.GuiElems.Content
		scrollV.Gui.Parent = window.GuiElems.Content
		scrollH.Gui.Parent = window.GuiElems.Content

		-- Init stuff that requires the window
		Explorer.InitRenameBox()
		Explorer.InitSearch()
		Explorer.InitDelCleaner()
		selection.Changed:Connect(Explorer.UpdateSelectionVisuals)

		-- Window events
		window.GuiElems.Main:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			if Explorer.Active then
				Explorer.UpdateView()
				Explorer.Refresh()
			end
		end)
		window.OnActivate:Connect(function()
			Explorer.Active = true
			Explorer.UpdateView()
			Explorer.Update()
			Explorer.Refresh()
		end)
		window.OnRestore:Connect(function()
			Explorer.Active = true
			Explorer.UpdateView()
			Explorer.Update()
			Explorer.Refresh()
		end)
		window.OnDeactivate:Connect(function() Explorer.Active = false end)
		window.OnMinimize:Connect(function() Explorer.Active = false end)

		-- Settings
		autoUpdateSearch = Settings.Explorer.AutoUpdateSearch


		-- Fill in nodes
		nodes[game] = {Obj = game}
		expanded[nodes[game]] = true

		-- Nil Instances
		if env.getnilinstances then
			nodes[nilNode.Obj] = nilNode
		end

		Explorer.SetupConnections()

		local insts = getDescendants(game)
		if Main.Elevated then
			for i = 1,#insts do
				local obj = insts[i]
				local par = nodes[ffa(obj,"Instance")]
				if not par then continue end
				local newNode = {
					Obj = obj,
					Parent = par,
				}
				nodes[obj] = newNode
				par[#par+1] = newNode
			end
		else
			for i = 1,#insts do
				local obj = insts[i]
				local s,parObj = pcall(ffa,obj,"Instance")
				local par = nodes[parObj]
				if not par then continue end
				local newNode = {
					Obj = obj,
					Parent = par,
				}
				nodes[obj] = newNode
				par[#par+1] = newNode
			end
		end
	end

	return Explorer
end

return {InitDeps = initDeps, InitAfterMain = initAfterMain, Main = main}
end,
Properties = function()
--[[
	Properties App Module
	
	The main properties interface
]]

-- Common Locals
local Main,Lib,Apps,Settings -- Main Containers
local Explorer, Properties, ScriptViewer, Notebook -- Major Apps
local API,RMD,env,service,plr,create,createSimple -- Main Locals

local function initDeps(data)
	Main = data.Main
	Lib = data.Lib
	Apps = data.Apps
	Settings = data.Settings

	API = data.API
	RMD = data.RMD
	env = data.env
	service = data.service
	plr = data.plr
	create = data.create
	createSimple = data.createSimple
end

local function initAfterMain()
	Explorer = Apps.Explorer
	Properties = Apps.Properties
	ScriptViewer = Apps.ScriptViewer
	Notebook = Apps.Notebook
end

local function main()
	local Properties = {}

	local window, toolBar, propsFrame
	local scrollV, scrollH
	local categoryOrder
	local props,viewList,expanded,indexableProps,propEntries,autoUpdateObjs = {},{},{},{},{},{}
	local inputBox,inputTextBox,inputProp
	local checkboxes,propCons = {},{}
	local table,string = table,string
	local getPropChangedSignal = game.GetPropertyChangedSignal
	local getAttributeChangedSignal = game.GetAttributeChangedSignal
	local isa = game.IsA
	local getAttribute = game.GetAttribute
	local setAttribute = game.SetAttribute

	Properties.GuiElems = {}
	Properties.Index = 0
	Properties.ViewWidth = 0
	Properties.MinInputWidth = 100
	Properties.EntryIndent = 16
	Properties.EntryOffset = 4
	Properties.NameWidthCache = {}
	Properties.SubPropCache = {}
	Properties.ClassLists = {}
	Properties.SearchText = ""

	Properties.AddAttributeProp = {Category = "Attributes", Class = "", Name = "", SpecialRow = "AddAttribute", Tags = {}}
	Properties.SoundPreviewProp = {Category = "Data", ValueType = {Name = "SoundPlayer"}, Class = "Sound", Name = "Preview", Tags = {}}

	Properties.IgnoreProps = {
		["DataModel"] = {
			["PrivateServerId"] = true,
			["PrivateServerOwnerId"] = true,
			["VIPServerId"] = true,
			["VIPServerOwnerId"] = true
		}
	}

	Properties.ExpandableTypes = {
		["Vector2"] = true,
		["Vector3"] = true,
		["UDim"] = true,
		["UDim2"] = true,
		["CFrame"] = true,
		["Rect"] = true,
		["PhysicalProperties"] = true,
		["Ray"] = true,
		["NumberRange"] = true,
		["Faces"] = true,
		["Axes"] = true,
	}

	Properties.ExpandableProps = {
		["Sound.SoundId"] = true
	}

	Properties.CollapsedCategories = {
		["Surface Inputs"] = true,
		["Surface"] = true
	}

	Properties.ConflictSubProps = {
		["Vector2"] = {"X","Y"},
		["Vector3"] = {"X","Y","Z"},
		["UDim"] = {"Scale","Offset"},
		["UDim2"] = {"X","X.Scale","X.Offset","Y","Y.Scale","Y.Offset"},
		["CFrame"] = {"Position","Position.X","Position.Y","Position.Z",
			"RightVector","RightVector.X","RightVector.Y","RightVector.Z",
			"UpVector","UpVector.X","UpVector.Y","UpVector.Z",
			"LookVector","LookVector.X","LookVector.Y","LookVector.Z"},
		["Rect"] = {"Min.X","Min.Y","Max.X","Max.Y"},
		["PhysicalProperties"] = {"Density","Elasticity","ElasticityWeight","Friction","FrictionWeight"},
		["Ray"] = {"Origin","Origin.X","Origin.Y","Origin.Z","Direction","Direction.X","Direction.Y","Direction.Z"},
		["NumberRange"] = {"Min","Max"},
		["Faces"] = {"Back","Bottom","Front","Left","Right","Top"},
		["Axes"] = {"X","Y","Z"}
	}

	Properties.ConflictIgnore = {
		["BasePart"] = {
			["ResizableFaces"] = true
		}
	}

	Properties.RoundableTypes = {
		["float"] = true,
		["double"] = true,
		["Color3"] = true,
		["UDim"] = true,
		["UDim2"] = true,
		["Vector2"] = true,
		["Vector3"] = true,
		["NumberRange"] = true,
		["Rect"] = true,
		["NumberSequence"] = true,
		["ColorSequence"] = true,
		["Ray"] = true,
		["CFrame"] = true
	}

	Properties.TypeNameConvert = {
		["number"] = "double",
		["boolean"] = "bool"
	}

	Properties.ToNumberTypes = {
		["int"] = true,
		["int64"] = true,
		["float"] = true,
		["double"] = true
	}

	Properties.DefaultPropValue = {
		string = "",
		bool = false,
		double = 0,
		UDim = UDim.new(0,0),
		UDim2 = UDim2.new(0,0,0,0),
		BrickColor = BrickColor.new("Medium stone grey"),
		Color3 = Color3.new(1,1,1),
		Vector2 = Vector2.new(0,0),
		Vector3 = Vector3.new(0,0,0),
		NumberSequence = NumberSequence.new(1),
		ColorSequence = ColorSequence.new(Color3.new(1,1,1)),
		NumberRange = NumberRange.new(0),
		Rect = Rect.new(0,0,0,0)
	}

	Properties.AllowedAttributeTypes = {"string","boolean","number","UDim","UDim2","BrickColor","Color3","Vector2","Vector3","NumberSequence","ColorSequence","NumberRange","Rect"}

	Properties.StringToValue = function(prop,str)
		local typeData = prop.ValueType
		local typeName = typeData.Name

		if typeName == "string" or typeName == "Content" then
			return str
		elseif Properties.ToNumberTypes[typeName] then
			return tonumber(str)
		elseif typeName == "Vector2" then
			local vals = str:split(",")
			local x,y = tonumber(vals[1]),tonumber(vals[2])
			if x and y and #vals >= 2 then return Vector2.new(x,y) end
		elseif typeName == "Vector3" then
			local vals = str:split(",")
			local x,y,z = tonumber(vals[1]),tonumber(vals[2]),tonumber(vals[3])
			if x and y and z and #vals >= 3 then return Vector3.new(x,y,z) end
		elseif typeName == "UDim" then
			local vals = str:split(",")
			local scale,offset = tonumber(vals[1]),tonumber(vals[2])
			if scale and offset and #vals >= 2 then return UDim.new(scale,offset) end
		elseif typeName == "UDim2" then
			local vals = str:gsub("[{}]",""):split(",")
			local xScale,xOffset,yScale,yOffset = tonumber(vals[1]),tonumber(vals[2]),tonumber(vals[3]),tonumber(vals[4])
			if xScale and xOffset and yScale and yOffset and #vals >= 4 then return UDim2.new(xScale,xOffset,yScale,yOffset) end
		elseif typeName == "CFrame" then
			local vals = str:split(",")
			local s,result = pcall(CFrame.new,unpack(vals))
			if s and #vals >= 12 then return result end
		elseif typeName == "Rect" then
			local vals = str:split(",")
			local s,result = pcall(Rect.new,unpack(vals))
			if s and #vals >= 4 then return result end
		elseif typeName == "Ray" then
			local vals = str:gsub("[{}]",""):split(",")
			local s,origin = pcall(Vector3.new,unpack(vals,1,3))
			local s2,direction = pcall(Vector3.new,unpack(vals,4,6))
			if s and s2 and #vals >= 6 then return Ray.new(origin,direction) end
		elseif typeName == "NumberRange" then
			local vals = str:split(",")
			local s,result = pcall(NumberRange.new,unpack(vals))
			if s and #vals >= 1 then return result end
		elseif typeName == "Color3" then
			local vals = str:gsub("[{}]",""):split(",")
			local s,result = pcall(Color3.fromRGB,unpack(vals))
			if s and #vals >= 3 then return result end
		end

		return nil
	end

	Properties.ValueToString = function(prop,val)
		local typeData = prop.ValueType
		local typeName = typeData.Name

		if typeName == "Color3" then
			return Lib.ColorToBytes(val)
		elseif typeName == "NumberRange" then
			return val.Min..", "..val.Max
		end

		return tostring(val)
	end

	Properties.GetIndexableProps = function(obj,classData)
		if not Main.Elevated then
			if not pcall(function() return obj.ClassName end) then return nil end
		end

		local ignoreProps = Properties.IgnoreProps[classData.Name] or {}

		local result = {}
		local count = 1
		local props = classData.Properties
		for i = 1,#props do
			local prop = props[i]
			if not ignoreProps[prop.Name] then
				local s = pcall(function() return obj[prop.Name] end)
				if s then
					result[count] = prop
					count = count + 1
				end
			end
		end

		return result
	end

	Properties.FindFirstObjWhichIsA = function(class)
		local classList = Properties.ClassLists[class] or {}
		if classList and #classList > 0 then
			return classList[1]
		end

		return nil
	end

	Properties.ComputeConflicts = function(p)
		local maxConflictCheck = Settings.Properties.MaxConflictCheck
		local sList = Explorer.Selection.List
		local classLists = Properties.ClassLists
		local stringSplit = string.split
		local t_clear = table.clear
		local conflictIgnore = Properties.ConflictIgnore
		local conflictMap = {}
		local propList = p and {p} or props

		if p then
			local gName = p.Class.."."..p.Name
			autoUpdateObjs[gName] = nil
			local subProps = Properties.ConflictSubProps[p.ValueType.Name] or {}
			for i = 1,#subProps do
				autoUpdateObjs[gName.."."..subProps[i]] = nil
			end
		else
			table.clear(autoUpdateObjs)
		end

		if #sList > 0 then
			for i = 1,#propList do
				local prop = propList[i]
				local propName,propClass = prop.Name,prop.Class
				local typeData = prop.RootType or prop.ValueType
				local typeName = typeData.Name
				local attributeName = prop.AttributeName
				local gName = propClass.."."..propName

				local checked = 0
				local subProps = Properties.ConflictSubProps[typeName] or {}
				local subPropCount = #subProps
				local toCheck = subPropCount + 1
				local conflictsFound = 0
				local indexNames = {}
				local ignored = conflictIgnore[propClass] and conflictIgnore[propClass][propName]
				local truthyCheck = (typeName == "PhysicalProperties")
				local isAttribute = prop.IsAttribute
				local isMultiType = prop.MultiType

				t_clear(conflictMap)

				if not isMultiType then
					local firstVal,firstObj,firstSet
					local classList = classLists[prop.Class] or {}
					for c = 1,#classList do
						local obj = classList[c]
						if not firstSet then
							if isAttribute then
								firstVal = getAttribute(obj,attributeName)
								if firstVal ~= nil then
									firstObj = obj
									firstSet = true
								end
							else
								firstVal = obj[propName]
								firstObj = obj
								firstSet = true
							end
							if ignored then break end
						else
							local propVal,skip
							if isAttribute then
								propVal = getAttribute(obj,attributeName)
								if propVal == nil then skip = true end
							else
								propVal = obj[propName]
							end

							if not skip then
								if not conflictMap[1] then
									if truthyCheck then
										if (firstVal and true or false) ~= (propVal and true or false) then
											conflictMap[1] = true
											conflictsFound = conflictsFound + 1
										end
									elseif firstVal ~= propVal then
										conflictMap[1] = true
										conflictsFound = conflictsFound + 1
									end
								end

								if subPropCount > 0 then
									for sPropInd = 1,subPropCount do
										local indexes = indexNames[sPropInd]
										if not indexes then indexes = stringSplit(subProps[sPropInd],".") indexNames[sPropInd] = indexes end

										local firstValSub = firstVal
										local propValSub = propVal

										for j = 1,#indexes do
											if not firstValSub or not propValSub then break end -- PhysicalProperties
											local indexName = indexes[j]
											firstValSub = firstValSub[indexName]
											propValSub = propValSub[indexName]
										end

										local mapInd = sPropInd + 1
										if not conflictMap[mapInd] and firstValSub ~= propValSub then
											conflictMap[mapInd] = true
											conflictsFound = conflictsFound + 1
										end
									end
								end

								if conflictsFound == toCheck then break end
							end
						end

						checked = checked + 1
						if checked == maxConflictCheck then break end
					end

					if not conflictMap[1] then autoUpdateObjs[gName] = firstObj end
					for sPropInd = 1,subPropCount do
						if not conflictMap[sPropInd+1] then
							autoUpdateObjs[gName.."."..subProps[sPropInd]] = firstObj
						end
					end
				end
			end
		end

		if p then
			Properties.Refresh()
		end
	end

	-- Fetches the properties to be displayed based on the explorer selection
	Settings.Properties.ShowAttributes = true -- im making it true anyway since its useful by default and people complain
	Properties.ShowExplorerProps = function()
		local maxConflictCheck = Settings.Properties.MaxConflictCheck
		local sList = Explorer.Selection.List
		local foundClasses = {}
		local propCount = 1
		local elevated = Main.Elevated
		local showDeprecated,showHidden = Settings.Properties.ShowDeprecated,Settings.Properties.ShowHidden
		local Classes = API.Classes
		local classLists = {}
		local lower = string.lower
		local RMDCustomOrders = RMD.PropertyOrders
		local getAttributes = game.GetAttributes
		local maxAttrs = Settings.Properties.MaxAttributes
		local showingAttrs = Settings.Properties.ShowAttributes
		local foundAttrs = {}
		local attrCount = 0
		local typeof = typeof
		local typeNameConvert = Properties.TypeNameConvert

		table.clear(props)

		for i = 1,#sList do
			local node = sList[i]
			local obj = node.Obj
			local class = node.Class
			if not class then class = obj.ClassName node.Class = class end

			local apiClass = Classes[class]
			while apiClass do
				local APIClassName = apiClass.Name
				if not foundClasses[APIClassName] then
					local apiProps = indexableProps[APIClassName]
					if not apiProps then apiProps = Properties.GetIndexableProps(obj,apiClass) indexableProps[APIClassName] = apiProps end

					for i = 1,#apiProps do
						local prop = apiProps[i]
						local tags = prop.Tags
						if (not tags.Deprecated or showDeprecated) and (not tags.Hidden or showHidden) then
							props[propCount] = prop
							propCount = propCount + 1
						end
					end
					foundClasses[APIClassName] = true
				end

				local classList = classLists[APIClassName]
				if not classList then classList = {} classLists[APIClassName] = classList end
				classList[#classList+1] = obj

				apiClass = apiClass.Superclass
			end

			if showingAttrs and attrCount < maxAttrs then
				local attrs = getAttributes(obj)
				for name,val in pairs(attrs) do
					local typ = typeof(val)
					if not foundAttrs[name] then
						local category = (typ == "Instance" and "Class") or (typ == "EnumItem" and "Enum") or "Other"
						local valType = {Name = typeNameConvert[typ] or typ, Category = category}
						local attrProp = {IsAttribute = true, Name = "ATTR_"..name, AttributeName = name, DisplayName = name, Class = "Instance", ValueType = valType, Category = "Attributes", Tags = {}}
						props[propCount] = attrProp
						propCount = propCount + 1
						attrCount = attrCount + 1
						foundAttrs[name] = {typ,attrProp}
						if attrCount == maxAttrs then break end
					elseif foundAttrs[name][1] ~= typ then
						foundAttrs[name][2].MultiType = true
						foundAttrs[name][2].Tags.ReadOnly = true
						foundAttrs[name][2].ValueType = {Name = "string"}
					end
				end
			end
		end

		table.sort(props,function(a,b)
			if a.Category ~= b.Category then
				return (categoryOrder[a.Category] or 9999) < (categoryOrder[b.Category] or 9999)
			else
				local aOrder = (RMDCustomOrders[a.Class] and RMDCustomOrders[a.Class][a.Name]) or 9999999
				local bOrder = (RMDCustomOrders[b.Class] and RMDCustomOrders[b.Class][b.Name]) or 9999999
				if aOrder ~= bOrder then
					return aOrder < bOrder
				else
					return lower(a.Name) < lower(b.Name)
				end
			end
		end)

		-- Find conflicts and get auto-update instances
		Properties.ClassLists = classLists
		Properties.ComputeConflicts()
		--warn("CONFLICT",tick()-start)
		if #props > 0 then
			props[#props+1] = Properties.AddAttributeProp
		end

		Properties.Update()
		Properties.Refresh()
	end

	Properties.UpdateView = function()
		local maxEntries = math.ceil(propsFrame.AbsoluteSize.Y / 23)
		local maxX = propsFrame.AbsoluteSize.X
		local totalWidth = Properties.ViewWidth + Properties.MinInputWidth

		scrollV.VisibleSpace = maxEntries
		scrollV.TotalSpace = #viewList + 1
		scrollH.VisibleSpace = maxX
		scrollH.TotalSpace = totalWidth

		scrollV.Gui.Visible = #viewList + 1 > maxEntries
		scrollH.Gui.Visible = Settings.Properties.ScaleType == 0 and totalWidth > maxX

		local oldSize = propsFrame.Size
		propsFrame.Size = UDim2.new(1,(scrollV.Gui.Visible and -16 or 0),1,(scrollH.Gui.Visible and -39 or -23))
		if oldSize ~= propsFrame.Size then
			Properties.UpdateView()
		else
			scrollV:Update()
			scrollH:Update()

			if scrollV.Gui.Visible and scrollH.Gui.Visible then
				scrollV.Gui.Size = UDim2.new(0,16,1,-39)
				scrollH.Gui.Size = UDim2.new(1,-16,0,16)
				Properties.Window.GuiElems.Content.ScrollCorner.Visible = true
			else
				scrollV.Gui.Size = UDim2.new(0,16,1,-23)
				scrollH.Gui.Size = UDim2.new(1,0,0,16)
				Properties.Window.GuiElems.Content.ScrollCorner.Visible = false
			end

			Properties.Index = scrollV.Index
		end
	end

	Properties.MakeSubProp = function(prop,subName,valueType,displayName)
		local subProp = {}
		for i,v in pairs(prop) do
			subProp[i] = v
		end
		subProp.RootType = subProp.RootType or subProp.ValueType
		subProp.ValueType = valueType
		subProp.SubName = subProp.SubName and (subProp.SubName..subName) or subName
		subProp.DisplayName = displayName

		return subProp
	end

	Properties.GetExpandedProps = function(prop) -- TODO: Optimize using table
		local result = {}
		local typeData = prop.ValueType
		local typeName = typeData.Name
		local makeSubProp = Properties.MakeSubProp

		if typeName == "Vector2" then
			result[1] = makeSubProp(prop,".X",{Name = "float"})
			result[2] = makeSubProp(prop,".Y",{Name = "float"})
		elseif typeName == "Vector3" then
			result[1] = makeSubProp(prop,".X",{Name = "float"})
			result[2] = makeSubProp(prop,".Y",{Name = "float"})
			result[3] = makeSubProp(prop,".Z",{Name = "float"})
		elseif typeName == "CFrame" then
			result[1] = makeSubProp(prop,".Position",{Name = "Vector3"})
			result[2] = makeSubProp(prop,".RightVector",{Name = "Vector3"})
			result[3] = makeSubProp(prop,".UpVector",{Name = "Vector3"})
			result[4] = makeSubProp(prop,".LookVector",{Name = "Vector3"})
		elseif typeName == "UDim" then
			result[1] = makeSubProp(prop,".Scale",{Name = "float"})
			result[2] = makeSubProp(prop,".Offset",{Name = "int"})
		elseif typeName == "UDim2" then
			result[1] = makeSubProp(prop,".X",{Name = "UDim"})
			result[2] = makeSubProp(prop,".Y",{Name = "UDim"})
		elseif typeName == "Rect" then
			result[1] = makeSubProp(prop,".Min.X",{Name = "float"},"X0")
			result[2] = makeSubProp(prop,".Min.Y",{Name = "float"},"Y0")
			result[3] = makeSubProp(prop,".Max.X",{Name = "float"},"X1")
			result[4] = makeSubProp(prop,".Max.Y",{Name = "float"},"Y1")
		elseif typeName == "PhysicalProperties" then
			result[1] = makeSubProp(prop,".Density",{Name = "float"})
			result[2] = makeSubProp(prop,".Elasticity",{Name = "float"})
			result[3] = makeSubProp(prop,".ElasticityWeight",{Name = "float"})
			result[4] = makeSubProp(prop,".Friction",{Name = "float"})
			result[5] = makeSubProp(prop,".FrictionWeight",{Name = "float"})
		elseif typeName == "Ray" then
			result[1] = makeSubProp(prop,".Origin",{Name = "Vector3"})
			result[2] = makeSubProp(prop,".Direction",{Name = "Vector3"})
		elseif typeName == "NumberRange" then
			result[1] = makeSubProp(prop,".Min",{Name = "float"})
			result[2] = makeSubProp(prop,".Max",{Name = "float"})
		elseif typeName == "Faces" then
			result[1] = makeSubProp(prop,".Back",{Name = "bool"})
			result[2] = makeSubProp(prop,".Bottom",{Name = "bool"})
			result[3] = makeSubProp(prop,".Front",{Name = "bool"})
			result[4] = makeSubProp(prop,".Left",{Name = "bool"})
			result[5] = makeSubProp(prop,".Right",{Name = "bool"})
			result[6] = makeSubProp(prop,".Top",{Name = "bool"})
		elseif typeName == "Axes" then
			result[1] = makeSubProp(prop,".X",{Name = "bool"})
			result[2] = makeSubProp(prop,".Y",{Name = "bool"})
			result[3] = makeSubProp(prop,".Z",{Name = "bool"})
		end

		if prop.Name == "SoundId" and prop.Class == "Sound" then
			result[1] = Properties.SoundPreviewProp
		end

		return result
	end

	Properties.Update = function()
		table.clear(viewList)

		local nameWidthCache = Properties.NameWidthCache
		local lastCategory
		local count = 1
		local maxWidth,maxDepth = 0,1

		local textServ = service.TextService
		local getTextSize = textServ.GetTextSize
		local font = Enum.Font.SourceSans
		local size = Vector2.new(math.huge,20)
		local stringSplit = string.split
		local entryIndent = Properties.EntryIndent
		local isFirstScaleType = Settings.Properties.ScaleType == 0
		local find,lower = string.find,string.lower
		local searchText = (#Properties.SearchText > 0 and lower(Properties.SearchText))

		local function recur(props,depth)
			for i = 1,#props do
				local prop = props[i]
				local propName = prop.Name
				local subName = prop.SubName
				local category = prop.Category

				local visible
				if searchText and depth == 1 then
					if find(lower(propName),searchText,1,true) then
						visible = true
					end
				else
					visible = true
				end

				if visible and lastCategory ~= category then
					viewList[count] = {CategoryName = category}
					count = count + 1
					lastCategory = category
				end

				if (expanded["CAT_"..category] and visible) or prop.SpecialRow then
					if depth > 1 then prop.Depth = depth if depth > maxDepth then maxDepth = depth end end

					if isFirstScaleType then
						local nameArr = subName and stringSplit(subName,".")
						local displayName = prop.DisplayName or (nameArr and nameArr[#nameArr]) or propName

						local nameWidth = nameWidthCache[displayName]
						if not nameWidth then nameWidth = getTextSize(textServ,displayName,14,font,size).X nameWidthCache[displayName] = nameWidth end

						local totalWidth = nameWidth + entryIndent*depth
						if totalWidth > maxWidth then
							maxWidth = totalWidth
						end
					end

					viewList[count] = prop
					count = count + 1

					local fullName = prop.Class.."."..prop.Name..(prop.SubName or "")
					if expanded[fullName] then
						local nextDepth = depth+1
						local expandedProps = Properties.GetExpandedProps(prop)
						if #expandedProps > 0 then
							recur(expandedProps,nextDepth)
						end
					end
				end
			end
		end
		recur(props,1)

		inputProp = nil
		Properties.ViewWidth = maxWidth + 9 + Properties.EntryOffset
		Properties.UpdateView()
	end

	Properties.NewPropEntry = function(index)
		local newEntry = Properties.EntryTemplate:Clone()
		local nameFrame = newEntry.NameFrame
		local valueFrame = newEntry.ValueFrame
		local newCheckbox = Lib.Checkbox.new(1)
		newCheckbox.Gui.Position = UDim2.new(0,3,0,3)
		newCheckbox.Gui.Parent = valueFrame
		newCheckbox.OnInput:Connect(function()
			local prop = viewList[index + Properties.Index]
			if not prop then return end

			if prop.ValueType.Name == "PhysicalProperties" then
				Properties.SetProp(prop,newCheckbox.Toggled and true or nil)
			else
				Properties.SetProp(prop,newCheckbox.Toggled)
			end
		end)
		checkboxes[index] = newCheckbox

		local iconFrame = Main.MiscIcons:GetLabel()
		iconFrame.Position = UDim2.new(0,2,0,3)
		iconFrame.Parent = newEntry.ValueFrame.RightButton

		newEntry.Position = UDim2.new(0,0,0,23*(index-1))

		nameFrame.Expand.InputBegan:Connect(function(input)
			local prop = viewList[index + Properties.Index]
			if not prop or input.UserInputType ~= Enum.UserInputType.MouseMovement then return end

			local fullName = (prop.CategoryName and "CAT_"..prop.CategoryName) or prop.Class.."."..prop.Name..(prop.SubName or "")

			Main.MiscIcons:DisplayByKey(newEntry.NameFrame.Expand.Icon, expanded[fullName] and "Collapse_Over" or "Expand_Over")
		end)

		nameFrame.Expand.InputEnded:Connect(function(input)
			local prop = viewList[index + Properties.Index]
			if not prop or input.UserInputType ~= Enum.UserInputType.MouseMovement then return end

			local fullName = (prop.CategoryName and "CAT_"..prop.CategoryName) or prop.Class.."."..prop.Name..(prop.SubName or "")

			Main.MiscIcons:DisplayByKey(newEntry.NameFrame.Expand.Icon, expanded[fullName] and "Collapse" or "Expand")
		end)

		nameFrame.Expand.MouseButton1Down:Connect(function()
			local prop = viewList[index + Properties.Index]
			if not prop then return end

			local fullName = (prop.CategoryName and "CAT_"..prop.CategoryName) or prop.Class.."."..prop.Name..(prop.SubName or "")
			if not prop.CategoryName and not Properties.ExpandableTypes[prop.ValueType and prop.ValueType.Name] and not Properties.ExpandableProps[fullName] then return end

			expanded[fullName] = not expanded[fullName]
			Properties.Update()
			Properties.Refresh()
		end)

		nameFrame.PropName.InputBegan:Connect(function(input)
			local prop = viewList[index + Properties.Index]
			if not prop then return end
			if input.UserInputType == Enum.UserInputType.MouseMovement and not nameFrame.PropName.TextFits then
				local fullNameFrame = Properties.FullNameFrame	
				local nameArr = string.split(prop.Class.."."..prop.Name..(prop.SubName or ""),".")
				local dispName = prop.DisplayName or nameArr[#nameArr]
				local sizeX = service.TextService:GetTextSize(dispName,14,Enum.Font.SourceSans,Vector2.new(math.huge,20)).X

				fullNameFrame.TextLabel.Text = dispName
				--fullNameFrame.Position = UDim2.new(0,Properties.EntryIndent*(prop.Depth or 1) + Properties.EntryOffset,0,23*(index-1))
				fullNameFrame.Size = UDim2.new(0,sizeX + 4,0,22)
				fullNameFrame.Visible = true
				Properties.FullNameFrameIndex = index
				Properties.FullNameFrameAttach.SetData(fullNameFrame, {Target = nameFrame})
				Properties.FullNameFrameAttach.Enable()
			end
		end)

		nameFrame.PropName.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement and Properties.FullNameFrameIndex == index then
				Properties.FullNameFrame.Visible = false
				Properties.FullNameFrameAttach.Disable()
			end
		end)

		valueFrame.ValueBox.MouseButton1Down:Connect(function()
			local prop = viewList[index + Properties.Index]
			if not prop then return end

			Properties.SetInputProp(prop,index)
		end)

		valueFrame.ColorButton.MouseButton1Down:Connect(function()
			local prop = viewList[index + Properties.Index]
			if not prop then return end

			Properties.SetInputProp(prop,index,"color")
		end)

		valueFrame.RightButton.MouseButton1Click:Connect(function()
			local prop = viewList[index + Properties.Index]
			if not prop then return end

			local fullName = prop.Class.."."..prop.Name..(prop.SubName or "")
			local inputFullName = inputProp and (inputProp.Class.."."..inputProp.Name..(inputProp.SubName or ""))

			if fullName == inputFullName and inputProp.ValueType.Category == "Class" then
				inputProp = nil
				Properties.SetProp(prop,nil)
			else
				Properties.SetInputProp(prop,index,"right")
			end
		end)

		nameFrame.ToggleAttributes.MouseButton1Click:Connect(function()
			Settings.Properties.ShowAttributes = not Settings.Properties.ShowAttributes
			Properties.ShowExplorerProps()
		end)

		newEntry.RowButton.MouseButton1Click:Connect(function()
			Properties.DisplayAddAttributeWindow()
		end)

		newEntry.EditAttributeButton.MouseButton1Down:Connect(function()
			local prop = viewList[index + Properties.Index]
			if not prop then return end

			Properties.DisplayAttributeContext(prop)
		end)

		valueFrame.SoundPreview.ControlButton.MouseButton1Click:Connect(function()
			if Properties.PreviewSound and Properties.PreviewSound.Playing then
				Properties.SetSoundPreview(false)
			else
				local soundObj = Properties.FindFirstObjWhichIsA("Sound")
				if soundObj then Properties.SetSoundPreview(soundObj) end
			end
		end)

		valueFrame.SoundPreview.InputBegan:Connect(function(input)
			if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end

			local releaseEvent,mouseEvent
			releaseEvent = service.UserInputService.InputEnded:Connect(function(input)
				if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
				releaseEvent:Disconnect()
				mouseEvent:Disconnect()
			end)

			local timeLine = newEntry.ValueFrame.SoundPreview.TimeLine
			local soundObj = Properties.FindFirstObjWhichIsA("Sound")
			if soundObj then Properties.SetSoundPreview(soundObj,true) end

			local function update(input)
				local sound = Properties.PreviewSound
				if not sound or sound.TimeLength == 0 then return end

				local mouseX = input.Position.X
				local timeLineSize = timeLine.AbsoluteSize
				local relaX = mouseX - timeLine.AbsolutePosition.X

				if timeLineSize.X <= 1 then return end
				if relaX < 0 then relaX = 0 elseif relaX >= timeLineSize.X then relaX = timeLineSize.X-1 end

				local perc = (relaX/(timeLineSize.X-1))
				sound.TimePosition = perc*sound.TimeLength
				timeLine.Slider.Position = UDim2.new(perc,-4,0,-8)
			end
			update(input)

			mouseEvent = service.UserInputService.InputChanged:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement then
					update(input)
				end
			end)
		end)

		newEntry.Parent = propsFrame

		return {
			Gui = newEntry,
			GuiElems = {
				NameFrame = nameFrame,
				ValueFrame = valueFrame,
				PropName = nameFrame.PropName,
				ValueBox = valueFrame.ValueBox,
				Expand = nameFrame.Expand,
				ColorButton = valueFrame.ColorButton,
				ColorPreview = valueFrame.ColorButton.ColorPreview,
				Gradient = valueFrame.ColorButton.ColorPreview.UIGradient,
				EnumArrow = valueFrame.EnumArrow,
				Checkbox = valueFrame.Checkbox,
				RightButton = valueFrame.RightButton,
				RightButtonIcon = iconFrame,
				RowButton = newEntry.RowButton,
				EditAttributeButton = newEntry.EditAttributeButton,
				ToggleAttributes = nameFrame.ToggleAttributes,
				SoundPreview = valueFrame.SoundPreview,
				SoundPreviewSlider = valueFrame.SoundPreview.TimeLine.Slider
			}
		}
	end

	Properties.GetSoundPreviewEntry = function()
		for i = 1,#viewList do
			if viewList[i] == Properties.SoundPreviewProp then
				return propEntries[i - Properties.Index]
			end
		end
	end

	Properties.SetSoundPreview = function(soundObj,noplay)
		local sound = Properties.PreviewSound
		if not sound then
			sound = Instance.new("Sound")
			sound.Name = "Preview"
			sound.Paused:Connect(function()
				local entry = Properties.GetSoundPreviewEntry()
				if entry then Main.MiscIcons:DisplayByKey(entry.GuiElems.SoundPreview.ControlButton.Icon, "Play") end
			end)
			sound.Resumed:Connect(function() Properties.Refresh() end)
			sound.Ended:Connect(function()
				local entry = Properties.GetSoundPreviewEntry()
				if entry then entry.GuiElems.SoundPreviewSlider.Position = UDim2.new(0,-4,0,-8) end
				Properties.Refresh()
			end)
			sound.Parent = window.Gui
			Properties.PreviewSound = sound
		end

		if not soundObj then
			sound:Pause()
		else
			local newId = sound.SoundId ~= soundObj.SoundId
			sound.SoundId = soundObj.SoundId
			sound.PlaybackSpeed = soundObj.PlaybackSpeed
			sound.Volume = soundObj.Volume
			if newId then sound.TimePosition = 0 end
			if not noplay then sound:Resume() end

			coroutine.wrap(function()
				local previewTime = tick()
				Properties.SoundPreviewTime = previewTime
				while previewTime == Properties.SoundPreviewTime and sound.Playing do
					local entry = Properties.GetSoundPreviewEntry()
					if entry then
						local tl = sound.TimeLength
						local perc = sound.TimePosition/(tl == 0 and 1 or tl)
						entry.GuiElems.SoundPreviewSlider.Position = UDim2.new(perc,-4,0,-8)
					end
					Lib.FastWait()
				end
			end)()
			Properties.Refresh()
		end
	end

	Properties.DisplayAttributeContext = function(prop)
		local context = Properties.AttributeContext
		if not context then
			context = Lib.ContextMenu.new()
			context.Iconless = true
			context.Width = 80
		end
		context:Clear()

		context:Add({Name = "Edit", OnClick = function()
			Properties.DisplayAddAttributeWindow(prop)
		end})
		context:Add({Name = "Delete", OnClick = function()
			Properties.SetProp(prop,nil,true)
			Properties.ShowExplorerProps()
		end})

		context:Show()
	end

	Properties.DisplayAddAttributeWindow = function(editAttr)
		local win = Properties.AddAttributeWindow
		if not win then
			win = Lib.Window.new()
			win.Alignable = false
			win.Resizable = false
			win:SetTitle("Add Attribute")
			win:SetSize(200,130)

			local saveButton = Lib.Button.new()
			local nameLabel = Lib.Label.new()
			nameLabel.Text = "Name"
			nameLabel.Position = UDim2.new(0,30,0,10)
			nameLabel.Size = UDim2.new(0,40,0,20)
			win:Add(nameLabel)

			local nameBox = Lib.ViewportTextBox.new()
			nameBox.Position = UDim2.new(0,75,0,10)
			nameBox.Size = UDim2.new(0,120,0,20)
			win:Add(nameBox,"NameBox")
			nameBox.TextBox:GetPropertyChangedSignal("Text"):Connect(function()
				saveButton:SetDisabled(#nameBox:GetText() == 0)
			end)

			local typeLabel = Lib.Label.new()
			typeLabel.Text = "Type"
			typeLabel.Position = UDim2.new(0,30,0,40)
			typeLabel.Size = UDim2.new(0,40,0,20)
			win:Add(typeLabel)

			local typeChooser = Lib.DropDown.new()
			typeChooser.CanBeEmpty = false
			typeChooser.Position = UDim2.new(0,75,0,40)
			typeChooser.Size = UDim2.new(0,120,0,20)
			typeChooser:SetOptions(Properties.AllowedAttributeTypes)
			win:Add(typeChooser,"TypeChooser")

			local errorLabel = Lib.Label.new()
			errorLabel.Text = ""
			errorLabel.Position = UDim2.new(0,5,1,-45)
			errorLabel.Size = UDim2.new(1,-10,0,20)
			errorLabel.TextColor3 = Settings.Theme.Important
			win.ErrorLabel = errorLabel
			win:Add(errorLabel,"Error")

			local cancelButton = Lib.Button.new()
			cancelButton.Text = "Cancel"
			cancelButton.Position = UDim2.new(1,-97,1,-25)
			cancelButton.Size = UDim2.new(0,92,0,20)
			cancelButton.OnClick:Connect(function()
				win:Close()
			end)
			win:Add(cancelButton)

			saveButton.Text = "Save"
			saveButton.Position = UDim2.new(0,5,1,-25)
			saveButton.Size = UDim2.new(0,92,0,20)
			saveButton.OnClick:Connect(function()
				local name = nameBox:GetText()
				if #name > 100 then
					errorLabel.Text = "Error: Name over 100 chars"
					return
				elseif name:sub(1,3) == "RBX" then
					errorLabel.Text = "Error: Name begins with 'RBX'"
					return
				end

				local typ = typeChooser.Selected
				local valType = {Name = Properties.TypeNameConvert[typ] or typ, Category = "DataType"}
				local attrProp = {IsAttribute = true, Name = "ATTR_"..name, AttributeName = name, DisplayName = name, Class = "Instance", ValueType = valType, Category = "Attributes", Tags = {}}

				Settings.Properties.ShowAttributes = true
				Properties.SetProp(attrProp,Properties.DefaultPropValue[valType.Name],true,Properties.EditingAttribute)
				Properties.ShowExplorerProps()
				win:Close()
			end)
			win:Add(saveButton,"SaveButton")

			Properties.AddAttributeWindow = win
		end

		Properties.EditingAttribute = editAttr
		win:SetTitle(editAttr and "Edit Attribute "..editAttr.AttributeName or "Add Attribute")
		win.Elements.Error.Text = ""
		win.Elements.NameBox:SetText("")
		win.Elements.SaveButton:SetDisabled(true)
		win.Elements.TypeChooser:SetSelected(1)
		win:Show()
	end

	Properties.IsTextEditable = function(prop)
		local typeData = prop.ValueType
		local typeName = typeData.Name

		return typeName ~= "bool" and typeData.Category ~= "Enum" and typeData.Category ~= "Class" and typeName ~= "BrickColor"
	end

	Properties.DisplayEnumDropdown = function(entryIndex)
		local context = Properties.EnumContext
		if not context then
			context = Lib.ContextMenu.new()
			context.Iconless = true
			context.MaxHeight = 200
			context.ReverseYOffset = 22
			Properties.EnumDropdown = context
		end

		if not inputProp or inputProp.ValueType.Category ~= "Enum" then return end
		local prop = inputProp

		local entry = propEntries[entryIndex]
		local valueFrame = entry.GuiElems.ValueFrame

		local enum = Enum[prop.ValueType.Name]
		if not enum then return end

		local sorted = {}
		for name,enum in next,enum:GetEnumItems() do
			sorted[#sorted+1] = enum
		end
		table.sort(sorted,function(a,b) return a.Name < b.Name end)

		context:Clear()

		local function onClick(name)
			if prop ~= inputProp then return end

			local enumItem = enum[name]
			inputProp = nil
			Properties.SetProp(prop,enumItem)
		end

		for i = 1,#sorted do
			local enumItem = sorted[i]
			context:Add({Name = enumItem.Name, OnClick = onClick})
		end

		context.Width = valueFrame.AbsoluteSize.X
		context:Show(valueFrame.AbsolutePosition.X, valueFrame.AbsolutePosition.Y + 22)
	end

	Properties.DisplayBrickColorEditor = function(prop,entryIndex,col)
		local editor = Properties.BrickColorEditor
		if not editor then
			editor = Lib.BrickColorPicker.new()
			editor.Gui.DisplayOrder = Main.DisplayOrders.Menu
			editor.ReverseYOffset = 22

			editor.OnSelect:Connect(function(col)
				if not editor.CurrentProp or editor.CurrentProp.ValueType.Name ~= "BrickColor" then return end

				if editor.CurrentProp == inputProp then inputProp = nil end
				Properties.SetProp(editor.CurrentProp,BrickColor.new(col))
			end)

			editor.OnMoreColors:Connect(function() -- TODO: Special Case BasePart.BrickColor to BasePart.Color
				editor:Close()
				local colProp
				for i,v in pairs(API.Classes.BasePart.Properties) do
					if v.Name == "Color" then
						colProp = v
						break
					end
				end
				Properties.DisplayColorEditor(colProp,editor.SavedColor.Color)
			end)

			Properties.BrickColorEditor = editor
		end

		local entry = propEntries[entryIndex]
		local valueFrame = entry.GuiElems.ValueFrame

		editor.CurrentProp = prop
		editor.SavedColor = col
		if prop and prop.Class == "BasePart" and prop.Name == "BrickColor" then
			editor:SetMoreColorsVisible(true)
		else
			editor:SetMoreColorsVisible(false)
		end
		editor:Show(valueFrame.AbsolutePosition.X, valueFrame.AbsolutePosition.Y + 22)
	end

	Properties.DisplayColorEditor = function(prop,col)
		local editor = Properties.ColorEditor
		if not editor then
			editor = Lib.ColorPicker.new()

			editor.OnSelect:Connect(function(col)
				if not editor.CurrentProp then return end
				local typeName = editor.CurrentProp.ValueType.Name
				if typeName ~= "Color3" and typeName ~= "BrickColor" then return end

				local colVal = (typeName == "Color3" and col or BrickColor.new(col))

				if editor.CurrentProp == inputProp then inputProp = nil end
				Properties.SetProp(editor.CurrentProp,colVal)
			end)

			Properties.ColorEditor = editor
		end

		editor.CurrentProp = prop
		if col then
			editor:SetColor(col)
		else
			local firstVal = Properties.GetFirstPropVal(prop)
			if firstVal then editor:SetColor(firstVal) end
		end
		editor:Show()
	end

	Properties.DisplayNumberSequenceEditor = function(prop,seq)
		local editor = Properties.NumberSequenceEditor
		if not editor then
			editor = Lib.NumberSequenceEditor.new()

			editor.OnSelect:Connect(function(val)
				if not editor.CurrentProp or editor.CurrentProp.ValueType.Name ~= "NumberSequence" then return end

				if editor.CurrentProp == inputProp then inputProp = nil end
				Properties.SetProp(editor.CurrentProp,val)
			end)

			Properties.NumberSequenceEditor = editor
		end

		editor.CurrentProp = prop
		if seq then
			editor:SetSequence(seq)
		else
			local firstVal = Properties.GetFirstPropVal(prop)
			if firstVal then editor:SetSequence(firstVal) end
		end
		editor:Show()
	end

	Properties.DisplayColorSequenceEditor = function(prop,seq)
		local editor = Properties.ColorSequenceEditor
		if not editor then
			editor = Lib.ColorSequenceEditor.new()

			editor.OnSelect:Connect(function(val)
				if not editor.CurrentProp or editor.CurrentProp.ValueType.Name ~= "ColorSequence" then return end

				if editor.CurrentProp == inputProp then inputProp = nil end
				Properties.SetProp(editor.CurrentProp,val)
			end)

			Properties.ColorSequenceEditor = editor
		end

		editor.CurrentProp = prop
		if seq then
			editor:SetSequence(seq)
		else
			local firstVal = Properties.GetFirstPropVal(prop)
			if firstVal then editor:SetSequence(firstVal) end
		end
		editor:Show()
	end

	Properties.GetFirstPropVal = function(prop)
		local first = Properties.FindFirstObjWhichIsA(prop.Class)
		if first then
			return Properties.GetPropVal(prop,first)
		end
	end

	Properties.GetPropVal = function(prop,obj)
		if prop.MultiType then return "<Multiple Types>" end
		if not obj then return end

		local propVal
		if prop.IsAttribute then
			propVal = getAttribute(obj,prop.AttributeName)
			if propVal == nil then return nil end

			local typ = typeof(propVal)
			local currentType = Properties.TypeNameConvert[typ] or typ
			if prop.RootType then
				if prop.RootType.Name ~= currentType then
					return nil
				end
			elseif prop.ValueType.Name ~= currentType then
				return nil
			end
		else
			propVal = obj[prop.Name]
		end
		if prop.SubName then
			local indexes = string.split(prop.SubName,".")
			for i = 1,#indexes do
				local indexName = indexes[i]
				if #indexName > 0 and propVal then
					propVal = propVal[indexName]
				end
			end
		end

		return propVal
	end

	Properties.SelectObject = function(obj)
		if inputProp and inputProp.ValueType.Category == "Class" then
			local prop = inputProp
			inputProp = nil

			if isa(obj,prop.ValueType.Name) then
				Properties.SetProp(prop,obj)
			else
				Properties.Refresh()
			end

			return true
		end

		return false
	end

	Properties.DisplayProp = function(prop,entryIndex)
		local propName = prop.Name
		local typeData = prop.ValueType
		local typeName = typeData.Name
		local tags = prop.Tags
		local gName = prop.Class.."."..prop.Name..(prop.SubName or "")
		local propObj = autoUpdateObjs[gName]
		local entryData = propEntries[entryIndex]
		local UDim2 = UDim2

		local guiElems = entryData.GuiElems
		local valueFrame = guiElems.ValueFrame
		local valueBox = guiElems.ValueBox
		local colorButton = guiElems.ColorButton
		local colorPreview = guiElems.ColorPreview
		local gradient = guiElems.Gradient
		local enumArrow = guiElems.EnumArrow
		local checkbox = guiElems.Checkbox
		local rightButton = guiElems.RightButton
		local soundPreview = guiElems.SoundPreview

		local propVal = Properties.GetPropVal(prop,propObj)
		local inputFullName = inputProp and (inputProp.Class.."."..inputProp.Name..(inputProp.SubName or ""))

		local offset = 4
		local endOffset = 6

		-- Offsetting the ValueBox for ValueType specific buttons
		if (typeName == "Color3" or typeName == "BrickColor" or typeName == "ColorSequence") then
			colorButton.Visible = true
			enumArrow.Visible = false
			if propVal then
				gradient.Color = (typeName == "Color3" and ColorSequence.new(propVal)) or (typeName == "BrickColor" and ColorSequence.new(propVal.Color)) or propVal
			else
				gradient.Color = ColorSequence.new(Color3.new(1,1,1))
			end
			colorPreview.BorderColor3 = (typeName == "ColorSequence" and Color3.new(1,1,1) or Color3.new(0,0,0))
			offset = 22
			endOffset = 24 + (typeName == "ColorSequence" and 20 or 0)
		elseif typeData.Category == "Enum" then
			colorButton.Visible = false
			enumArrow.Visible = not prop.Tags.ReadOnly
			endOffset = 22
		elseif (gName == inputFullName and typeData.Category == "Class") or typeName == "NumberSequence" then
			colorButton.Visible = false
			enumArrow.Visible = false
			endOffset = 26
		else
			colorButton.Visible = false
			enumArrow.Visible = false
		end

		valueBox.Position = UDim2.new(0,offset,0,0)
		valueBox.Size = UDim2.new(1,-endOffset,1,0)

		-- Right button
		if inputFullName == gName and typeData.Category == "Class" then
			Main.MiscIcons:DisplayByKey(guiElems.RightButtonIcon, "Delete")
			guiElems.RightButtonIcon.Visible = true
			rightButton.Text = ""
			rightButton.Visible = true
		elseif typeName == "NumberSequence" or typeName == "ColorSequence" then
			guiElems.RightButtonIcon.Visible = false
			rightButton.Text = "..."
			rightButton.Visible = true
		else
			rightButton.Visible = false
		end

		-- Displays the correct ValueBox for the ValueType, and sets it to the prop value
		if typeName == "bool" or typeName == "PhysicalProperties" then
			valueBox.Visible = false
			checkbox.Visible = true
			soundPreview.Visible = false
			checkboxes[entryIndex].Disabled = tags.ReadOnly
			if typeName == "PhysicalProperties" and autoUpdateObjs[gName] then
				checkboxes[entryIndex]:SetState(propVal and true or false)
			else
				checkboxes[entryIndex]:SetState(propVal)
			end
		elseif typeName == "SoundPlayer" then
			valueBox.Visible = false
			checkbox.Visible = false
			soundPreview.Visible = true
			local playing = Properties.PreviewSound and Properties.PreviewSound.Playing
			Main.MiscIcons:DisplayByKey(soundPreview.ControlButton.Icon, playing and "Pause" or "Play")
		else
			valueBox.Visible = true
			checkbox.Visible = false
			soundPreview.Visible = false

			if propVal ~= nil then
				if typeName == "Color3" then
					valueBox.Text = "["..Lib.ColorToBytes(propVal).."]"
				elseif typeData.Category == "Enum" then
					valueBox.Text = propVal.Name
				elseif Properties.RoundableTypes[typeName] and Settings.Properties.NumberRounding then
					local rawStr = Properties.ValueToString(prop,propVal)
					valueBox.Text = rawStr:gsub("-?%d+%.%d+",function(num)
						return tostring(tonumber(("%."..Settings.Properties.NumberRounding.."f"):format(num)))
					end)
				else
					valueBox.Text = Properties.ValueToString(prop,propVal)
				end
			else
				valueBox.Text = ""
			end

			valueBox.TextColor3 = tags.ReadOnly and Settings.Theme.PlaceholderText or Settings.Theme.Text
		end
	end

	Properties.Refresh = function()
		local maxEntries = math.max(math.ceil((propsFrame.AbsoluteSize.Y) / 23),0)	
		local maxX = propsFrame.AbsoluteSize.X
		local valueWidth = math.max(Properties.MinInputWidth,maxX-Properties.ViewWidth)
		local inputPropVisible = false
		local isa = game.IsA
		local UDim2 = UDim2
		local stringSplit = string.split
		local scaleType = Settings.Properties.ScaleType

		-- Clear connections
		for i = 1,#propCons do
			propCons[i]:Disconnect()
		end
		table.clear(propCons)

		-- Hide full name viewer
		Properties.FullNameFrame.Visible = false
		Properties.FullNameFrameAttach.Disable()

		for i = 1,maxEntries do
			local entryData = propEntries[i]
			if not propEntries[i] then entryData = Properties.NewPropEntry(i) propEntries[i] = entryData end

			local entry = entryData.Gui
			local guiElems = entryData.GuiElems
			local nameFrame = guiElems.NameFrame
			local propNameLabel = guiElems.PropName
			local valueFrame = guiElems.ValueFrame
			local expand = guiElems.Expand
			local valueBox = guiElems.ValueBox
			local propNameBox = guiElems.PropName
			local rightButton = guiElems.RightButton
			local editAttributeButton = guiElems.EditAttributeButton
			local toggleAttributes = guiElems.ToggleAttributes

			local prop = viewList[i + Properties.Index]
			if prop then
				local entryXOffset = (scaleType == 0 and scrollH.Index or 0)
				entry.Visible = true
				entry.Position = UDim2.new(0,-entryXOffset,0,entry.Position.Y.Offset)
				entry.Size = UDim2.new(scaleType == 0 and 0 or 1, scaleType == 0 and Properties.ViewWidth + valueWidth or 0,0,22)

				if prop.SpecialRow then
					if prop.SpecialRow == "AddAttribute" then
						nameFrame.Visible = false
						valueFrame.Visible = false
						guiElems.RowButton.Visible = true
					end
				else
					-- Revert special row stuff
					nameFrame.Visible = true
					guiElems.RowButton.Visible = false

					local depth = Properties.EntryIndent*(prop.Depth or 1)
					local leftOffset = depth + Properties.EntryOffset
					nameFrame.Position = UDim2.new(0,leftOffset,0,0)
					propNameLabel.Size = UDim2.new(1,-2 - (scaleType == 0 and 0 or 6),1,0)

					local gName = (prop.CategoryName and "CAT_"..prop.CategoryName) or prop.Class.."."..prop.Name..(prop.SubName or "")

					if prop.CategoryName then
						entry.BackgroundColor3 = Settings.Theme.Main1
						valueFrame.Visible = false

						propNameBox.Text = prop.CategoryName
						propNameBox.Font = Enum.Font.SourceSansBold
						expand.Visible = true
						propNameBox.TextColor3 = Settings.Theme.Text
						nameFrame.BackgroundTransparency = 1
						nameFrame.Size = UDim2.new(1,0,1,0)
						editAttributeButton.Visible = false

						local showingAttrs = Settings.Properties.ShowAttributes
						toggleAttributes.Position = UDim2.new(1,-85-leftOffset,0,0)
						toggleAttributes.Text = (showingAttrs and "[Setting: ON]" or "[Setting: OFF]")
						toggleAttributes.TextColor3 = Settings.Theme.Text
						toggleAttributes.Visible = (prop.CategoryName == "Attributes")
					else
						local propName = prop.Name
						local typeData = prop.ValueType
						local typeName = typeData.Name
						local tags = prop.Tags
						local propObj = autoUpdateObjs[gName]

						local attributeOffset = (prop.IsAttribute and 20 or 0)
						editAttributeButton.Visible = (prop.IsAttribute and not prop.RootType)
						toggleAttributes.Visible = false

						-- Moving around the frames
						if scaleType == 0 then
							nameFrame.Size = UDim2.new(0,Properties.ViewWidth - leftOffset - 1,1,0)
							valueFrame.Position = UDim2.new(0,Properties.ViewWidth,0,0)
							valueFrame.Size = UDim2.new(0,valueWidth - attributeOffset,1,0)
						else
							nameFrame.Size = UDim2.new(0.5,-leftOffset - 1,1,0)
							valueFrame.Position = UDim2.new(0.5,0,0,0)
							valueFrame.Size = UDim2.new(0.5,-attributeOffset,1,0)
						end

						local nameArr = stringSplit(gName,".")
						propNameBox.Text = prop.DisplayName or nameArr[#nameArr]
						propNameBox.Font = Enum.Font.SourceSans
						entry.BackgroundColor3 = Settings.Theme.Main2
						valueFrame.Visible = true

						expand.Visible = typeData.Category == "DataType" and Properties.ExpandableTypes[typeName] or Properties.ExpandableProps[gName]
						propNameBox.TextColor3 = tags.ReadOnly and Settings.Theme.PlaceholderText or Settings.Theme.Text

						-- Display property value
						Properties.DisplayProp(prop,i)
						if propObj then
							if prop.IsAttribute then
								propCons[#propCons+1] = getAttributeChangedSignal(propObj,prop.AttributeName):Connect(function()
									Properties.DisplayProp(prop,i)
								end)
							else
								propCons[#propCons+1] = getPropChangedSignal(propObj,propName):Connect(function()
									Properties.DisplayProp(prop,i)
								end)
							end
						end

						-- Position and resize Input Box
						local beforeVisible = valueBox.Visible
						local inputFullName = inputProp and (inputProp.Class.."."..inputProp.Name..(inputProp.SubName or ""))
						if gName == inputFullName then
							nameFrame.BackgroundColor3 = Settings.Theme.ListSelection
							nameFrame.BackgroundTransparency = 0
							if typeData.Category == "Class" or typeData.Category == "Enum" or typeName == "BrickColor" then
								valueFrame.BackgroundColor3 = Settings.Theme.TextBox
								valueFrame.BackgroundTransparency = 0
								valueBox.Visible = true
							else
								inputPropVisible = true
								local scale = (scaleType == 0 and 0 or 0.5)
								local offset = (scaleType == 0 and Properties.ViewWidth-scrollH.Index or 0)
								local endOffset = 0

								if typeName == "Color3" or typeName == "ColorSequence" then
									offset = offset + 22
								end

								if typeName == "NumberSequence" or typeName == "ColorSequence" then
									endOffset = 20
								end

								inputBox.Position = UDim2.new(scale,offset,0,entry.Position.Y.Offset)
								inputBox.Size = UDim2.new(1-scale,-offset-endOffset-attributeOffset,0,22)
								inputBox.Visible = true
								valueBox.Visible = false
							end
						else
							nameFrame.BackgroundColor3 = Settings.Theme.Main1
							nameFrame.BackgroundTransparency = 1
							valueFrame.BackgroundColor3 = Settings.Theme.Main1
							valueFrame.BackgroundTransparency = 1
							valueBox.Visible = beforeVisible
						end
					end

					-- Expand
					if prop.CategoryName or Properties.ExpandableTypes[prop.ValueType and prop.ValueType.Name] or Properties.ExpandableProps[gName] then
						if Lib.CheckMouseInGui(expand) then
							Main.MiscIcons:DisplayByKey(expand.Icon, expanded[gName] and "Collapse_Over" or "Expand_Over")
						else
							Main.MiscIcons:DisplayByKey(expand.Icon, expanded[gName] and "Collapse" or "Expand")
						end
						expand.Visible = true
					else
						expand.Visible = false
					end
				end
				entry.Visible = true
			else
				entry.Visible = false
			end
		end

		if not inputPropVisible then
			inputBox.Visible = false
		end

		for i = maxEntries+1,#propEntries do
			propEntries[i].Gui:Destroy()
			propEntries[i] = nil
			checkboxes[i] = nil
		end
	end

	Properties.SetProp = function(prop,val,noupdate,prevAttribute)
		local sList = Explorer.Selection.List
		local propName = prop.Name
		local subName = prop.SubName
		local propClass = prop.Class
		local typeData = prop.ValueType
		local typeName = typeData.Name
		local attributeName = prop.AttributeName
		local rootTypeData = prop.RootType
		local rootTypeName = rootTypeData and rootTypeData.Name
		local fullName = prop.Class.."."..prop.Name..(prop.SubName or "")
		local Vector3 = Vector3

		for i = 1,#sList do
			local node = sList[i]
			local obj = node.Obj

			if isa(obj,propClass) then
				pcall(function()
					local setVal = val
					local root
					if prop.IsAttribute then
						root = getAttribute(obj,attributeName)
					else
						root = obj[propName]
					end

					if prevAttribute then
						if prevAttribute.ValueType.Name == typeName then
							setVal = getAttribute(obj,prevAttribute.AttributeName) or setVal
						end
						setAttribute(obj,prevAttribute.AttributeName,nil)
					end

					if rootTypeName then
						if rootTypeName == "Vector2" then
							setVal = Vector2.new((subName == ".X" and setVal) or root.X, (subName == ".Y" and setVal) or root.Y)
						elseif rootTypeName == "Vector3" then
							setVal = Vector3.new((subName == ".X" and setVal) or root.X, (subName == ".Y" and setVal) or root.Y, (subName == ".Z" and setVal) or root.Z)
						elseif rootTypeName == "UDim" then
							setVal = UDim.new((subName == ".Scale" and setVal) or root.Scale, (subName == ".Offset" and setVal) or root.Offset)
						elseif rootTypeName == "UDim2" then
							local rootX,rootY = root.X,root.Y
							local X_UDim = (subName == ".X" and setVal) or UDim.new((subName == ".X.Scale" and setVal) or rootX.Scale, (subName == ".X.Offset" and setVal) or rootX.Offset)
							local Y_UDim = (subName == ".Y" and setVal) or UDim.new((subName == ".Y.Scale" and setVal) or rootY.Scale, (subName == ".Y.Offset" and setVal) or rootY.Offset)
							setVal = UDim2.new(X_UDim,Y_UDim)
						elseif rootTypeName == "CFrame" then
							local rootPos,rootRight,rootUp,rootLook = root.Position,root.RightVector,root.UpVector,root.LookVector
							local pos = (subName == ".Position" and setVal) or Vector3.new((subName == ".Position.X" and setVal) or rootPos.X, (subName == ".Position.Y" and setVal) or rootPos.Y, (subName == ".Position.Z" and setVal) or rootPos.Z)
							local rightV = (subName == ".RightVector" and setVal) or Vector3.new((subName == ".RightVector.X" and setVal) or rootRight.X, (subName == ".RightVector.Y" and setVal) or rootRight.Y, (subName == ".RightVector.Z" and setVal) or rootRight.Z)
							local upV = (subName == ".UpVector" and setVal) or Vector3.new((subName == ".UpVector.X" and setVal) or rootUp.X, (subName == ".UpVector.Y" and setVal) or rootUp.Y, (subName == ".UpVector.Z" and setVal) or rootUp.Z)
							local lookV = (subName == ".LookVector" and setVal) or Vector3.new((subName == ".LookVector.X" and setVal) or rootLook.X, (subName == ".RightVector.Y" and setVal) or rootLook.Y, (subName == ".RightVector.Z" and setVal) or rootLook.Z)
							setVal = CFrame.fromMatrix(pos,rightV,upV,-lookV)
						elseif rootTypeName == "Rect" then
							local rootMin,rootMax = root.Min,root.Max
							local min = Vector2.new((subName == ".Min.X" and setVal) or rootMin.X, (subName == ".Min.Y" and setVal) or rootMin.Y)
							local max = Vector2.new((subName == ".Max.X" and setVal) or rootMax.X, (subName == ".Max.Y" and setVal) or rootMax.Y)
							setVal = Rect.new(min,max)
						elseif rootTypeName == "PhysicalProperties" then
							local rootProps = PhysicalProperties.new(obj.Material)
							local density = (subName == ".Density" and setVal) or (root and root.Density) or rootProps.Density
							local friction = (subName == ".Friction" and setVal) or (root and root.Friction) or rootProps.Friction
							local elasticity = (subName == ".Elasticity" and setVal) or (root and root.Elasticity) or rootProps.Elasticity
							local frictionWeight = (subName == ".FrictionWeight" and setVal) or (root and root.FrictionWeight) or rootProps.FrictionWeight
							local elasticityWeight = (subName == ".ElasticityWeight" and setVal) or (root and root.ElasticityWeight) or rootProps.ElasticityWeight
							setVal = PhysicalProperties.new(density,friction,elasticity,frictionWeight,elasticityWeight)
						elseif rootTypeName == "Ray" then
							local rootOrigin,rootDirection = root.Origin,root.Direction
							local origin = (subName == ".Origin" and setVal) or Vector3.new((subName == ".Origin.X" and setVal) or rootOrigin.X, (subName == ".Origin.Y" and setVal) or rootOrigin.Y, (subName == ".Origin.Z" and setVal) or rootOrigin.Z)
							local direction = (subName == ".Direction" and setVal) or Vector3.new((subName == ".Direction.X" and setVal) or rootDirection.X, (subName == ".Direction.Y" and setVal) or rootDirection.Y, (subName == ".Direction.Z" and setVal) or rootDirection.Z)
							setVal = Ray.new(origin,direction)
						elseif rootTypeName == "Faces" then
							local faces = {}
							local faceList = {"Back","Bottom","Front","Left","Right","Top"}
							for _,face in pairs(faceList) do
								local val
								if subName == "."..face then
									val = setVal
								else
									val = root[face]
								end
								if val then faces[#faces+1] = Enum.NormalId[face] end
							end
							setVal = Faces.new(unpack(faces))
						elseif rootTypeName == "Axes" then
							local axes = {}
							local axesList = {"X","Y","Z"}
							for _,axe in pairs(axesList) do
								local val
								if subName == "."..axe then
									val = setVal
								else
									val = root[axe]
								end
								if val then axes[#axes+1] = Enum.Axis[axe] end
							end
							setVal = Axes.new(unpack(axes))
						elseif rootTypeName == "NumberRange" then
							setVal = NumberRange.new(subName == ".Min" and setVal or root.Min, subName == ".Max" and setVal or root.Max)
						end
					end

					if typeName == "PhysicalProperties" and setVal then
						setVal = root or PhysicalProperties.new(obj.Material)
					end

					if prop.IsAttribute then
						setAttribute(obj,attributeName,setVal)
					else
						obj[propName] = setVal
					end
				end)
			end
		end

		if not noupdate then
			Properties.ComputeConflicts(prop)
		end
	end

	Properties.InitInputBox = function()
		inputBox = create({
			{1,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderSizePixel=0,Name="InputBox",Size=UDim2.new(0,200,0,22),Visible=false,ZIndex=2,}},
			{2,"TextBox",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BackgroundTransparency=1,BorderColor3=Color3.new(0.062745101749897,0.51764708757401,1),BorderSizePixel=0,ClearTextOnFocus=false,Font=3,Parent={1},PlaceholderColor3=Color3.new(0.69803923368454,0.69803923368454,0.69803923368454),Position=UDim2.new(0,3,0,0),Size=UDim2.new(1,-6,1,0),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,TextXAlignment=0,ZIndex=2,}},
		})
		inputTextBox = inputBox.TextBox
		inputBox.BackgroundColor3 = Settings.Theme.TextBox
		inputBox.Parent = Properties.Window.GuiElems.Content.List

		inputTextBox.FocusLost:Connect(function()
			if not inputProp then return end

			local prop = inputProp
			inputProp = nil
			local val = Properties.StringToValue(prop,inputTextBox.Text)
			if val then Properties.SetProp(prop,val) else Properties.Refresh() end
		end)

		inputTextBox.Focused:Connect(function()
			inputTextBox.SelectionStart = 1
			inputTextBox.CursorPosition = #inputTextBox.Text + 1
		end)

		Lib.ViewportTextBox.convert(inputTextBox)
	end

	Properties.SetInputProp = function(prop,entryIndex,special)
		local typeData = prop.ValueType
		local typeName = typeData.Name
		local fullName = prop.Class.."."..prop.Name..(prop.SubName or "")
		local propObj = autoUpdateObjs[fullName]
		local propVal = Properties.GetPropVal(prop,propObj)

		if prop.Tags.ReadOnly then return end

		inputProp = prop
		if special then
			if special == "color" then
				if typeName == "Color3" then
					inputTextBox.Text = propVal and Properties.ValueToString(prop,propVal) or ""
					Properties.DisplayColorEditor(prop,propVal)
				elseif typeName == "BrickColor" then
					Properties.DisplayBrickColorEditor(prop,entryIndex,propVal)
				elseif typeName == "ColorSequence" then
					inputTextBox.Text = propVal and Properties.ValueToString(prop,propVal) or ""
					Properties.DisplayColorSequenceEditor(prop,propVal)
				end
			elseif special == "right" then
				if typeName == "NumberSequence" then
					inputTextBox.Text = propVal and Properties.ValueToString(prop,propVal) or ""
					Properties.DisplayNumberSequenceEditor(prop,propVal)
				elseif typeName == "ColorSequence" then
					inputTextBox.Text = propVal and Properties.ValueToString(prop,propVal) or ""
					Properties.DisplayColorSequenceEditor(prop,propVal)
				end
			end
		else
			if Properties.IsTextEditable(prop) then
				inputTextBox.Text = propVal and Properties.ValueToString(prop,propVal) or ""
				inputTextBox:CaptureFocus()
			elseif typeData.Category == "Enum" then
				Properties.DisplayEnumDropdown(entryIndex)
			elseif typeName == "BrickColor" then
				Properties.DisplayBrickColorEditor(prop,entryIndex,propVal)
			end
		end
		Properties.Refresh()
	end

	Properties.InitSearch = function()
		local searchBox = Properties.GuiElems.ToolBar.SearchFrame.SearchBox

		Lib.ViewportTextBox.convert(searchBox)

		searchBox:GetPropertyChangedSignal("Text"):Connect(function()
			Properties.SearchText = searchBox.Text
			Properties.Update()
			Properties.Refresh()
		end)
	end

	Properties.InitEntryStuff = function()
		Properties.EntryTemplate = create({
			{1,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderColor3=Color3.new(0.1294117718935,0.1294117718935,0.1294117718935),Font=3,Name="Entry",Position=UDim2.new(0,1,0,1),Size=UDim2.new(0,250,0,22),Text="",TextSize=14,}},
			{2,"Frame",{BackgroundColor3=Color3.new(0.04313725605607,0.35294118523598,0.68627452850342),BackgroundTransparency=1,BorderColor3=Color3.new(0.33725491166115,0.49019610881805,0.73725491762161),BorderSizePixel=0,Name="NameFrame",Parent={1},Position=UDim2.new(0,20,0,0),Size=UDim2.new(1,-40,1,0),}},
			{3,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="PropName",Parent={2},Position=UDim2.new(0,2,0,0),Size=UDim2.new(1,-2,1,0),Text="Anchored",TextColor3=Color3.new(1,1,1),TextSize=14,TextTransparency=0.10000000149012,TextTruncate=1,TextXAlignment=0,}},
			{4,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,ClipsDescendants=true,Font=3,Name="Expand",Parent={2},Position=UDim2.new(0,-20,0,1),Size=UDim2.new(0,20,0,20),Text="",TextSize=14,Visible=false,}},
			{5,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5642383285",ImageRectOffset=Vector2.new(144,16),ImageRectSize=Vector2.new(16,16),Name="Icon",Parent={4},Position=UDim2.new(0,2,0,2),ScaleType=4,Size=UDim2.new(0,16,0,16),}},
			{6,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=4,Name="ToggleAttributes",Parent={2},Position=UDim2.new(1,-85,0,0),Size=UDim2.new(0,85,0,22),Text="[SETTING: OFF]",TextColor3=Color3.new(1,1,1),TextSize=14,TextTransparency=0.10000000149012,Visible=false,}},
			{7,"Frame",{BackgroundColor3=Color3.new(0.04313725605607,0.35294118523598,0.68627452850342),BackgroundTransparency=1,BorderColor3=Color3.new(0.33725491166115,0.49019607901573,0.73725491762161),BorderSizePixel=0,Name="ValueFrame",Parent={1},Position=UDim2.new(1,-100,0,0),Size=UDim2.new(0,80,1,0),}},
			{8,"Frame",{BackgroundColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),BorderColor3=Color3.new(0.33725491166115,0.49019610881805,0.73725491762161),BorderSizePixel=0,Name="Line",Parent={7},Position=UDim2.new(0,-1,0,0),Size=UDim2.new(0,1,1,0),}},
			{9,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="ColorButton",Parent={7},Size=UDim2.new(0,20,0,22),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,Visible=false,}},
			{10,"Frame",{BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0,0,0),Name="ColorPreview",Parent={9},Position=UDim2.new(0,5,0,6),Size=UDim2.new(0,10,0,10),}},
			{11,"UIGradient",{Parent={10},}},
			{12,"Frame",{BackgroundTransparency=1,Name="EnumArrow",Parent={7},Position=UDim2.new(1,-16,0,3),Size=UDim2.new(0,16,0,16),Visible=false,}},
			{13,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={12},Position=UDim2.new(0,8,0,9),Size=UDim2.new(0,1,0,1),}},
			{14,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={12},Position=UDim2.new(0,7,0,8),Size=UDim2.new(0,3,0,1),}},
			{15,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={12},Position=UDim2.new(0,6,0,7),Size=UDim2.new(0,5,0,1),}},
			{16,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="ValueBox",Parent={7},Position=UDim2.new(0,4,0,0),Size=UDim2.new(1,-8,1,0),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,TextTransparency=0.10000000149012,TextTruncate=1,TextXAlignment=0,}},
			{17,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="RightButton",Parent={7},Position=UDim2.new(1,-20,0,0),Size=UDim2.new(0,20,0,22),Text="...",TextColor3=Color3.new(1,1,1),TextSize=14,Visible=false,}},
			{18,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="SettingsButton",Parent={7},Position=UDim2.new(1,-20,0,0),Size=UDim2.new(0,20,0,22),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,Visible=false,}},
			{19,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Name="SoundPreview",Parent={7},Size=UDim2.new(1,0,1,0),Visible=false,}},
			{20,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="ControlButton",Parent={19},Size=UDim2.new(0,20,0,22),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,}},
			{21,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5642383285",ImageRectOffset=Vector2.new(144,16),ImageRectSize=Vector2.new(16,16),Name="Icon",Parent={20},Position=UDim2.new(0,2,0,3),ScaleType=4,Size=UDim2.new(0,16,0,16),}},
			{22,"Frame",{BackgroundColor3=Color3.new(0.3137255012989,0.3137255012989,0.3137255012989),BorderSizePixel=0,Name="TimeLine",Parent={19},Position=UDim2.new(0,26,0.5,-1),Size=UDim2.new(1,-34,0,2),}},
			{23,"Frame",{BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.1294117718935,0.1294117718935,0.1294117718935),Name="Slider",Parent={22},Position=UDim2.new(0,-4,0,-8),Size=UDim2.new(0,8,0,18),}},
			{24,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="EditAttributeButton",Parent={1},Position=UDim2.new(1,-20,0,0),Size=UDim2.new(0,20,0,22),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,}},
			{25,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5034718180",ImageTransparency=0.20000000298023,Name="Icon",Parent={24},Position=UDim2.new(0,2,0,3),Size=UDim2.new(0,16,0,16),}},
			{26,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderSizePixel=0,Font=3,Name="RowButton",Parent={1},Size=UDim2.new(1,0,1,0),Text="Add Attribute",TextColor3=Color3.new(1,1,1),TextSize=14,TextTransparency=0.10000000149012,Visible=false,}},
		})

		local fullNameFrame = Lib.Frame.new()
		local label = Lib.Label.new()
		label.Parent = fullNameFrame.Gui
		label.Position = UDim2.new(0,2,0,0)
		label.Size = UDim2.new(1,-4,1,0)
		fullNameFrame.Visible = false
		fullNameFrame.Parent = window.Gui

		Properties.FullNameFrame = fullNameFrame
		Properties.FullNameFrameAttach = Lib.AttachTo(fullNameFrame)
	end

	Properties.Init = function() -- TODO: MAKE BETTER
		local guiItems = create({
			{1,"Folder",{Name="Items",}},
			{2,"Frame",{BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BorderSizePixel=0,Name="ToolBar",Parent={1},Size=UDim2.new(1,0,0,22),}},
			{3,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.1176470592618,0.1176470592618,0.1176470592618),BorderSizePixel=0,Name="SearchFrame",Parent={2},Position=UDim2.new(0,3,0,1),Size=UDim2.new(1,-6,0,18),}},
			{4,"TextBox",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,ClearTextOnFocus=false,Font=3,Name="SearchBox",Parent={3},PlaceholderColor3=Color3.new(0.39215689897537,0.39215689897537,0.39215689897537),PlaceholderText="Search properties",Position=UDim2.new(0,4,0,0),Size=UDim2.new(1,-24,0,18),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,TextXAlignment=0,}},
			{5,"UICorner",{CornerRadius=UDim.new(0,2),Parent={3},}},
			{6,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Reset",Parent={3},Position=UDim2.new(1,-17,0,1),Size=UDim2.new(0,16,0,16),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,}},
			{7,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5034718129",ImageColor3=Color3.new(0.39215686917305,0.39215686917305,0.39215686917305),Parent={6},Size=UDim2.new(0,16,0,16),}},
			{8,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Refresh",Parent={2},Position=UDim2.new(1,-20,0,1),Size=UDim2.new(0,18,0,18),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,Visible=false,}},
			{9,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5642310344",Parent={8},Position=UDim2.new(0,3,0,3),Size=UDim2.new(0,12,0,12),}},
			{10,"Frame",{BackgroundColor3=Color3.new(0.15686275064945,0.15686275064945,0.15686275064945),BorderSizePixel=0,Name="ScrollCorner",Parent={1},Position=UDim2.new(1,-16,1,-16),Size=UDim2.new(0,16,0,16),Visible=false,}},
			{11,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,ClipsDescendants=true,Name="List",Parent={1},Position=UDim2.new(0,0,0,23),Size=UDim2.new(1,0,1,-23),}},
		})

		-- Vars
		categoryOrder =  API.CategoryOrder
		for category,_ in next,categoryOrder do
			if not Properties.CollapsedCategories[category] then
				expanded["CAT_"..category] = true
			end
		end
		expanded["Sound.SoundId"] = true

		-- Init window
		window = Lib.Window.new()
		Properties.Window = window
		window:SetTitle("Properties")

		toolBar = guiItems.ToolBar
		propsFrame = guiItems.List

		Properties.GuiElems.ToolBar = toolBar
		Properties.GuiElems.PropsFrame = propsFrame

		Properties.InitEntryStuff()

		-- Window events
		window.GuiElems.Main:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
			if Properties.Window:IsContentVisible() then
				Properties.UpdateView()
				Properties.Refresh()
			end
		end)
		window.OnActivate:Connect(function()
			Properties.UpdateView()
			Properties.Update()
			Properties.Refresh()
		end)
		window.OnRestore:Connect(function()
			Properties.UpdateView()
			Properties.Update()
			Properties.Refresh()
		end)

		-- Init scrollbars
		scrollV = Lib.ScrollBar.new()		
		scrollV.WheelIncrement = 3
		scrollV.Gui.Position = UDim2.new(1,-16,0,23)
		scrollV:SetScrollFrame(propsFrame)
		scrollV.Scrolled:Connect(function()
			Properties.Index = scrollV.Index
			Properties.Refresh()
		end)

		scrollH = Lib.ScrollBar.new(true)
		scrollH.Increment = 5
		scrollH.WheelIncrement = 20
		scrollH.Gui.Position = UDim2.new(0,0,1,-16)
		scrollH.Scrolled:Connect(function()
			Properties.Refresh()
		end)

		-- Setup Gui
		window.GuiElems.Line.Position = UDim2.new(0,0,0,22)
		toolBar.Parent = window.GuiElems.Content
		propsFrame.Parent = window.GuiElems.Content
		guiItems.ScrollCorner.Parent = window.GuiElems.Content
		scrollV.Gui.Parent = window.GuiElems.Content
		scrollH.Gui.Parent = window.GuiElems.Content
		Properties.InitInputBox()
		Properties.InitSearch()
	end

	return Properties
end

return {InitDeps = initDeps, InitAfterMain = initAfterMain, Main = main}
end,
ScriptViewer = function()
--[[
	Script Viewer App Module
	
	A script viewer that is basically a notepad
]]

-- Common Locals
local Main,Lib,Apps,Settings -- Main Containers
local Explorer, Properties, ScriptViewer, Notebook -- Major Apps
local API,RMD,env,service,plr,create,createSimple -- Main Locals

local function initDeps(data)
	Main = data.Main
	Lib = data.Lib
	Apps = data.Apps
	Settings = data.Settings

	API = data.API
	RMD = data.RMD
	env = data.env
	service = data.service
	plr = data.plr
	create = data.create
	createSimple = data.createSimple
end

local function initAfterMain()
	Explorer = Apps.Explorer
	Properties = Apps.Properties
	ScriptViewer = Apps.ScriptViewer
	Notebook = Apps.Notebook
end

local function main()
	local ScriptViewer = {}
	local window, codeFrame
	local PreviousScr = nil

	ScriptViewer.ViewScript = function(scr)
		if scr.ClassName == "Script" then local success, source = pcall(otherdecompile or function() end, scr)
		if not success or not source then source, PreviousScr = "-- DEX - Source failed to decompile", nil else PreviousScr = scr end
		codeFrame:SetText(source:gsub("\0", "\\0")) -- Fix stupid breaking script viewer 
		else
		local success, source = pcall(medaldecompile or krampusdecompile or simpledecompile or function() end, scr)
		if not success or not source then source, PreviousScr = "-- DEX - Source failed to decompile", nil else PreviousScr = scr end
		codeFrame:SetText(source:gsub("\0", "\\0")) -- Fix stupid breaking script viewer
		end
		window:Show()
	end

	ScriptViewer.Init = function()
		window = Lib.Window.new()
		window:SetTitle("Script Viewer")
		window:Resize(500,400)
		ScriptViewer.Window = window

		codeFrame = Lib.CodeFrame.new()
		codeFrame.Frame.Position = UDim2.new(0,0,0,20)
		codeFrame.Frame.Size = UDim2.new(1,0,1,-20)
		codeFrame.Frame.Parent = window.GuiElems.Content

		-- TODO: REMOVE AND MAKE BETTER
		local copy = Instance.new("TextButton",window.GuiElems.Content)
		copy.BackgroundTransparency = 1
		copy.Size = UDim2.new(0.5,0,0,20)
		copy.Text = "Copy to Clipboard"
		copy.TextColor3 = Color3.new(1,1,1)

		copy.MouseButton1Click:Connect(function()
			local source = codeFrame:GetText()
			env.setclipboard(source)
		end)

		local save = Instance.new("TextButton",window.GuiElems.Content)
		save.BackgroundTransparency = 1
		save.Position = UDim2.new(0.35,0,0,0)
		save.Size = UDim2.new(0.3,0,0,20)
		save.Text = "Save to File"
		save.TextColor3 = Color3.new(1,1,1)

		save.MouseButton1Click:Connect(function()
			local source = codeFrame:GetText()
			local filename = "Place_"..game.PlaceId.."_Script_"..os.time()..".txt"

			env.writefile(filename, source)
			if env.movefileas then
				env.movefileas(filename, ".txt")
			end
		end)

		local dumpbtn = Instance.new("TextButton",window.GuiElems.Content)
		dumpbtn.BackgroundTransparency = 1
		dumpbtn.Position = UDim2.new(0.7,0,0,0)
		dumpbtn.Size = UDim2.new(0.3,0,0,20)
		dumpbtn.Text = "Dump Functions"
		dumpbtn.TextColor3 = Color3.new(1,1,1)

		dumpbtn.MouseButton1Click:Connect(function()
			if PreviousScr ~= nil then
				pcall(function()
                    -- thanks King.Kevin#6025 you'll obviously be credited (no discord tag since that can easily be impersonated)
                    local getgc = getgc or get_gc_objects
                    local getupvalues = (debug and debug.getupvalues) or getupvalues or getupvals
                    local getconstants = (debug and debug.getconstants) or getconstants or getconsts
                    local getinfo = (debug and (debug.getinfo or debug.info)) or getinfo
                    local original = ("\n-- // Function Dumper made by King.Kevin\n-- // Script Path: %s\n\n--[["):format(PreviousScr:GetFullName())
                    local dump = original
                    local functions, function_count, data_base = {}, 0, {}
                    function functions:add_to_dump(str, indentation, new_line)
                        local new_line = new_line or true
                        dump = dump .. ("%s%s%s"):format(string.rep("    ", indentation), tostring(str), new_line and "\n" or "")
                    end
                    function functions:get_function_name(func)
                        local n = getinfo(func).name
                        return n ~= "" and n or "Unknown Name"
                    end
                    function functions:dump_table(input, indent, index)
                        local indent = indent < 0 and 0 or indent
                        functions:add_to_dump(("%s [%s] %s"):format(tostring(index), tostring(typeof(input)), tostring(input)), indent - 1)
                        local count = 0
                        for index, value in pairs(input) do
                            count = count + 1
                            if type(value) == "function" then
                                functions:add_to_dump(("%d [function] = %s"):format(count, functions:get_function_name(value)), indent)
                            elseif type(value) == "table" then
                                if not data_base[value] then
                                    data_base[value] = true
                                    functions:add_to_dump(("%d [table]:"):format(count), indent)
                                    functions:dump_table(value, indent + 1, index)
                                else
                                    functions:add_to_dump(("%d [table] (Recursive table detected)"):format(count), indent)
                                end
                            else
                                functions:add_to_dump(("%d [%s] = %s"):format(count, tostring(typeof(value)), tostring(value)), indent)
                            end
                        end
                    end
                    function functions:dump_function(input, indent)
                        functions:add_to_dump(("\nFunction Dump: %s"):format(functions:get_function_name(input)), indent)
                        functions:add_to_dump(("\nFunction Upvalues: %s"):format(functions:get_function_name(input)), indent)
                        for index, upvalue in pairs(getupvalues(input)) do
                            if type(upvalue) == "function" then
                                functions:add_to_dump(("%d [function] = %s"):format(index, functions:get_function_name(upvalue)), indent + 1)
                            elseif type(upvalue) == "table" then
                                if not data_base[upvalue] then
                                    data_base[upvalue] = true
                                    functions:add_to_dump(("%d [table]:"):format(index), indent + 1)
                                    functions:dump_table(upvalue, indent + 2, index)
                                else
                                    functions:add_to_dump(("%d [table] (Recursive table detected)"):format(index), indent + 1)
                                end
                            else
                                functions:add_to_dump(("%d [%s] = %s"):format(index, tostring(typeof(upvalue)), tostring(upvalue)), indent + 1)
                            end
                        end
                        functions:add_to_dump(("\nFunction Constants: %s"):format(functions:get_function_name(input)), indent)
                        for index, constant in pairs(getconstants(input)) do
                            if type(constant) == "function" then
                                functions:add_to_dump(("%d [function] = %s"):format(index, functions:get_function_name(constant)), indent + 1)
                            elseif type(constant) == "table" then
                                if not data_base[constant] then
                                    data_base[constant] = true
                                    functions:add_to_dump(("%d [table]:"):format(index), indent + 1)
                                    functions:dump_table(constant, indent + 2, index)
                                else
                                    functions:add_to_dump(("%d [table] (Recursive table detected)"):format(index), indent + 1)
                                end
                            else
                                functions:add_to_dump(("%d [%s] = %s"):format(index, tostring(typeof(constant)), tostring(constant)), indent + 1)
                            end
                        end
                    end
                    for _, _function in pairs(getgc()) do
                        if typeof(_function) == "function" and getfenv(_function).script and getfenv(_function).script == PreviousScr then
                            functions:dump_function(_function, 0)
                            functions:add_to_dump("\n" .. ("="):rep(100), 0, false)
                        end
                    end
                    local source = codeFrame:GetText()
                    if dump ~= original then source = source .. dump .. "]]" end
                    codeFrame:SetText(source)
                end)
            end
		end)
	end

	return ScriptViewer
end

return {InitDeps = initDeps, InitAfterMain = initAfterMain, Main = main}
end,
Lib = function()
--[[
	Lib Module
	
	Container for functions and classes
]]

-- Common Locals
local Main,Lib,Apps,Settings -- Main Containers
local Explorer, Properties, ScriptViewer, Notebook -- Major Apps
local API,RMD,env,service,plr,create,createSimple -- Main Locals

local function initDeps(data)
	Main = data.Main
	Lib = data.Lib
	Apps = data.Apps
	Settings = data.Settings

	API = data.API
	RMD = data.RMD
	env = data.env
	service = data.service
	plr = data.plr
	create = data.create
	createSimple = data.createSimple
end

local function initAfterMain()
	Explorer = Apps.Explorer
	Properties = Apps.Properties
	ScriptViewer = Apps.ScriptViewer
	Notebook = Apps.Notebook
end

local function main()
	local Lib = {}

	local renderStepped = service.RunService.RenderStepped
	local signalWait = renderStepped.wait
	local PH = newproxy() -- Placeholder, must be replaced in constructor
	local SIGNAL = newproxy()

	-- Usually for classes that work with a Roblox Object
	local function initObj(props,mt)
		local type = type
		local function copy(t)
			local res = {}
			for i,v in pairs(t) do
				if v == SIGNAL then
					res[i] = Lib.Signal.new()
				elseif type(v) == "table" then
					res[i] = copy(v)
				else
					res[i] = v
				end
			end		
			return res
		end

		local newObj = copy(props)
		return setmetatable(newObj,mt)
	end

	local function getGuiMT(props,funcs)
		return {__index = function(self,ind) if not props[ind] then return funcs[ind] or self.Gui[ind] end end,
		__newindex = function(self,ind,val) if not props[ind] then self.Gui[ind] = val else rawset(self,ind,val) end end}
	end

	-- Functions

	Lib.FormatLuaString = (function()
		local string = string
		local gsub = string.gsub
		local format = string.format
		local char = string.char
		local cleanTable = {['"'] = '\\"', ['\\'] = '\\\\'}
		for i = 0,31 do
			cleanTable[char(i)] = "\\"..format("%03d",i)
		end
		for i = 127,255 do
			cleanTable[char(i)] = "\\"..format("%03d",i)
		end

		return function(str)
			return gsub(str,"[\"\\\0-\31\127-\255]",cleanTable)
		end
	end)()

	Lib.CheckMouseInGui = function(gui)
		if gui == nil then return false end
		local mouse = Main.Mouse
		local guiPosition = gui.AbsolutePosition
		local guiSize = gui.AbsoluteSize	

		return mouse.X >= guiPosition.X and mouse.X < guiPosition.X + guiSize.X and mouse.Y >= guiPosition.Y and mouse.Y < guiPosition.Y + guiSize.Y
	end

	Lib.IsShiftDown = function()
		return service.UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) or service.UserInputService:IsKeyDown(Enum.KeyCode.RightShift)
	end

	Lib.IsCtrlDown = function()
		return service.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or service.UserInputService:IsKeyDown(Enum.KeyCode.RightControl)
	end

	Lib.CreateArrow = function(size,num,dir)
		local max = num
		local arrowFrame = createSimple("Frame",{
			BackgroundTransparency = 1,
			Name = "Arrow",
			Size = UDim2.new(0,size,0,size)
		})
		if dir == "up" then
			for i = 1,num do
				local newLine = createSimple("Frame",{
					BackgroundColor3 = Color3.new(220/255,220/255,220/255),
					BorderSizePixel = 0,
					Position = UDim2.new(0,math.floor(size/2)-(i-1),0,math.floor(size/2)+i-math.floor(max/2)-1),
					Size = UDim2.new(0,i+(i-1),0,1),
					Parent = arrowFrame
				})
			end
			return arrowFrame
		elseif dir == "down" then
			for i = 1,num do
				local newLine = createSimple("Frame",{
					BackgroundColor3 = Color3.new(220/255,220/255,220/255),
					BorderSizePixel = 0,
					Position = UDim2.new(0,math.floor(size/2)-(i-1),0,math.floor(size/2)-i+math.floor(max/2)+1),
					Size = UDim2.new(0,i+(i-1),0,1),
					Parent = arrowFrame
				})
			end
			return arrowFrame
		elseif dir == "left" then
			for i = 1,num do
				local newLine = createSimple("Frame",{
					BackgroundColor3 = Color3.new(220/255,220/255,220/255),
					BorderSizePixel = 0,
					Position = UDim2.new(0,math.floor(size/2)+i-math.floor(max/2)-1,0,math.floor(size/2)-(i-1)),
					Size = UDim2.new(0,1,0,i+(i-1)),
					Parent = arrowFrame
				})
			end
			return arrowFrame
		elseif dir == "right" then
			for i = 1,num do
				local newLine = createSimple("Frame",{
					BackgroundColor3 = Color3.new(220/255,220/255,220/255),
					BorderSizePixel = 0,
					Position = UDim2.new(0,math.floor(size/2)-i+math.floor(max/2)+1,0,math.floor(size/2)-(i-1)),
					Size = UDim2.new(0,1,0,i+(i-1)),
					Parent = arrowFrame
				})
			end
			return arrowFrame
		end
		error("r u ok")
	end

	Lib.ParseXML = (function()
		local func = function()
			-- Only exists to parse RMD
			-- from https://github.com/jonathanpoelen/xmlparser

			local string, print, pairs = string, print, pairs

			-- http://lua-users.org/wiki/StringTrim
			local trim = function(s)
				local from = s:match"^%s*()"
				return from > #s and "" or s:match(".*%S", from)
			end

			local gtchar = string.byte('>', 1)
			local slashchar = string.byte('/', 1)
			local D = string.byte('D', 1)
			local E = string.byte('E', 1)

			function parse(s, evalEntities)
				-- remove comments
				s = s:gsub('<!%-%-(.-)%-%->', '')

				local entities, tentities = {}

				if evalEntities then
					local pos = s:find('<[_%w]')
					if pos then
						s:sub(1, pos):gsub('<!ENTITY%s+([_%w]+)%s+(.)(.-)%2', function(name, q, entity)
							entities[#entities+1] = {name=name, value=entity}
						end)
						tentities = createEntityTable(entities)
						s = replaceEntities(s:sub(pos), tentities)
					end
				end

				local t, l = {}, {}

				local addtext = function(txt)
					txt = txt:match'^%s*(.*%S)' or ''
					if #txt ~= 0 then
						t[#t+1] = {text=txt}
					end    
				end

				s:gsub('<([?!/]?)([-:_%w]+)%s*(/?>?)([^<]*)', function(type, name, closed, txt)
					-- open
					if #type == 0 then
						local a = {}
						if #closed == 0 then
							local len = 0
							for all,aname,_,value,starttxt in string.gmatch(txt, "(.-([-_%w]+)%s*=%s*(.)(.-)%3%s*(/?>?))") do
								len = len + #all
								a[aname] = value
								if #starttxt ~= 0 then
									txt = txt:sub(len+1)
									closed = starttxt
									break
								end
							end
						end
						t[#t+1] = {tag=name, attrs=a, children={}}

						if closed:byte(1) ~= slashchar then
							l[#l+1] = t
							t = t[#t].children
						end

						addtext(txt)
						-- close
					elseif '/' == type then
						t = l[#l]
						l[#l] = nil

						addtext(txt)
						-- ENTITY
					elseif '!' == type then
						if E == name:byte(1) then
							txt:gsub('([_%w]+)%s+(.)(.-)%2', function(name, q, entity)
								entities[#entities+1] = {name=name, value=entity}
							end, 1)
						end
						-- elseif '?' == type then
						--   print('?  ' .. name .. ' // ' .. attrs .. '$$')
						-- elseif '-' == type then
						--   print('comment  ' .. name .. ' // ' .. attrs .. '$$')
						-- else
						--   print('o  ' .. #p .. ' // ' .. name .. ' // ' .. attrs .. '$$')
					end
				end)

				return {children=t, entities=entities, tentities=tentities}
			end

			function parseText(txt)
				return parse(txt)
			end

			function defaultEntityTable()
				return { quot='"', apos='\'', lt='<', gt='>', amp='&', tab='\t', nbsp=' ', }
			end

			function replaceEntities(s, entities)
				return s:gsub('&([^;]+);', entities)
			end

			function createEntityTable(docEntities, resultEntities)
				entities = resultEntities or defaultEntityTable()
				for _,e in pairs(docEntities) do
					e.value = replaceEntities(e.value, entities)
					entities[e.name] = e.value
				end
				return entities
			end

			return parseText
		end
		local newEnv = setmetatable({},{__index = getfenv()})
		setfenv(func,newEnv)
		return func()
	end)()

	Lib.FastWait = function(s)
		if not s then return signalWait(renderStepped) end
		local start = tick()
		while tick() - start < s do signalWait(renderStepped) end
	end

	Lib.ButtonAnim = function(button,data)
		local holding = false
		local disabled = false
		local mode = data and data.Mode or 1
		local control = {}

		if mode == 2 then
			local lerpTo = data.LerpTo or Color3.new(0,0,0)
			local delta = data.LerpDelta or 0.2
			control.StartColor = data.StartColor or button.BackgroundColor3
			control.PressColor = data.PressColor or control.StartColor:lerp(lerpTo,delta)
			control.HoverColor = data.HoverColor or control.StartColor:lerp(control.PressColor,0.6)
			control.OutlineColor = data.OutlineColor
		end

		button.InputBegan:Connect(function(input)
			if disabled then return end
			if input.UserInputType == Enum.UserInputType.MouseMovement and not holding then
				if mode == 1 then
					button.BackgroundTransparency = 0.4
				elseif mode == 2 then
					button.BackgroundColor3 = control.HoverColor
				end
			elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
				holding = true
				if mode == 1 then
					button.BackgroundTransparency = 0
				elseif mode == 2 then
					button.BackgroundColor3 = control.PressColor
					if control.OutlineColor then button.BorderColor3 = control.PressColor end
				end
			end
		end)

		button.InputEnded:Connect(function(input)
			if disabled then return end
			if input.UserInputType == Enum.UserInputType.MouseMovement and not holding then
				if mode == 1 then
					button.BackgroundTransparency = 1
				elseif mode == 2 then
					button.BackgroundColor3 = control.StartColor
				end
			elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
				holding = false
				if mode == 1 then
					button.BackgroundTransparency = Lib.CheckMouseInGui(button) and 0.4 or 1
				elseif mode == 2 then
					button.BackgroundColor3 = Lib.CheckMouseInGui(button) and control.HoverColor or control.StartColor
					if control.OutlineColor then button.BorderColor3 = control.OutlineColor end
				end
			end
		end)

		control.Disable = function()
			disabled = true
			holding = false

			if mode == 1 then
				button.BackgroundTransparency = 1
			elseif mode == 2 then
				button.BackgroundColor3 = control.StartColor
			end
		end

		control.Enable = function()
			disabled = false
		end

		return control
	end

	Lib.FindAndRemove = function(t,item)
		local pos = table.find(t,item)
		if pos then table.remove(t,pos) end
	end

	Lib.AttachTo = function(obj,data)
		local target,posOffX,posOffY,sizeOffX,sizeOffY,resize,con
		local disabled = false

		local function update()
			if not obj or not target then return end

			local targetPos = target.AbsolutePosition
			local targetSize = target.AbsoluteSize
			obj.Position = UDim2.new(0,targetPos.X + posOffX,0,targetPos.Y + posOffY)
			if resize then obj.Size = UDim2.new(0,targetSize.X + sizeOffX,0,targetSize.Y + sizeOffY) end
		end

		local function setup(o,data)
			obj = o
			data = data or {}
			target = data.Target
			posOffX = data.PosOffX or 0
			posOffY = data.PosOffY or 0
			sizeOffX = data.SizeOffX or 0
			sizeOffY = data.SizeOffY or 0
			resize = data.Resize or false

			if con then con:Disconnect() con = nil end
			if target then
				con = target.Changed:Connect(function(prop)
					if not disabled and prop == "AbsolutePosition" or prop == "AbsoluteSize" then
						update()
					end
				end)
			end

			update()
		end
		setup(obj,data)

		return {
			SetData = function(obj,data)
				setup(obj,data)
			end,
			Enable = function()
				disabled = false
				update()
			end,
			Disable = function()
				disabled = true
			end,
			Destroy = function()
				con:Disconnect()
				con = nil
			end,
		}
	end

	Lib.ProtectedGuis = {}

    Lib.ShowGui = function(gui)
        if env.gethui then
            gui.Parent = env.gethui()
        elseif env.protectgui then
            env.protectgui(gui)
            gui.Parent = Main.GuiHolder
        else
            gui.Parent = Main.GuiHolder
        end
    end

	Lib.ColorToBytes = function(col)
		local round = math.round
		return string.format("%d, %d, %d",round(col.r*255),round(col.g*255),round(col.b*255))
	end

	Lib.ReadFile = function(filename)
		if not env.readfile then return end

		local s,contents = pcall(env.readfile,filename)
		if s and contents then return contents end
	end

	Lib.DeferFunc = function(f,...)
		signalWait(renderStepped)
		return f(...)
	end
	
	Lib.LoadCustomAsset = function(filepath)
		if not env.getcustomasset or not env.isfile or not env.isfile(filepath) then return end

		return env.getcustomasset(filepath)
	end

	Lib.FetchCustomAsset = function(url,filepath)
		if not env.writefile then return end

		local s,data = pcall(game.HttpGet,game,url)
		if not s then return end

		env.writefile(filepath,data)
		return Lib.LoadCustomAsset(filepath)
	end

	-- Classes

	Lib.Signal = (function()
		local funcs = {}

		local disconnect = function(con)
			local pos = table.find(con.Signal.Connections,con)
			if pos then table.remove(con.Signal.Connections,pos) end
		end

		funcs.Connect = function(self,func)
			if type(func) ~= "function" then error("Attempt to connect a non-function") end		
			local con = {
				Signal = self,
				Func = func,
				Disconnect = disconnect
			}
			self.Connections[#self.Connections+1] = con
			return con
		end

		funcs.Fire = function(self,...)
			for i,v in next,self.Connections do
				xpcall(coroutine.wrap(v.Func),function(e) warn(e.."\n"..debug.traceback()) end,...)
			end
		end

		local mt = {
			__index = funcs,
			__tostring = function(self)
				return "Signal: " .. tostring(#self.Connections) .. " Connections"
			end
		}

		local function new()
			local obj = {}
			obj.Connections = {}

			return setmetatable(obj,mt)
		end

		return {new = new}
	end)()

	Lib.Set = (function()
		local funcs = {}

		funcs.Add = function(self,obj)
			if self.Map[obj] then return end

			local list = self.List
			list[#list+1] = obj
			self.Map[obj] = true
			self.Changed:Fire()
		end

		funcs.AddTable = function(self,t)
			local changed
			local list,map = self.List,self.Map
			for i = 1,#t do
				local elem = t[i]
				if not map[elem] then
					list[#list+1] = elem
					map[elem] = true
					changed = true
				end
			end
			if changed then self.Changed:Fire() end
		end

		funcs.Remove = function(self,obj)
			if not self.Map[obj] then return end

			local list = self.List
			local pos = table.find(list,obj)
			if pos then table.remove(list,pos) end
			self.Map[obj] = nil
			self.Changed:Fire()
		end

		funcs.RemoveTable = function(self,t)
			local changed
			local list,map = self.List,self.Map
			local removeSet = {}
			for i = 1,#t do
				local elem = t[i]
				map[elem] = nil
				removeSet[elem] = true
			end

			for i = #list,1,-1 do
				local elem = list[i]
				if removeSet[elem] then
					table.remove(list,i)
					changed = true
				end
			end
			if changed then self.Changed:Fire() end
		end

		funcs.Set = function(self,obj)
			if #self.List == 1 and self.List[1] == obj then return end

			self.List = {obj}
			self.Map = {[obj] = true}
			self.Changed:Fire()
		end

		funcs.SetTable = function(self,t)
			local newList,newMap = {},{}
			self.List,self.Map = newList,newMap
			table.move(t,1,#t,1,newList)
			for i = 1,#t do
				newMap[t[i]] = true
			end
			self.Changed:Fire()
		end

		funcs.Clear = function(self)
			if #self.List == 0 then return end
			self.List = {}
			self.Map = {}
			self.Changed:Fire()
		end

		local mt = {__index = funcs}

		local function new()
			local obj = setmetatable({
				List = {},
				Map = {},
				Changed = Lib.Signal.new()
			},mt)

			return obj
		end

		return {new = new}
	end)()

	Lib.IconMap = (function()
		local funcs = {}

		funcs.GetLabel = function(self)
			local label = Instance.new("ImageLabel")
			self:SetupLabel(label)
			return label
		end

		funcs.SetupLabel = function(self,obj)
			obj.BackgroundTransparency = 1
			obj.ImageRectOffset = Vector2.new(0,0)
			obj.ImageRectSize = Vector2.new(self.IconSizeX,self.IconSizeY)
			obj.ScaleType = Enum.ScaleType.Crop
			obj.Size = UDim2.new(0,self.IconSizeX,0,self.IconSizeY)
		end

		funcs.Display = function(self,obj,index)
			obj.Image = self.MapId
			if not self.NumX then
				obj.ImageRectOffset = Vector2.new(self.IconSizeX*index, 0)
			else
				obj.ImageRectOffset = Vector2.new(self.IconSizeX*(index % self.NumX), self.IconSizeY*math.floor(index / self.NumX))	
			end
		end

		funcs.DisplayByKey = function(self,obj,key)
			if self.IndexDict[key] then
				self:Display(obj,self.IndexDict[key])
			end
		end

		funcs.SetDict = function(self,dict)
			self.IndexDict = dict
		end

		local mt = {}
		mt.__index = funcs

		local function new(mapId,mapSizeX,mapSizeY,iconSizeX,iconSizeY)
			local obj = setmetatable({
				MapId = mapId,
				MapSizeX = mapSizeX,
				MapSizeY = mapSizeY,
				IconSizeX = iconSizeX,
				IconSizeY = iconSizeY,
				NumX = mapSizeX/iconSizeX,
				IndexDict = {}
			},mt)
			return obj
		end

		local function newLinear(mapId,iconSizeX,iconSizeY)
			local obj = setmetatable({
				MapId = mapId,
				IconSizeX = iconSizeX,
				IconSizeY = iconSizeY,
				IndexDict = {}
			},mt)
			return obj
		end

		return {new = new, newLinear = newLinear}
	end)()

	Lib.ScrollBar = (function()
		local funcs = {}
		local user = service.UserInputService
		local mouse = plr:GetMouse()
		local checkMouseInGui = Lib.CheckMouseInGui
		local createArrow = Lib.CreateArrow

		local function drawThumb(self)
			local total = self.TotalSpace
			local visible = self.VisibleSpace
			local index = self.Index
			local scrollThumb = self.GuiElems.ScrollThumb
			local scrollThumbFrame = self.GuiElems.ScrollThumbFrame

			if not (self:CanScrollUp()	or self:CanScrollDown()) then
				scrollThumb.Visible = false
			else
				scrollThumb.Visible = true
			end

			if self.Horizontal then
				scrollThumb.Size = UDim2.new(visible/total,0,1,0)
				if scrollThumb.AbsoluteSize.X < 16 then
					scrollThumb.Size = UDim2.new(0,16,1,0)
				end
				local fs = scrollThumbFrame.AbsoluteSize.X
				local bs = scrollThumb.AbsoluteSize.X
				scrollThumb.Position = UDim2.new(self:GetScrollPercent()*(fs-bs)/fs,0,0,0)
			else
				scrollThumb.Size = UDim2.new(1,0,visible/total,0)
				if scrollThumb.AbsoluteSize.Y < 16 then
					scrollThumb.Size = UDim2.new(1,0,0,16)
				end
				local fs = scrollThumbFrame.AbsoluteSize.Y
				local bs = scrollThumb.AbsoluteSize.Y
				scrollThumb.Position = UDim2.new(0,0,self:GetScrollPercent()*(fs-bs)/fs,0)
			end
		end

		local function createFrame(self)
			local newFrame = createSimple("Frame",{Style=0,Active=true,AnchorPoint=Vector2.new(0,0),BackgroundColor3=Color3.new(0.35294118523598,0.35294118523598,0.35294118523598),BackgroundTransparency=0,BorderColor3=Color3.new(0.10588236153126,0.16470588743687,0.20784315466881),BorderSizePixel=0,ClipsDescendants=false,Draggable=false,Position=UDim2.new(1,-16,0,0),Rotation=0,Selectable=false,Size=UDim2.new(0,16,1,0),SizeConstraint=0,Visible=true,ZIndex=1,Name="ScrollBar",})
			local button1 = nil
			local button2 = nil

			if self.Horizontal then
				newFrame.Size = UDim2.new(1,0,0,16)
				button1 = createSimple("ImageButton",{
					Parent = newFrame,
					Name = "Left",
					Size = UDim2.new(0,16,0,16),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					AutoButtonColor = false
				})
				createArrow(16,4,"left").Parent = button1
				button2 = createSimple("ImageButton",{
					Parent = newFrame,
					Name = "Right",
					Position = UDim2.new(1,-16,0,0),
					Size = UDim2.new(0,16,0,16),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					AutoButtonColor = false
				})
				createArrow(16,4,"right").Parent = button2
			else
				newFrame.Size = UDim2.new(0,16,1,0)
				button1 = createSimple("ImageButton",{
					Parent = newFrame,
					Name = "Up",
					Size = UDim2.new(0,16,0,16),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					AutoButtonColor = false
				})
				createArrow(16,4,"up").Parent = button1
				button2 = createSimple("ImageButton",{
					Parent = newFrame,
					Name = "Down",
					Position = UDim2.new(0,0,1,-16),
					Size = UDim2.new(0,16,0,16),
					BackgroundTransparency = 1,
					BorderSizePixel = 0,
					AutoButtonColor = false
				})
				createArrow(16,4,"down").Parent = button2
			end

			local scrollThumbFrame = createSimple("Frame",{
				BackgroundTransparency = 1,
				Parent = newFrame
			})
			if self.Horizontal then
				scrollThumbFrame.Position = UDim2.new(0,16,0,0)
				scrollThumbFrame.Size = UDim2.new(1,-32,1,0)
			else
				scrollThumbFrame.Position = UDim2.new(0,0,0,16)
				scrollThumbFrame.Size = UDim2.new(1,0,1,-32)
			end

			local scrollThumb = createSimple("Frame",{
				BackgroundColor3 = Color3.new(120/255,120/255,120/255),
				BorderSizePixel = 0,
				Parent = scrollThumbFrame
			})

			local markerFrame = createSimple("Frame",{
				BackgroundTransparency = 1,
				Name = "Markers",
				Size = UDim2.new(1,0,1,0),
				Parent = scrollThumbFrame
			})

			local buttonPress = false
			local thumbPress = false
			local thumbFramePress = false

			--local thumbColor = Color3.new(120/255,120/255,120/255)
			--local thumbSelectColor = Color3.new(140/255,140/255,140/255)
			button1.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement and not buttonPress and self:CanScrollUp() then button1.BackgroundTransparency = 0.8 end
				if input.UserInputType ~= Enum.UserInputType.MouseButton1 or not self:CanScrollUp() then return end
				buttonPress = true
				button1.BackgroundTransparency = 0.5
				if self:CanScrollUp() then self:ScrollUp() self.Scrolled:Fire() end
				local buttonTick = tick()
				local releaseEvent
				releaseEvent = user.InputEnded:Connect(function(input)
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
					releaseEvent:Disconnect()
					if checkMouseInGui(button1) and self:CanScrollUp() then button1.BackgroundTransparency = 0.8 else button1.BackgroundTransparency = 1 end
					buttonPress = false
				end)
				while buttonPress do
					if tick() - buttonTick >= 0.3 and self:CanScrollUp() then
						self:ScrollUp()
						self.Scrolled:Fire()
					end
					wait()
				end
			end)
			button1.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement and not buttonPress then button1.BackgroundTransparency = 1 end
			end)
			button2.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement and not buttonPress and self:CanScrollDown() then button2.BackgroundTransparency = 0.8 end
				if input.UserInputType ~= Enum.UserInputType.MouseButton1 or not self:CanScrollDown() then return end
				buttonPress = true
				button2.BackgroundTransparency = 0.5
				if self:CanScrollDown() then self:ScrollDown() self.Scrolled:Fire() end
				local buttonTick = tick()
				local releaseEvent
				releaseEvent = user.InputEnded:Connect(function(input)
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
					releaseEvent:Disconnect()
					if checkMouseInGui(button2) and self:CanScrollDown() then button2.BackgroundTransparency = 0.8 else button2.BackgroundTransparency = 1 end
					buttonPress = false
				end)
				while buttonPress do
					if tick() - buttonTick >= 0.3 and self:CanScrollDown() then
						self:ScrollDown()
						self.Scrolled:Fire()
					end
					wait()
				end
			end)
			button2.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement and not buttonPress then button2.BackgroundTransparency = 1 end
			end)

			scrollThumb.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement and not thumbPress then scrollThumb.BackgroundTransparency = 0.2 scrollThumb.BackgroundColor3 = self.ThumbSelectColor end
				if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end

				local dir = self.Horizontal and "X" or "Y"
				local lastThumbPos = nil

				buttonPress = false
				thumbFramePress = false			
				thumbPress = true
				scrollThumb.BackgroundTransparency = 0
				local mouseOffset = mouse[dir] - scrollThumb.AbsolutePosition[dir]
				local mouseStart = mouse[dir]
				local releaseEvent
				local mouseEvent
				releaseEvent = user.InputEnded:Connect(function(input)
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
					releaseEvent:Disconnect()
					if mouseEvent then mouseEvent:Disconnect() end
					if checkMouseInGui(scrollThumb) then scrollThumb.BackgroundTransparency = 0.2 else scrollThumb.BackgroundTransparency = 0 scrollThumb.BackgroundColor3 = self.ThumbColor end
					thumbPress = false
				end)
				self:Update()

				mouseEvent = user.InputChanged:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement and thumbPress and releaseEvent.Connected then
						local thumbFrameSize = scrollThumbFrame.AbsoluteSize[dir]-scrollThumb.AbsoluteSize[dir]
						local pos = mouse[dir] - scrollThumbFrame.AbsolutePosition[dir] - mouseOffset
						if pos > thumbFrameSize then
							pos = thumbFrameSize
						elseif pos < 0 then
							pos = 0
						end
						if lastThumbPos ~= pos then
							lastThumbPos = pos
							self:ScrollTo(math.floor(0.5+pos/thumbFrameSize*(self.TotalSpace-self.VisibleSpace)))
						end
						wait()
					end
				end)
			end)
			scrollThumb.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement and not thumbPress then scrollThumb.BackgroundTransparency = 0 scrollThumb.BackgroundColor3 = self.ThumbColor end
			end)
			scrollThumbFrame.InputBegan:Connect(function(input)
				if input.UserInputType ~= Enum.UserInputType.MouseButton1 or checkMouseInGui(scrollThumb) then return end

				local dir = self.Horizontal and "X" or "Y"
				local scrollDir = 0
				if mouse[dir] >= scrollThumb.AbsolutePosition[dir] + scrollThumb.AbsoluteSize[dir] then
					scrollDir = 1
				end

				local function doTick()
					local scrollSize = self.VisibleSpace - 1
					if scrollDir == 0 and mouse[dir] < scrollThumb.AbsolutePosition[dir] then
						self:ScrollTo(self.Index - scrollSize)
					elseif scrollDir == 1 and mouse[dir] >= scrollThumb.AbsolutePosition[dir] + scrollThumb.AbsoluteSize[dir] then
						self:ScrollTo(self.Index + scrollSize)
					end
				end

				thumbPress = false			
				thumbFramePress = true
				doTick()
				local thumbFrameTick = tick()
				local releaseEvent
				releaseEvent = user.InputEnded:Connect(function(input)
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
					releaseEvent:Disconnect()
					thumbFramePress = false
				end)
				while thumbFramePress do
					if tick() - thumbFrameTick >= 0.3 and checkMouseInGui(scrollThumbFrame) then
						doTick()
					end
					wait()
				end
			end)

			newFrame.MouseWheelForward:Connect(function()
				self:ScrollTo(self.Index - self.WheelIncrement)
			end)

			newFrame.MouseWheelBackward:Connect(function()
				self:ScrollTo(self.Index + self.WheelIncrement)
			end)

			self.GuiElems.ScrollThumb = scrollThumb
			self.GuiElems.ScrollThumbFrame = scrollThumbFrame
			self.GuiElems.Button1 = button1
			self.GuiElems.Button2 = button2
			self.GuiElems.MarkerFrame = markerFrame

			return newFrame
		end

		funcs.Update = function(self,nocallback)
			local total = self.TotalSpace
			local visible = self.VisibleSpace
			local index = self.Index
			local button1 = self.GuiElems.Button1
			local button2 = self.GuiElems.Button2

			self.Index = math.clamp(self.Index,0,math.max(0,total-visible))

			if self.LastTotalSpace ~= self.TotalSpace then
				self.LastTotalSpace = self.TotalSpace
				self:UpdateMarkers()
			end

			if self:CanScrollUp() then
				for i,v in pairs(button1.Arrow:GetChildren()) do
					v.BackgroundTransparency = 0
				end
			else
				button1.BackgroundTransparency = 1
				for i,v in pairs(button1.Arrow:GetChildren()) do
					v.BackgroundTransparency = 0.5
				end
			end
			if self:CanScrollDown() then
				for i,v in pairs(button2.Arrow:GetChildren()) do
					v.BackgroundTransparency = 0
				end
			else
				button2.BackgroundTransparency = 1
				for i,v in pairs(button2.Arrow:GetChildren()) do
					v.BackgroundTransparency = 0.5
				end
			end

			drawThumb(self)
		end

		funcs.UpdateMarkers = function(self)
			local markerFrame = self.GuiElems.MarkerFrame
			markerFrame:ClearAllChildren()

			for i,v in pairs(self.Markers) do
				if i < self.TotalSpace then
					createSimple("Frame",{
						BackgroundTransparency = 0,
						BackgroundColor3 = v,
						BorderSizePixel = 0,
						Position = self.Horizontal and UDim2.new(i/self.TotalSpace,0,1,-6) or UDim2.new(1,-6,i/self.TotalSpace,0),
						Size = self.Horizontal and UDim2.new(0,1,0,6) or UDim2.new(0,6,0,1),
						Name = "Marker"..tostring(i),
						Parent = markerFrame
					})
				end
			end
		end

		funcs.AddMarker = function(self,ind,color)
			self.Markers[ind] = color or Color3.new(0,0,0)
		end
		funcs.ScrollTo = function(self,ind,nocallback)
			self.Index = ind
			self:Update()
			if not nocallback then
				self.Scrolled:Fire()
			end
		end
		funcs.ScrollUp = function(self)
			self.Index = self.Index - self.Increment
			self:Update()
		end
		funcs.ScrollDown = function(self)
			self.Index = self.Index + self.Increment
			self:Update()
		end
		funcs.CanScrollUp = function(self)
			return self.Index > 0
		end
		funcs.CanScrollDown = function(self)
			return self.Index + self.VisibleSpace < self.TotalSpace
		end
		funcs.GetScrollPercent = function(self)
			return self.Index/(self.TotalSpace-self.VisibleSpace)
		end
		funcs.SetScrollPercent = function(self,perc)
			self.Index = math.floor(perc*(self.TotalSpace-self.VisibleSpace))
			self:Update()
		end

		funcs.Texture = function(self,data)
			self.ThumbColor = data.ThumbColor or Color3.new(0,0,0)
			self.ThumbSelectColor = data.ThumbSelectColor or Color3.new(0,0,0)
			self.GuiElems.ScrollThumb.BackgroundColor3 = data.ThumbColor or Color3.new(0,0,0)
			self.Gui.BackgroundColor3 = data.FrameColor or Color3.new(0,0,0)
			self.GuiElems.Button1.BackgroundColor3 = data.ButtonColor or Color3.new(0,0,0)
			self.GuiElems.Button2.BackgroundColor3 = data.ButtonColor or Color3.new(0,0,0)
			for i,v in pairs(self.GuiElems.Button1.Arrow:GetChildren()) do
				v.BackgroundColor3 = data.ArrowColor or Color3.new(0,0,0)
			end
			for i,v in pairs(self.GuiElems.Button2.Arrow:GetChildren()) do
				v.BackgroundColor3 = data.ArrowColor or Color3.new(0,0,0)
			end
		end

		funcs.SetScrollFrame = function(self,frame)
			if self.ScrollUpEvent then self.ScrollUpEvent:Disconnect() self.ScrollUpEvent = nil end
			if self.ScrollDownEvent then self.ScrollDownEvent:Disconnect() self.ScrollDownEvent = nil end
			self.ScrollUpEvent = frame.MouseWheelForward:Connect(function() self:ScrollTo(self.Index - self.WheelIncrement) end)
			self.ScrollDownEvent = frame.MouseWheelBackward:Connect(function() self:ScrollTo(self.Index + self.WheelIncrement) end)
		end

		local mt = {}
		mt.__index = funcs

		local function new(hor)
			local obj = setmetatable({
				Index = 0,
				VisibleSpace = 0,
				TotalSpace = 0,
				Increment = 1,
				WheelIncrement = 1,
				Markers = {},
				GuiElems = {},
				Horizontal = hor,
				LastTotalSpace = 0,
				Scrolled = Lib.Signal.new()
			},mt)
			obj.Gui = createFrame(obj)
			obj:Texture({
				ThumbColor = Color3.fromRGB(60,60,60),
				ThumbSelectColor = Color3.fromRGB(75,75,75),
				ArrowColor = Color3.new(1,1,1),
				FrameColor = Color3.fromRGB(40,40,40),
				ButtonColor = Color3.fromRGB(75,75,75)
			})
			return obj
		end

		return {new = new}
	end)()

	Lib.Window = (function()
		local funcs = {}
		local static = {MinWidth = 200, FreeWidth = 200}
		local mouse = plr:GetMouse()
		local sidesGui,alignIndicator
		local visibleWindows = {}
		local leftSide = {Width = 300, Windows = {}, ResizeCons = {}, Hidden = true}
		local rightSide = {Width = 300, Windows = {}, ResizeCons = {}, Hidden = true}

		local displayOrderStart
		local sideDisplayOrder
		local sideTweenInfo = TweenInfo.new(0.3,Enum.EasingStyle.Quad,Enum.EasingDirection.Out)
		local tweens = {}
		local isA = game.IsA

		local theme = {
			MainColor1 = Color3.fromRGB(52,52,52),
			MainColor2 = Color3.fromRGB(45,45,45),
			Button = Color3.fromRGB(60,60,60)
		}

		local function stopTweens()
			for i = 1,#tweens do
				tweens[i]:Cancel()
			end
			tweens = {}
		end

		local function resizeHook(self,resizer,dir)
			local guiMain = self.GuiElems.Main
			resizer.InputBegan:Connect(function(input)
				if not self.Dragging and not self.Resizing and self.Resizable and self.ResizableInternal then
					local isH = dir:find("[WE]") and true
					local isV = dir:find("[NS]") and true
					local signX = dir:find("W",1,true) and -1 or 1
					local signY = dir:find("N",1,true) and -1 or 1

					if self.Minimized and isV then return end

					if input.UserInputType == Enum.UserInputType.MouseMovement then
						resizer.BackgroundTransparency = 0.5
					elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
						local releaseEvent,mouseEvent

						local offX = mouse.X - resizer.AbsolutePosition.X
						local offY = mouse.Y - resizer.AbsolutePosition.Y

						self.Resizing = resizer
						resizer.BackgroundTransparency = 1

						releaseEvent = service.UserInputService.InputEnded:Connect(function(input)
							if input.UserInputType == Enum.UserInputType.MouseButton1 then
								releaseEvent:Disconnect()
								mouseEvent:Disconnect()
								self.Resizing = false
								resizer.BackgroundTransparency = 1
							end
						end)

						mouseEvent = service.UserInputService.InputChanged:Connect(function(input)
							if self.Resizable and self.ResizableInternal and input.UserInputType == Enum.UserInputType.MouseMovement then
								self:StopTweens()
								local deltaX = input.Position.X - resizer.AbsolutePosition.X - offX
								local deltaY = input.Position.Y - resizer.AbsolutePosition.Y - offY

								if guiMain.AbsoluteSize.X + deltaX*signX < self.MinX then deltaX = signX*(self.MinX - guiMain.AbsoluteSize.X) end
								if guiMain.AbsoluteSize.Y + deltaY*signY < self.MinY then deltaY = signY*(self.MinY - guiMain.AbsoluteSize.Y) end
								if signY < 0 and guiMain.AbsolutePosition.Y + deltaY < 0 then deltaY = -guiMain.AbsolutePosition.Y end

								guiMain.Position = guiMain.Position + UDim2.new(0,(signX < 0 and deltaX or 0),0,(signY < 0 and deltaY or 0))
								self.SizeX = self.SizeX + (isH and deltaX*signX or 0)
								self.SizeY = self.SizeY + (isV and deltaY*signY or 0)
								guiMain.Size = UDim2.new(0,self.SizeX,0,self.Minimized and 20 or self.SizeY)

								--if isH then self.SizeX = guiMain.AbsoluteSize.X end
								--if isV then self.SizeY = guiMain.AbsoluteSize.Y end
							end
						end)
					end
				end
			end)

			resizer.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement and self.Resizing ~= resizer then
					resizer.BackgroundTransparency = 1
				end
			end)
		end

		local updateWindows

		local function moveToTop(window)
			local found = table.find(visibleWindows,window)
			if found then
				table.remove(visibleWindows,found)
				table.insert(visibleWindows,1,window)
				updateWindows()
			end
		end

		local function sideHasRoom(side,neededSize)
			local maxY = sidesGui.AbsoluteSize.Y - (math.max(0,#side.Windows - 1) * 4)
			local inc = 0
			for i,v in pairs(side.Windows) do
				inc = inc + (v.MinY or 100)
				if inc > maxY - neededSize then return false end
			end

			return true
		end

		local function getSideInsertPos(side,curY)
			local pos = #side.Windows + 1
			local range = {0,sidesGui.AbsoluteSize.Y}

			for i,v in pairs(side.Windows) do
				local midPos = v.PosY + v.SizeY/2
				if curY <= midPos then
					pos = i
					range[2] = midPos
					break
				else
					range[1] = midPos
				end
			end

			return pos,range
		end

		local function focusInput(self,obj)
			if isA(obj,"GuiButton") then
				obj.MouseButton1Down:Connect(function()
					moveToTop(self)
				end)
			elseif isA(obj,"TextBox") then
				obj.Focused:Connect(function()
					moveToTop(self)
				end)
			end
		end

		local createGui = function(self)
			local gui = create({
				{1,"ScreenGui",{Name="Window",}},
				{2,"Frame",{Active=true,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="Main",Parent={1},Position=UDim2.new(0.40000000596046,0,0.40000000596046,0),Size=UDim2.new(0,300,0,300),}},
				{3,"Frame",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderSizePixel=0,Name="Content",Parent={2},Position=UDim2.new(0,0,0,20),Size=UDim2.new(1,0,1,-20),ClipsDescendants=true}},
				{4,"Frame",{BackgroundColor3=Color3.fromRGB(33,33,33),BorderSizePixel=0,Name="Line",Parent={3},Size=UDim2.new(1,0,0,1),}},
				{5,"Frame",{BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BorderSizePixel=0,Name="TopBar",Parent={2},Size=UDim2.new(1,0,0,20),}},
				{6,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={5},Position=UDim2.new(0,5,0,0),Size=UDim2.new(1,-10,0,20),Text="Window",TextColor3=Color3.new(1,1,1),TextSize=14,TextXAlignment=0,}},
				{7,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Close",Parent={5},Position=UDim2.new(1,-18,0,2),Size=UDim2.new(0,16,0,16),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,}},
				{8,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5054663650",Parent={7},Position=UDim2.new(0,3,0,3),Size=UDim2.new(0,10,0,10),}},
				{9,"UICorner",{CornerRadius=UDim.new(0,4),Parent={7},}},
				{10,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Minimize",Parent={5},Position=UDim2.new(1,-36,0,2),Size=UDim2.new(0,16,0,16),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,}},
				{11,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://5034768003",Parent={10},Position=UDim2.new(0,3,0,3),Size=UDim2.new(0,10,0,10),}},
				{12,"UICorner",{CornerRadius=UDim.new(0,4),Parent={10},}},
				{13,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Image="rbxassetid://1427967925",Name="Outlines",Parent={2},Position=UDim2.new(0,-5,0,-5),ScaleType=1,Size=UDim2.new(1,10,1,10),SliceCenter=Rect.new(6,6,25,25),TileSize=UDim2.new(0,20,0,20),}},
				{14,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Name="ResizeControls",Parent={2},Position=UDim2.new(0,-5,0,-5),Size=UDim2.new(1,10,1,10),}},
				{15,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.27450981736183,0.27450981736183,0.27450981736183),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="North",Parent={14},Position=UDim2.new(0,5,0,0),Size=UDim2.new(1,-10,0,5),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{16,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.27450981736183,0.27450981736183,0.27450981736183),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="South",Parent={14},Position=UDim2.new(0,5,1,-5),Size=UDim2.new(1,-10,0,5),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{17,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.27450981736183,0.27450981736183,0.27450981736183),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="NorthEast",Parent={14},Position=UDim2.new(1,-5,0,0),Size=UDim2.new(0,5,0,5),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{18,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.27450981736183,0.27450981736183,0.27450981736183),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="East",Parent={14},Position=UDim2.new(1,-5,0,5),Size=UDim2.new(0,5,1,-10),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{19,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.27450981736183,0.27450981736183,0.27450981736183),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="West",Parent={14},Position=UDim2.new(0,0,0,5),Size=UDim2.new(0,5,1,-10),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{20,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.27450981736183,0.27450981736183,0.27450981736183),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="SouthEast",Parent={14},Position=UDim2.new(1,-5,1,-5),Size=UDim2.new(0,5,0,5),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{21,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.27450981736183,0.27450981736183,0.27450981736183),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="NorthWest",Parent={14},Size=UDim2.new(0,5,0,5),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{22,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.27450981736183,0.27450981736183,0.27450981736183),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="SouthWest",Parent={14},Position=UDim2.new(0,0,1,-5),Size=UDim2.new(0,5,0,5),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
			})

			local guiMain = gui.Main
			local guiTopBar = guiMain.TopBar
			local guiResizeControls = guiMain.ResizeControls

			self.GuiElems.Main = guiMain
			self.GuiElems.TopBar = guiMain.TopBar
			self.GuiElems.Content = guiMain.Content
			self.GuiElems.Line = guiMain.Content.Line
			self.GuiElems.Outlines = guiMain.Outlines
			self.GuiElems.Title = guiTopBar.Title
			self.GuiElems.Close = guiTopBar.Close
			self.GuiElems.Minimize = guiTopBar.Minimize
			self.GuiElems.ResizeControls = guiResizeControls
			self.ContentPane = guiMain.Content

			guiTopBar.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 and self.Draggable then
					local releaseEvent,mouseEvent

					local maxX = sidesGui.AbsoluteSize.X
					local initX = guiMain.AbsolutePosition.X
					local initY = guiMain.AbsolutePosition.Y
					local offX = mouse.X - initX
					local offY = mouse.Y - initY

					local alignInsertPos,alignInsertSide

					guiDragging = true

					releaseEvent = cloneref(game:GetService("UserInputService")).InputEnded:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseButton1 then
							releaseEvent:Disconnect()
							mouseEvent:Disconnect()
							guiDragging = false
							alignIndicator.Parent = nil
							if alignInsertSide then
								local targetSide = (alignInsertSide == "left" and leftSide) or (alignInsertSide == "right" and rightSide)
								self:AlignTo(targetSide,alignInsertPos)
							end
						end
					end)

					mouseEvent = cloneref(game:GetService("UserInputService")).InputChanged:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseMovement and self.Draggable and not self.Closed then
							if self.Aligned then
								if leftSide.Resizing or rightSide.Resizing then return end
								local posX,posY = input.Position.X-offX,input.Position.Y-offY
								local delta = math.sqrt((posX-initX)^2 + (posY-initY)^2)
								if delta >= 5 then
									self:SetAligned(false)
								end
							else
								local inputX,inputY = input.Position.X,input.Position.Y
								local posX,posY = inputX-offX,inputY-offY
								if posY < 0 then posY = 0 end
								guiMain.Position = UDim2.new(0,posX,0,posY)

								if self.Resizable and self.Alignable then
									if inputX < 25 then
										if sideHasRoom(leftSide,self.MinY or 100) then
											local insertPos,range = getSideInsertPos(leftSide,inputY)
											alignIndicator.Indicator.Position = UDim2.new(0,-15,0,range[1])
											alignIndicator.Indicator.Size = UDim2.new(0,40,0,range[2]-range[1])
											Lib.ShowGui(alignIndicator)
											alignInsertPos = insertPos
											alignInsertSide = "left"
											return
										end
									elseif inputX >= maxX - 25 then
										if sideHasRoom(rightSide,self.MinY or 100) then
											local insertPos,range = getSideInsertPos(rightSide,inputY)
											alignIndicator.Indicator.Position = UDim2.new(0,maxX-25,0,range[1])
											alignIndicator.Indicator.Size = UDim2.new(0,40,0,range[2]-range[1])
											Lib.ShowGui(alignIndicator)
											alignInsertPos = insertPos
											alignInsertSide = "right"
											return
										end
									end
								end
								alignIndicator.Parent = nil
								alignInsertPos = nil
								alignInsertSide = nil
							end
						end
					end)
				end
			end)

			guiTopBar.Close.MouseButton1Click:Connect(function()
				if self.Closed then return end
				self:Close()
			end)

			guiTopBar.Minimize.MouseButton1Click:Connect(function()
				if self.Closed then return end
				if self.Aligned then
					self:SetAligned(false)
				else
					self:SetMinimized()
				end
			end)

			guiTopBar.Minimize.MouseButton2Click:Connect(function()
				if self.Closed then return end
				if not self.Aligned then
					self:SetMinimized(nil,2)
					guiTopBar.Minimize.BackgroundTransparency = 1
				end
			end)

			guiMain.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 and not self.Aligned and not self.Closed then
					moveToTop(self)
				end
			end)

			guiMain:GetPropertyChangedSignal("AbsolutePosition"):Connect(function()
				local absPos = guiMain.AbsolutePosition
				self.PosX = absPos.X
				self.PosY = absPos.Y
			end)

			resizeHook(self,guiResizeControls.North,"N")
			resizeHook(self,guiResizeControls.NorthEast,"NE")
			resizeHook(self,guiResizeControls.East,"E")
			resizeHook(self,guiResizeControls.SouthEast,"SE")
			resizeHook(self,guiResizeControls.South,"S")
			resizeHook(self,guiResizeControls.SouthWest,"SW")
			resizeHook(self,guiResizeControls.West,"W")
			resizeHook(self,guiResizeControls.NorthWest,"NW")

			guiMain.Size = UDim2.new(0,self.SizeX,0,self.SizeY)

			gui.DescendantAdded:Connect(function(obj) focusInput(self,obj) end)
			local descs = gui:GetDescendants()
			for i = 1,#descs do
				focusInput(self,descs[i])
			end

			self.MinimizeAnim = Lib.ButtonAnim(guiTopBar.Minimize)
			self.CloseAnim = Lib.ButtonAnim(guiTopBar.Close)

			return gui
		end

		local function updateSideFrames(noTween)
			stopTweens()
			leftSide.Frame.Size = UDim2.new(0,leftSide.Width,1,0)
			rightSide.Frame.Size = UDim2.new(0,rightSide.Width,1,0)
			leftSide.Frame.Resizer.Position = UDim2.new(0,leftSide.Width,0,0)
			rightSide.Frame.Resizer.Position = UDim2.new(0,-5,0,0)

			--leftSide.Frame.Visible = (#leftSide.Windows > 0)
			--rightSide.Frame.Visible = (#rightSide.Windows > 0)

			--[[if #leftSide.Windows > 0 and leftSide.Frame.Position == UDim2.new(0,-leftSide.Width-5,0,0) then
				leftSide.Frame:TweenPosition(UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.3,true)
			elseif #leftSide.Windows == 0 and leftSide.Frame.Position == UDim2.new(0,0,0,0) then
				leftSide.Frame:TweenPosition(UDim2.new(0,-leftSide.Width-5,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.3,true)
			end
			local rightTweenPos = (#rightSide.Windows == 0 and UDim2.new(1,5,0,0) or UDim2.new(1,-rightSide.Width,0,0))
			rightSide.Frame:TweenPosition(rightTweenPos,Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.3,true)]]
			local leftHidden = #leftSide.Windows == 0 or leftSide.Hidden
			local rightHidden = #rightSide.Windows == 0 or rightSide.Hidden
			local leftPos = (leftHidden and UDim2.new(0,-leftSide.Width-10,0,0) or UDim2.new(0,0,0,0))
			local rightPos = (rightHidden and UDim2.new(1,10,0,0) or UDim2.new(1,-rightSide.Width,0,0))

			sidesGui.LeftToggle.Text = leftHidden and ">" or "<"
			sidesGui.RightToggle.Text = rightHidden and "<" or ">"

			if not noTween then
				local function insertTween(...)
					local tween = service.TweenService:Create(...)
					tweens[#tweens+1] = tween
					tween:Play()
				end
				insertTween(leftSide.Frame,sideTweenInfo,{Position = leftPos})
				insertTween(rightSide.Frame,sideTweenInfo,{Position = rightPos})
				insertTween(sidesGui.LeftToggle,sideTweenInfo,{Position = UDim2.new(0,#leftSide.Windows == 0 and -16 or 0,0,-36)})
				insertTween(sidesGui.RightToggle,sideTweenInfo,{Position = UDim2.new(1,#rightSide.Windows == 0 and 0 or -16,0,-36)})
			else
				leftSide.Frame.Position = leftPos
				rightSide.Frame.Position = rightPos
				sidesGui.LeftToggle.Position = UDim2.new(0,#leftSide.Windows == 0 and -16 or 0,0,-36)
				sidesGui.RightToggle.Position = UDim2.new(1,#rightSide.Windows == 0 and 0 or -16,0,-36)
			end
		end

		local function getSideFramePos(side)
			local leftHidden = #leftSide.Windows == 0 or leftSide.Hidden
			local rightHidden = #rightSide.Windows == 0 or rightSide.Hidden
			if side == leftSide then
				return (leftHidden and UDim2.new(0,-leftSide.Width-10,0,0) or UDim2.new(0,0,0,0))
			else
				return (rightHidden and UDim2.new(1,10,0,0) or UDim2.new(1,-rightSide.Width,0,0))
			end
		end

		local function sideResized(side)
			local currentPos = 0
			local sideFramePos = getSideFramePos(side)
			for i,v in pairs(side.Windows) do
				v.SizeX = side.Width
				v.GuiElems.Main.Size = UDim2.new(0,side.Width,0,v.SizeY)
				v.GuiElems.Main.Position = UDim2.new(sideFramePos.X.Scale,sideFramePos.X.Offset,0,currentPos)
				currentPos = currentPos + v.SizeY+4
			end
		end

		local function sideResizerHook(resizer,dir,side,pos)
			local mouse = Main.Mouse
			local windows = side.Windows

			resizer.InputBegan:Connect(function(input)
				if not side.Resizing then
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						resizer.BackgroundColor3 = theme.MainColor2
					elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
						local releaseEvent,mouseEvent

						local offX = mouse.X - resizer.AbsolutePosition.X
						local offY = mouse.Y - resizer.AbsolutePosition.Y

						side.Resizing = resizer
						resizer.BackgroundColor3 = theme.MainColor2

						releaseEvent = service.UserInputService.InputEnded:Connect(function(input)
							if input.UserInputType == Enum.UserInputType.MouseButton1 then
								releaseEvent:Disconnect()
								mouseEvent:Disconnect()
								side.Resizing = false
								resizer.BackgroundColor3 = theme.Button
							end
						end)

						mouseEvent = service.UserInputService.InputChanged:Connect(function(input)
							if not resizer.Parent then
								releaseEvent:Disconnect()
								mouseEvent:Disconnect()
								side.Resizing = false
								return
							end
							if input.UserInputType == Enum.UserInputType.MouseMovement then
								if dir == "V" then
									local delta = input.Position.Y - resizer.AbsolutePosition.Y - offY

									if delta > 0 then
										local neededSize = delta
										for i = pos+1,#windows do
											local window = windows[i]
											local newSize = math.max(window.SizeY-neededSize,(window.MinY or 100))
											neededSize = neededSize - (window.SizeY - newSize)
											window.SizeY = newSize
										end
										windows[pos].SizeY = windows[pos].SizeY + math.max(0,delta-neededSize)
									else
										local neededSize = -delta
										for i = pos,1,-1 do
											local window = windows[i]
											local newSize = math.max(window.SizeY-neededSize,(window.MinY or 100))
											neededSize = neededSize - (window.SizeY - newSize)
											window.SizeY = newSize
										end
										windows[pos+1].SizeY = windows[pos+1].SizeY + math.max(0,-delta-neededSize)
									end

									updateSideFrames()
									sideResized(side)
								elseif dir == "H" then
									local maxWidth = math.max(300,sidesGui.AbsoluteSize.X-static.FreeWidth)
									local otherSide = (side == leftSide and rightSide or leftSide)
									local delta = input.Position.X - resizer.AbsolutePosition.X - offX
									delta = (side == leftSide and delta or -delta)

									local proposedSize = math.max(static.MinWidth,side.Width + delta)
									if proposedSize + otherSide.Width <= maxWidth then
										side.Width = proposedSize
									else
										local newOtherSize = maxWidth - proposedSize
										if newOtherSize >= static.MinWidth then
											side.Width = proposedSize
											otherSide.Width = newOtherSize
										else
											side.Width = maxWidth - static.MinWidth
											otherSide.Width = static.MinWidth
										end
									end

									updateSideFrames(true)
									sideResized(side)
									sideResized(otherSide)
								end
							end
						end)
					end
				end
			end)

			resizer.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement and side.Resizing ~= resizer then
					resizer.BackgroundColor3 = theme.Button
				end
			end)
		end

		local function renderSide(side,noTween) -- TODO: Use existing resizers
			local currentPos = 0
			local sideFramePos = getSideFramePos(side)
			local template = side.WindowResizer:Clone()
			for i,v in pairs(side.ResizeCons) do v:Disconnect() end
			for i,v in pairs(side.Frame:GetChildren()) do if v.Name == "WindowResizer" then v:Destroy() end end
			side.ResizeCons = {}
			side.Resizing = nil

			for i,v in pairs(side.Windows) do
				v.SidePos = i
				local isEnd = i == #side.Windows
				local size = UDim2.new(0,side.Width,0,v.SizeY)
				local pos = UDim2.new(sideFramePos.X.Scale,sideFramePos.X.Offset,0,currentPos)
				Lib.ShowGui(v.Gui)
				--v.GuiElems.Main:TweenSizeAndPosition(size,pos,Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.3,true)
				if noTween then
					v.GuiElems.Main.Size = size
					v.GuiElems.Main.Position = pos
				else
					local tween = service.TweenService:Create(v.GuiElems.Main,sideTweenInfo,{Size = size, Position = pos})
					tweens[#tweens+1] = tween
					tween:Play()
				end
				currentPos = currentPos + v.SizeY+4

				if not isEnd then
					local newTemplate = template:Clone()
					newTemplate.Position = UDim2.new(1,-side.Width,0,currentPos-4)
					side.ResizeCons[#side.ResizeCons+1] = v.Gui.Main:GetPropertyChangedSignal("Size"):Connect(function()
						newTemplate.Position = UDim2.new(1,-side.Width,0, v.GuiElems.Main.Position.Y.Offset + v.GuiElems.Main.Size.Y.Offset)
					end)
					side.ResizeCons[#side.ResizeCons+1] = v.Gui.Main:GetPropertyChangedSignal("Position"):Connect(function()
						newTemplate.Position = UDim2.new(1,-side.Width,0, v.GuiElems.Main.Position.Y.Offset + v.GuiElems.Main.Size.Y.Offset)
					end)
					sideResizerHook(newTemplate,"V",side,i)
					newTemplate.Parent = side.Frame
				end
			end

			--side.Frame.Back.Position = UDim2.new(0,0,0,0)
			--side.Frame.Back.Size = UDim2.new(0,side.Width,1,0)
		end

		local function updateSide(side,noTween)
			local oldHeight = 0
			local currentPos = 0
			local neededSize = 0
			local windows = side.Windows
			local height = sidesGui.AbsoluteSize.Y - (math.max(0,#windows - 1) * 4)

			for i,v in pairs(windows) do oldHeight = oldHeight + v.SizeY end
			for i,v in pairs(windows) do
				if i == #windows then
					v.SizeY = height-currentPos
					neededSize = math.max(0,(v.MinY or 100)-v.SizeY)
				else
					v.SizeY = math.max(math.floor(v.SizeY/oldHeight*height),v.MinY or 100)
				end
				currentPos = currentPos + v.SizeY
			end

			if neededSize > 0 then
				for i = #windows-1,1,-1 do
					local window = windows[i]
					local newSize = math.max(window.SizeY-neededSize,(window.MinY or 100))
					neededSize = neededSize - (window.SizeY - newSize)
					window.SizeY = newSize
				end
				local lastWindow = windows[#windows]
				lastWindow.SizeY = (lastWindow.MinY or 100)-neededSize
			end
			renderSide(side,noTween)
		end

		updateWindows = function(noTween)
			updateSideFrames(noTween)
			updateSide(leftSide,noTween)
			updateSide(rightSide,noTween)
			local count = 0
			for i = #visibleWindows,1,-1 do
				visibleWindows[i].Gui.DisplayOrder = displayOrderStart + count
				Lib.ShowGui(visibleWindows[i].Gui)
				count = count + 1
			end

			--[[local leftTweenPos = (#leftSide.Windows == 0 and UDim2.new(0,-leftSide.Width-5,0,0) or UDim2.new(0,0,0,0))
			leftSide.Frame:TweenPosition(leftTweenPos,Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.3,true)
			local rightTweenPos = (#rightSide.Windows == 0 and UDim2.new(1,5,0,0) or UDim2.new(1,-rightSide.Width,0,0))
			rightSide.Frame:TweenPosition(rightTweenPos,Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.3,true)]]
		end

		funcs.SetMinimized = function(self,set,mode)
			local oldVal = self.Minimized
			local newVal
			if set == nil then newVal = not self.Minimized else newVal = set end
			self.Minimized = newVal
			if not mode then mode = 1 end

			local resizeControls = self.GuiElems.ResizeControls
			local minimizeControls = {"North","NorthEast","NorthWest","South","SouthEast","SouthWest"}
			for i = 1,#minimizeControls do
				local control = resizeControls:FindFirstChild(minimizeControls[i])
				if control then control.Visible = not newVal end
			end

			if mode == 1 or mode == 2 then
				self:StopTweens()
				if mode == 1 then
					self.GuiElems.Main:TweenSize(UDim2.new(0,self.SizeX,0,newVal and 20 or self.SizeY),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.25,true)
				else
					local maxY = sidesGui.AbsoluteSize.Y
					local newPos = UDim2.new(0,self.PosX,0,newVal and math.min(maxY-20,self.PosY + self.SizeY - 20) or math.max(0,self.PosY - self.SizeY + 20))

					self.GuiElems.Main:TweenPosition(newPos,Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.25,true)
					self.GuiElems.Main:TweenSize(UDim2.new(0,self.SizeX,0,newVal and 20 or self.SizeY),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.25,true)
				end
				self.GuiElems.Minimize.ImageLabel.Image = newVal and "rbxassetid://5060023708" or "rbxassetid://5034768003"
			end

			if oldVal ~= newVal then
				if newVal then
					self.OnMinimize:Fire()
				else
					self.OnRestore:Fire()
				end
			end
		end

		funcs.Resize = function(self,sizeX,sizeY)
			self.SizeX = sizeX or self.SizeX
			self.SizeY = sizeY or self.SizeY
			self.GuiElems.Main.Size = UDim2.new(0,self.SizeX,0,self.SizeY)
		end

		funcs.SetSize = funcs.Resize

		funcs.SetTitle = function(self,title)
			self.GuiElems.Title.Text = title
		end

		funcs.SetResizable = function(self,val)
			self.Resizable = val
			self.GuiElems.ResizeControls.Visible = self.Resizable and self.ResizableInternal
		end

		funcs.SetResizableInternal = function(self,val)
			self.ResizableInternal = val
			self.GuiElems.ResizeControls.Visible = self.Resizable and self.ResizableInternal
		end

		funcs.SetAligned = function(self,val)
			self.Aligned = val
			self:SetResizableInternal(not val)
			self.GuiElems.Main.Active = not val
			self.GuiElems.Main.Outlines.Visible = not val
			if not val then
				for i,v in pairs(leftSide.Windows) do if v == self then table.remove(leftSide.Windows,i) break end end
				for i,v in pairs(rightSide.Windows) do if v == self then table.remove(rightSide.Windows,i) break end end
				if not table.find(visibleWindows,self) then table.insert(visibleWindows,1,self) end
				self.GuiElems.Minimize.ImageLabel.Image = "rbxassetid://5034768003"
				self.Side = nil
				updateWindows()
			else
				self:SetMinimized(false,3)
				for i,v in pairs(visibleWindows) do if v == self then table.remove(visibleWindows,i) break end end
				self.GuiElems.Minimize.ImageLabel.Image = "rbxassetid://5448127505"
			end
		end

		funcs.Add = function(self,obj,name)
			if type(obj) == "table" and obj.Gui and obj.Gui:IsA("GuiObject") then
				obj.Gui.Parent = self.ContentPane
			else
				obj.Parent = self.ContentPane
			end
			if name then self.Elements[name] = obj end
		end

		funcs.GetElement = function(self,obj,name)
			return self.Elements[name]
		end

		funcs.AlignTo = function(self,side,pos,size,silent)
			if table.find(side.Windows,self) or self.Closed then return end

			size = size or self.SizeY
			if size > 0 and size <= 1 then
				local totalSideHeight = 0
				for i,v in pairs(side.Windows) do totalSideHeight = totalSideHeight + v.SizeY end
				self.SizeY = (totalSideHeight > 0 and totalSideHeight * size * 2) or size
			else
				self.SizeY = (size > 0 and size or 100)
			end

			self:SetAligned(true)
			self.Side = side
			self.SizeX = side.Width
			self.Gui.DisplayOrder = sideDisplayOrder + 1
			for i,v in pairs(side.Windows) do v.Gui.DisplayOrder = sideDisplayOrder end
			pos = math.min(#side.Windows+1, pos or 1)
			self.SidePos = pos
			table.insert(side.Windows, pos, self)

			if not silent then
				side.Hidden = false
			end
			-- updateWindows(silent)
		end

		funcs.Close = function(self)
			self.Closed = true
			self:SetResizableInternal(false)

			Lib.FindAndRemove(leftSide.Windows,self)
			Lib.FindAndRemove(rightSide.Windows,self)
			Lib.FindAndRemove(visibleWindows,self)

			self.MinimizeAnim.Disable()
			self.CloseAnim.Disable()
			self.ClosedSide = self.Side
			self.Side = nil
			self.OnDeactivate:Fire()

			if not self.Aligned then
				self:StopTweens()
				local ti = TweenInfo.new(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.Out)

				local closeTime = tick()
				self.LastClose = closeTime

				self:DoTween(self.GuiElems.Main,ti,{Size = UDim2.new(0,self.SizeX,0,20)})
				self:DoTween(self.GuiElems.Title,ti,{TextTransparency = 1})
				self:DoTween(self.GuiElems.Minimize.ImageLabel,ti,{ImageTransparency = 1})
				self:DoTween(self.GuiElems.Close.ImageLabel,ti,{ImageTransparency = 1})
				Lib.FastWait(0.2)
				if closeTime ~= self.LastClose then return end

				self:DoTween(self.GuiElems.TopBar,ti,{BackgroundTransparency = 1})
				self:DoTween(self.GuiElems.Outlines,ti,{ImageTransparency = 1})
				Lib.FastWait(0.2)
				if closeTime ~= self.LastClose then return end
			end

			self.Aligned = false
			self.Gui.Parent = nil
			updateWindows(true)
		end

		funcs.Hide = funcs.Close

		funcs.IsVisible = function(self)
			return not self.Closed and ((self.Side and not self.Side.Hidden) or not self.Side)
		end

		funcs.IsContentVisible = function(self)
			return self:IsVisible() and not self.Minimized
		end

		funcs.Focus = function(self)
			moveToTop(self)
		end

		funcs.MoveInBoundary = function(self)
			local posX,posY = self.PosX,self.PosY
			local maxX,maxY = sidesGui.AbsoluteSize.X,sidesGui.AbsoluteSize.Y
			posX = math.min(posX,maxX-self.SizeX)
			posY = math.min(posY,maxY-20)
			self.GuiElems.Main.Position = UDim2.new(0,posX,0,posY)
		end

		funcs.DoTween = function(self,...)
			local tween = service.TweenService:Create(...)
			self.Tweens[#self.Tweens+1] = tween
			tween:Play()
		end

		funcs.StopTweens = function(self)
			for i,v in pairs(self.Tweens) do
				v:Cancel()
			end
			self.Tweens = {}
		end

		funcs.Show = function(self,data)
			return static.ShowWindow(self,data)
		end

		funcs.ShowAndFocus = function(self,data)
			static.ShowWindow(self,data)
			service.RunService.RenderStepped:wait()
			self:Focus()
		end

		static.ShowWindow = function(window,data)
			data = data or {}
			local align = data.Align
			local pos = data.Pos
			local size = data.Size
			local targetSide = (align == "left" and leftSide) or (align == "right" and rightSide)

			if not window.Closed then
				if not window.Aligned then
					window:SetMinimized(false)
				elseif window.Side and not data.Silent then
					static.SetSideVisible(window.Side,true)
				end
				return
			end

			window.Closed = false
			window.LastClose = tick()
			window.GuiElems.Title.TextTransparency = 0
			window.GuiElems.Minimize.ImageLabel.ImageTransparency = 0
			window.GuiElems.Close.ImageLabel.ImageTransparency = 0
			window.GuiElems.TopBar.BackgroundTransparency = 0
			window.GuiElems.Outlines.ImageTransparency = 0
			window.GuiElems.Minimize.ImageLabel.Image = "rbxassetid://5034768003"
			window.GuiElems.Main.Active = true
			window.GuiElems.Main.Outlines.Visible = true
			window:SetMinimized(false,3)
			window:SetResizableInternal(true)
			window.MinimizeAnim.Enable()
			window.CloseAnim.Enable()

			if align then
				window:AlignTo(targetSide,pos,size,data.Silent)
			else
				if align == nil and window.ClosedSide then -- Regular open
					window:AlignTo(window.ClosedSide,window.SidePos,size,true)
					static.SetSideVisible(window.ClosedSide,true)
				else
					if table.find(visibleWindows,window) then return end

					-- TODO: make better
					window.GuiElems.Main.Size = UDim2.new(0,window.SizeX,0,20)
					local ti = TweenInfo.new(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.Out)
					window:StopTweens()
					window:DoTween(window.GuiElems.Main,ti,{Size = UDim2.new(0,window.SizeX,0,window.SizeY)})

					window.SizeY = size or window.SizeY
					table.insert(visibleWindows,1,window)
					updateWindows()
				end
			end

			window.ClosedSide = nil
			window.OnActivate:Fire()
		end

		static.ToggleSide = function(name)
			local side = (name == "left" and leftSide or rightSide)
			side.Hidden = not side.Hidden
			for i,v in pairs(side.Windows) do
				if side.Hidden then
					v.OnDeactivate:Fire()
				else
					v.OnActivate:Fire()
				end
			end
			updateWindows()
		end

		static.SetSideVisible = function(s,vis)
			local side = (type(s) == "table" and s) or (s == "left" and leftSide or rightSide)
			side.Hidden = not vis
			for i,v in pairs(side.Windows) do
				if side.Hidden then
					v.OnDeactivate:Fire()
				else
					v.OnActivate:Fire()
				end
			end
			updateWindows()
		end

		static.Init = function()
			displayOrderStart = Main.DisplayOrders.Window
			sideDisplayOrder = Main.DisplayOrders.SideWindow

			sidesGui = Instance.new("ScreenGui")
			local leftFrame = create({
				{1,"Frame",{Active=true,Name="LeftSide",BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderSizePixel=0,}},
				{2,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2549019753933,0.2549019753933,0.2549019753933),BorderSizePixel=0,Font=3,Name="Resizer",Parent={1},Size=UDim2.new(0,5,1,0),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{3,"Frame",{BackgroundColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),BorderSizePixel=0,Name="Line",Parent={2},Position=UDim2.new(0,0,0,0),Size=UDim2.new(0,1,1,0),}},
				{4,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2549019753933,0.2549019753933,0.2549019753933),BorderSizePixel=0,Font=3,Name="WindowResizer",Parent={1},Position=UDim2.new(1,-300,0,0),Size=UDim2.new(1,0,0,4),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{5,"Frame",{BackgroundColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),BorderSizePixel=0,Name="Line",Parent={4},Size=UDim2.new(1,0,0,1),}},
			})
			leftSide.Frame = leftFrame
			leftFrame.Position = UDim2.new(0,-leftSide.Width-10,0,0)
			leftSide.WindowResizer = leftFrame.WindowResizer
			leftFrame.WindowResizer.Parent = nil
			leftFrame.Parent = sidesGui

			local rightFrame = create({
				{1,"Frame",{Active=true,Name="RightSide",BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderSizePixel=0,}},
				{2,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2549019753933,0.2549019753933,0.2549019753933),BorderSizePixel=0,Font=3,Name="Resizer",Parent={1},Size=UDim2.new(0,5,1,0),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{3,"Frame",{BackgroundColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),BorderSizePixel=0,Name="Line",Parent={2},Position=UDim2.new(0,4,0,0),Size=UDim2.new(0,1,1,0),}},
				{4,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2549019753933,0.2549019753933,0.2549019753933),BorderSizePixel=0,Font=3,Name="WindowResizer",Parent={1},Position=UDim2.new(1,-300,0,0),Size=UDim2.new(1,0,0,4),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
				{5,"Frame",{BackgroundColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),BorderSizePixel=0,Name="Line",Parent={4},Size=UDim2.new(1,0,0,1),}},
			})
			rightSide.Frame = rightFrame
			rightFrame.Position = UDim2.new(1,10,0,0)
			rightSide.WindowResizer = rightFrame.WindowResizer
			rightFrame.WindowResizer.Parent = nil
			rightFrame.Parent = sidesGui

			sideResizerHook(leftFrame.Resizer,"H",leftSide)
			sideResizerHook(rightFrame.Resizer,"H",rightSide)

			alignIndicator = Instance.new("ScreenGui")
			alignIndicator.DisplayOrder = Main.DisplayOrders.Core
			local indicator = Instance.new("Frame",alignIndicator)
			indicator.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
			indicator.BorderSizePixel = 0
			indicator.BackgroundTransparency = 0.8
			indicator.Name = "Indicator"
			local corner = Instance.new("UICorner",indicator)
			corner.CornerRadius = UDim.new(0,10)

			local leftToggle = create({{1,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BorderColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),BorderMode=2,Font=10,Name="LeftToggle",Position=UDim2.new(0,0,0,-36),Size=UDim2.new(0,16,0,36),Text="<",TextColor3=Color3.new(1,1,1),TextSize=14,}}})
			local rightToggle = leftToggle:Clone()
			rightToggle.Name = "RightToggle"
			rightToggle.Position = UDim2.new(1,-16,0,-36)
			Lib.ButtonAnim(leftToggle,{Mode = 2,PressColor = Color3.fromRGB(32,32,32)})
			Lib.ButtonAnim(rightToggle,{Mode = 2,PressColor = Color3.fromRGB(32,32,32)})

			leftToggle.MouseButton1Click:Connect(function()
				static.ToggleSide("left")
			end)

			rightToggle.MouseButton1Click:Connect(function()
				static.ToggleSide("right")
			end)

			leftToggle.Parent = sidesGui
			rightToggle.Parent = sidesGui

			sidesGui:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				local maxWidth = math.max(300,sidesGui.AbsoluteSize.X-static.FreeWidth)
				leftSide.Width = math.max(static.MinWidth,math.min(leftSide.Width,maxWidth-rightSide.Width))
				rightSide.Width = math.max(static.MinWidth,math.min(rightSide.Width,maxWidth-leftSide.Width))
				for i = 1,#visibleWindows do
					visibleWindows[i]:MoveInBoundary()
				end
				updateWindows(true)
			end)

			sidesGui.DisplayOrder = sideDisplayOrder - 1
			Lib.ShowGui(sidesGui)
			updateSideFrames()
		end

		local mt = {__index = funcs}
		static.new = function()
			local obj = setmetatable({
				Minimized = false,
				Dragging = false,
				Resizing = false,
				Aligned = false,
				Draggable = true,
				Resizable = true,
				ResizableInternal = true,
				Alignable = true,
				Closed = true,
				SizeX = 300,
				SizeY = 300,
				MinX = 200,
				MinY = 200,
				PosX = 0,
				PosY = 0,
				GuiElems = {},
				Tweens = {},
				Elements = {},
				OnActivate = Lib.Signal.new(),
				OnDeactivate = Lib.Signal.new(),
				OnMinimize = Lib.Signal.new(),
				OnRestore = Lib.Signal.new()
			},mt)
			obj.Gui = createGui(obj)
			return obj
		end

		return static
	end)()

	Lib.ContextMenu = (function()
		local funcs = {}
		local mouse

		local function createGui(self)
			local contextGui = create({
				{1,"ScreenGui",{DisplayOrder=1000000,Name="Context",ZIndexBehavior=1,}},
				{2,"Frame",{Active=true,BackgroundColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),BorderColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),Name="Main",Parent={1},Position=UDim2.new(0.5,-100,0.5,-150),Size=UDim2.new(0,200,0,100),}},
				{3,"UICorner",{CornerRadius=UDim.new(0,4),Parent={2},}},
				{4,"Frame",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),Name="Container",Parent={2},Position=UDim2.new(0,1,0,1),Size=UDim2.new(1,-2,1,-2),}},
				{5,"UICorner",{CornerRadius=UDim.new(0,4),Parent={4},}},
				{6,"ScrollingFrame",{Active=true,BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BackgroundTransparency=1,BorderSizePixel=0,CanvasSize=UDim2.new(0,0,0,0),Name="List",Parent={4},Position=UDim2.new(0,2,0,2),ScrollBarImageColor3=Color3.new(0,0,0),ScrollBarThickness=4,Size=UDim2.new(1,-4,1,-4),VerticalScrollBarInset=1,}},
				{7,"UIListLayout",{Parent={6},SortOrder=2,}},
				{8,"Frame",{BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BorderSizePixel=0,Name="SearchFrame",Parent={4},Size=UDim2.new(1,0,0,24),Visible=false,}},
				{9,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.1176470592618,0.1176470592618,0.1176470592618),BorderSizePixel=0,Name="SearchContainer",Parent={8},Position=UDim2.new(0,3,0,3),Size=UDim2.new(1,-6,0,18),}},
				{10,"TextBox",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="SearchBox",Parent={9},PlaceholderColor3=Color3.new(0.39215689897537,0.39215689897537,0.39215689897537),PlaceholderText="Search",Position=UDim2.new(0,4,0,0),Size=UDim2.new(1,-8,0,18),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,TextXAlignment=0,}},
				{11,"UICorner",{CornerRadius=UDim.new(0,2),Parent={9},}},
				{12,"Frame",{BackgroundColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),BorderSizePixel=0,Name="Line",Parent={8},Position=UDim2.new(0,0,1,0),Size=UDim2.new(1,0,0,1),}},
				{13,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BackgroundTransparency=1,BorderColor3=Color3.new(0.33725491166115,0.49019610881805,0.73725491762161),BorderSizePixel=0,Font=3,Name="Entry",Parent={1},Size=UDim2.new(1,0,0,22),Text="",TextSize=14,Visible=false,}},
				{14,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="EntryName",Parent={13},Position=UDim2.new(0,24,0,0),Size=UDim2.new(1,-24,1,0),Text="Duplicate",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{15,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Shortcut",Parent={13},Position=UDim2.new(0,24,0,0),Size=UDim2.new(1,-30,1,0),Text="Ctrl+D",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{16,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,ImageRectOffset=Vector2.new(304,0),ImageRectSize=Vector2.new(16,16),Name="Icon",Parent={13},Position=UDim2.new(0,2,0,3),ScaleType=4,Size=UDim2.new(0,16,0,16),}},
				{17,"UICorner",{CornerRadius=UDim.new(0,4),Parent={13},}},
				{18,"Frame",{BackgroundColor3=Color3.new(0.21568629145622,0.21568629145622,0.21568629145622),BackgroundTransparency=1,BorderSizePixel=0,Name="Divider",Parent={1},Position=UDim2.new(0,0,0,20),Size=UDim2.new(1,0,0,7),Visible=false,}},
				{19,"Frame",{BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BorderSizePixel=0,Name="Line",Parent={18},Position=UDim2.new(0,0,0.5,0),Size=UDim2.new(1,0,0,1),}},
				{20,"TextLabel",{AnchorPoint=Vector2.new(0,0.5),BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="DividerName",Parent={18},Position=UDim2.new(0,2,0.5,0),Size=UDim2.new(1,-4,1,0),Text="Objects",TextColor3=Color3.new(1,1,1),TextSize=14,TextTransparency=0.60000002384186,TextXAlignment=0,Visible=false,}},
			})
			self.GuiElems.Main = contextGui.Main
			self.GuiElems.List = contextGui.Main.Container.List
			self.GuiElems.Entry = contextGui.Entry
			self.GuiElems.Divider = contextGui.Divider
			self.GuiElems.SearchFrame = contextGui.Main.Container.SearchFrame
			self.GuiElems.SearchBar = self.GuiElems.SearchFrame.SearchContainer.SearchBox
			Lib.ViewportTextBox.convert(self.GuiElems.SearchBar)

			self.GuiElems.SearchBar:GetPropertyChangedSignal("Text"):Connect(function()
				local lower,find = string.lower,string.find
				local searchText = lower(self.GuiElems.SearchBar.Text)
				local items = self.Items
				local map = self.ItemToEntryMap

				if searchText ~= "" then
					local results = {}
					local count = 1
					for i = 1,#items do
						local item = items[i]
						local entry = map[item]
						if entry then
							if not item.Divider and find(lower(item.Name),searchText,1,true) then
								results[count] = item
								count = count + 1
							else
								entry.Visible = false
							end
						end
					end
					table.sort(results,function(a,b) return a.Name < b.Name end)
					for i = 1,#results do
						local entry = map[results[i]]
						entry.LayoutOrder = i
						entry.Visible = true
					end
				else
					for i = 1,#items do
						local entry = map[items[i]]
						if entry then entry.LayoutOrder = i entry.Visible = true end
					end
				end

				local toSize = self.GuiElems.List.UIListLayout.AbsoluteContentSize.Y + 6
				self.GuiElems.List.CanvasSize = UDim2.new(0,0,0,toSize-6)
			end)

			return contextGui
		end

		funcs.Add = function(self,item)
			local newItem = {
				Name = item.Name or "Item",
				Icon = item.Icon or "",
				Shortcut = item.Shortcut or "",
				OnClick = item.OnClick,
				OnHover = item.OnHover,
				Disabled = item.Disabled or false,
				DisabledIcon = item.DisabledIcon or "",
				IconMap = item.IconMap,
				OnRightClick = item.OnRightClick
			}
			if self.QueuedDivider then
				local text = self.QueuedDividerText and #self.QueuedDividerText > 0 and self.QueuedDividerText
				self:AddDivider(text)
			end
			self.Items[#self.Items+1] = newItem
			self.Updated = nil
		end

		funcs.AddRegistered = function(self,name,disabled)
			if not self.Registered[name] then error(name.." is not registered") end
			
			if self.QueuedDivider then
				local text = self.QueuedDividerText and #self.QueuedDividerText > 0 and self.QueuedDividerText
				self:AddDivider(text)
			end
			self.Registered[name].Disabled = disabled
			self.Items[#self.Items+1] = self.Registered[name]
			self.Updated = nil
		end

		funcs.Register = function(self,name,item)
			self.Registered[name] = {
				Name = item.Name or "Item",
				Icon = item.Icon or "",
				Shortcut = item.Shortcut or "",
				OnClick = item.OnClick,
				OnHover = item.OnHover,
				DisabledIcon = item.DisabledIcon or "",
				IconMap = item.IconMap,
				OnRightClick = item.OnRightClick
			}
		end

		funcs.UnRegister = function(self,name)
			self.Registered[name] = nil
		end

		funcs.AddDivider = function(self,text)
			self.QueuedDivider = false
			local textWidth = text and service.TextService:GetTextSize(text,14,Enum.Font.SourceSans,Vector2.new(999999999,20)).X or nil
			table.insert(self.Items,{Divider = true, Text = text, TextSize = textWidth and textWidth+4})
			self.Updated = nil
		end
		
		funcs.QueueDivider = function(self,text)
			self.QueuedDivider = true
			self.QueuedDividerText = text or ""
		end

		funcs.Clear = function(self)
			self.Items = {}
			self.Updated = nil
		end

		funcs.Refresh = function(self)
			for i,v in pairs(self.GuiElems.List:GetChildren()) do
				if not v:IsA("UIListLayout") then
					v:Destroy()
				end
			end
			local map = {}
			self.ItemToEntryMap = map

			local dividerFrame = self.GuiElems.Divider
			local contextList = self.GuiElems.List
			local entryFrame = self.GuiElems.Entry
			local items = self.Items

			for i = 1,#items do
				local item = items[i]
				if item.Divider then
					local newDivider = dividerFrame:Clone()
					newDivider.Line.BackgroundColor3 = self.Theme.DividerColor
					if item.Text then
						newDivider.Size = UDim2.new(1,0,0,20)
						newDivider.Line.Position = UDim2.new(0,item.TextSize,0.5,0)
						newDivider.Line.Size = UDim2.new(1,-item.TextSize,0,1)
						newDivider.DividerName.TextColor3 = self.Theme.TextColor
						newDivider.DividerName.Text = item.Text
						newDivider.DividerName.Visible = true
					end
					newDivider.Visible = true
					map[item] = newDivider
					newDivider.Parent = contextList
				else
					local newEntry = entryFrame:Clone()
					newEntry.BackgroundColor3 = self.Theme.HighlightColor
					newEntry.EntryName.TextColor3 = self.Theme.TextColor
					newEntry.EntryName.Text = item.Name
					newEntry.Shortcut.Text = item.Shortcut
					if item.Disabled then
						newEntry.EntryName.TextColor3 = Color3.new(150/255,150/255,150/255)
						newEntry.Shortcut.TextColor3 = Color3.new(150/255,150/255,150/255)
					end

					if self.Iconless then
						newEntry.EntryName.Position = UDim2.new(0,2,0,0)
						newEntry.EntryName.Size = UDim2.new(1,-4,0,20)
						newEntry.Icon.Visible = false
					else
						local iconIndex = item.Disabled and item.DisabledIcon or item.Icon
						if item.IconMap then
							if type(iconIndex) == "number" then
								item.IconMap:Display(newEntry.Icon,iconIndex)
							elseif type(iconIndex) == "string" then
								item.IconMap:DisplayByKey(newEntry.Icon,iconIndex)
							end
						elseif type(iconIndex) == "string" then
							newEntry.Icon.Image = iconIndex
						end
					end

					if not item.Disabled then
						if item.OnClick then
							newEntry.MouseButton1Click:Connect(function()
								item.OnClick(item.Name)
								if not item.NoHide then
									self:Hide()
								end
							end)
						end

						if item.OnRightClick then
							newEntry.MouseButton2Click:Connect(function()
								item.OnRightClick(item.Name)
								if not item.NoHide then
									self:Hide()
								end
							end)
						end
					end

					newEntry.InputBegan:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseMovement then
							newEntry.BackgroundTransparency = 0
						end
					end)

					newEntry.InputEnded:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseMovement then
							newEntry.BackgroundTransparency = 1
						end
					end)

					newEntry.Visible = true
					map[item] = newEntry
					newEntry.Parent = contextList
				end
			end
			self.Updated = true
		end

		funcs.Show = function(self,x,y)
			-- Initialize Gui
			local elems = self.GuiElems
			elems.SearchFrame.Visible = self.SearchEnabled
			elems.List.Position = UDim2.new(0,2,0,2 + (self.SearchEnabled and 24 or 0))
			elems.List.Size = UDim2.new(1,-4,1,-4 - (self.SearchEnabled and 24 or 0))
			if self.SearchEnabled and self.ClearSearchOnShow then elems.SearchBar.Text = "" end
			self.GuiElems.List.CanvasPosition = Vector2.new(0,0)

			if not self.Updated then
				self:Refresh() -- Create entries
			end

			-- Vars
			local reverseY = false
			local x,y = x or mouse.X, y or mouse.Y
			local maxX,maxY = mouse.ViewSizeX,mouse.ViewSizeY

			-- Position and show
			if x + self.Width > maxX then
				x = self.ReverseX and x - self.Width or maxX - self.Width
			end
			elems.Main.Position = UDim2.new(0,x,0,y)
			elems.Main.Size = UDim2.new(0,self.Width,0,0)
			self.Gui.DisplayOrder = Main.DisplayOrders.Menu
			Lib.ShowGui(self.Gui)

			-- Size adjustment
			local toSize = elems.List.UIListLayout.AbsoluteContentSize.Y + 6 -- Padding
			if self.MaxHeight and toSize > self.MaxHeight then
				elems.List.CanvasSize = UDim2.new(0,0,0,toSize-6)
				toSize = self.MaxHeight
			else
				elems.List.CanvasSize = UDim2.new(0,0,0,0)
			end
			if y + toSize > maxY then reverseY = true end

			-- Close event
			local closable
			if self.CloseEvent then self.CloseEvent:Disconnect() end
			self.CloseEvent = service.UserInputService.InputBegan:Connect(function(input)
				if not closable or input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end

				if not Lib.CheckMouseInGui(elems.Main) then
					self.CloseEvent:Disconnect()
					self:Hide()
				end
			end)

			-- Resize
			if reverseY then
				elems.Main.Position = UDim2.new(0,x,0,y-(self.ReverseYOffset or 0))
				local newY = y - toSize - (self.ReverseYOffset or 0)
				y = newY >= 0 and newY or 0
				elems.Main:TweenSizeAndPosition(UDim2.new(0,self.Width,0,toSize),UDim2.new(0,x,0,y),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.2,true)
			else
				elems.Main:TweenSize(UDim2.new(0,self.Width,0,toSize),Enum.EasingDirection.Out,Enum.EasingStyle.Quart,0.2,true)
			end

			-- Close debounce
			Lib.FastWait()
			if self.SearchEnabled and self.FocusSearchOnShow then elems.SearchBar:CaptureFocus() end
			closable = true
		end

		funcs.Hide = function(self)
			self.Gui.Parent = nil
		end

		funcs.ApplyTheme = function(self,data)
			local theme = self.Theme
			theme.ContentColor = data.ContentColor or Settings.Theme.Menu
			theme.OutlineColor = data.OutlineColor or Settings.Theme.Menu
			theme.DividerColor = data.DividerColor or Settings.Theme.Outline2
			theme.TextColor = data.TextColor or Settings.Theme.Text
			theme.HighlightColor = data.HighlightColor or Settings.Theme.Main1

			self.GuiElems.Main.BackgroundColor3 = theme.OutlineColor
			self.GuiElems.Main.Container.BackgroundColor3 = theme.ContentColor
		end

		local mt = {__index = funcs}
		local function new()
			if not mouse then mouse = Main.Mouse or service.Players.LocalPlayer:GetMouse() end

			local obj = setmetatable({
				Width = 200,
				MaxHeight = nil,
				Iconless = false,
				SearchEnabled = false,
				ClearSearchOnShow = true,
				FocusSearchOnShow = true,
				Updated = false,
				QueuedDivider = false,
				QueuedDividerText = "",
				Items = {},
				Registered = {},
				GuiElems = {},
				Theme = {}
			},mt)
			obj.Gui = createGui(obj)
			obj:ApplyTheme({})
			return obj
		end

		return {new = new}
	end)()

	Lib.CodeFrame = (function()
		local funcs = {}

		local typeMap = {
			[1] = "String",
			[2] = "String",
			[3] = "String",
			[4] = "Comment",
			[5] = "Operator",
			[6] = "Number",
			[7] = "Keyword",
			[8] = "BuiltIn",
			[9] = "LocalMethod",
			[10] = "LocalProperty",
			[11] = "Nil",
			[12] = "Bool",
			[13] = "Function",
			[14] = "Local",
			[15] = "Self",
			[16] = "FunctionName",
			[17] = "Bracket"
		}

		local specialKeywordsTypes = {
			["nil"] = 11,
			["true"] = 12,
			["false"] = 12,
			["function"] = 13,
			["local"] = 14,
			["self"] = 15
		}

		local keywords = {
			["and"] = true,
			["break"] = true, 
			["do"] = true,
			["else"] = true,
			["elseif"] = true,
			["end"] = true,
			["false"] = true,
			["for"] = true,
			["function"] = true,
			["if"] = true,
			["in"] = true,
			["local"] = true,
			["nil"] = true,
			["not"] = true,
			["or"] = true,
			["repeat"] = true,
			["return"] = true,
			["then"] = true,
			["true"] = true,
			["until"] = true,
			["while"] = true,
			["plugin"] = true
		}

		local builtIns = {
			["delay"] = true,
			["elapsedTime"] = true,
			["require"] = true,
			["spawn"] = true,
			["tick"] = true,
			["time"] = true,
			["typeof"] = true,
			["UserSettings"] = true,
			["wait"] = true,
			["warn"] = true,
			["game"] = true,
			["shared"] = true,
			["script"] = true,
			["workspace"] = true,
			["assert"] = true,
			["collectgarbage"] = true,
			["error"] = true,
			["getfenv"] = true,
			["getmetatable"] = true,
			["ipairs"] = true,
			["loadstring"] = true,
			["newproxy"] = true,
			["next"] = true,
			["pairs"] = true,
			["pcall"] = true,
			["print"] = true,
			["rawequal"] = true,
			["rawget"] = true,
			["rawset"] = true,
			["select"] = true,
			["setfenv"] = true,
			["setmetatable"] = true,
			["tonumber"] = true,
			["tostring"] = true,
			["type"] = true,
			["unpack"] = true,
			["xpcall"] = true,
			["_G"] = true,
			["_VERSION"] = true,
			["coroutine"] = true,
			["debug"] = true,
			["math"] = true,
			["os"] = true,
			["string"] = true,
			["table"] = true,
			["bit32"] = true,
			["utf8"] = true,
			["Axes"] = true,
			["BrickColor"] = true,
			["CFrame"] = true,
			["Color3"] = true,
			["ColorSequence"] = true,
			["ColorSequenceKeypoint"] = true,
			["DockWidgetPluginGuiInfo"] = true,
			["Enum"] = true,
			["Faces"] = true,
			["Instance"] = true,
			["NumberRange"] = true,
			["NumberSequence"] = true,
			["NumberSequenceKeypoint"] = true,
			["PathWaypoint"] = true,
			["PhysicalProperties"] = true,
			["Random"] = true,
			["Ray"] = true,
			["Rect"] = true,
			["Region3"] = true,
			["Region3int16"] = true,
			["TweenInfo"] = true,
			["UDim"] = true,
			["UDim2"] = true,
			["Vector2"] = true,
			["Vector2int16"] = true,
			["Vector3"] = true,
			["Vector3int16"] = true
		}

		local builtInInited = false

		local richReplace = {
			["'"] = "&apos;",
			["\""] = "&quot;",
			["<"] = "&lt;",
			[">"] = "&gt;",
			["&"] = "&amp;"
		}
		
		local tabSub = "\205"
		local tabReplacement = (" %s%s "):format(tabSub,tabSub)
		
		local tabJumps = {
			[("[^%s] %s"):format(tabSub,tabSub)] = 0,
			[(" %s%s"):format(tabSub,tabSub)] = -1,
			[("%s%s "):format(tabSub,tabSub)] = 2,
			[("%s [^%s]"):format(tabSub,tabSub)] = 1,
		}
		
		local tweenService = service.TweenService
		local lineTweens = {}

		local function initBuiltIn()
			local env = getfenv()
			local type = type
			local tostring = tostring
			for name,_ in next,builtIns do
				local envVal = env[name]
				if type(envVal) == "table" then
					local items = {}
					for i,v in next,envVal do
						items[i] = true
					end
					builtIns[name] = items
				end
			end

			local enumEntries = {}
			local enums = Enum:GetEnums()
			for i = 1,#enums do
				enumEntries[tostring(enums[i])] = true
			end
			builtIns["Enum"] = enumEntries

			builtInInited = true
		end
		
		local function setupEditBox(obj)
			local editBox = obj.GuiElems.EditBox
			
			editBox.Focused:Connect(function()
				obj:ConnectEditBoxEvent()
				obj.Editing = true
			end)
			
			editBox.FocusLost:Connect(function()
				obj:DisconnectEditBoxEvent()
				obj.Editing = false
			end)
			
			editBox:GetPropertyChangedSignal("Text"):Connect(function()
				local text = editBox.Text
				if #text == 0 or obj.EditBoxCopying then return end
				editBox.Text = ""
				obj:AppendText(text)
			end)
		end
		
		local function setupMouseSelection(obj)
			local mouse = plr:GetMouse()
			local codeFrame = obj.GuiElems.LinesFrame
			local lines = obj.Lines
			
			codeFrame.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					local fontSizeX,fontSizeY = math.ceil(obj.FontSize/2),obj.FontSize
					
					local relX = mouse.X - codeFrame.AbsolutePosition.X
					local relY = mouse.Y - codeFrame.AbsolutePosition.Y
					local selX = math.round(relX / fontSizeX) + obj.ViewX
					local selY = math.floor(relY / fontSizeY) + obj.ViewY
					local releaseEvent,mouseEvent,scrollEvent
					local scrollPowerV,scrollPowerH = 0,0
					selY = math.min(#lines-1,selY)
					local relativeLine = lines[selY+1] or ""
					selX = math.min(#relativeLine, selX + obj:TabAdjust(selX,selY))

					obj.SelectionRange = {{-1,-1},{-1,-1}}
					obj:MoveCursor(selX,selY)
					obj.FloatCursorX = selX

					local function updateSelection()
						local relX = mouse.X - codeFrame.AbsolutePosition.X
						local relY = mouse.Y - codeFrame.AbsolutePosition.Y
						local sel2X = math.max(0,math.round(relX / fontSizeX) + obj.ViewX)
						local sel2Y = math.max(0,math.floor(relY / fontSizeY) + obj.ViewY)

						sel2Y = math.min(#lines-1,sel2Y)
						local relativeLine = lines[sel2Y+1] or ""
						sel2X = math.min(#relativeLine, sel2X + obj:TabAdjust(sel2X,sel2Y))

						if sel2Y < selY or (sel2Y == selY and sel2X < selX) then
							obj.SelectionRange = {{sel2X,sel2Y},{selX,selY}}
						else						
							obj.SelectionRange = {{selX,selY},{sel2X,sel2Y}}
						end

						obj:MoveCursor(sel2X,sel2Y)
						obj.FloatCursorX = sel2X
						obj:Refresh()
					end

					releaseEvent = service.UserInputService.InputEnded:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseButton1 then
							releaseEvent:Disconnect()
							mouseEvent:Disconnect()
							scrollEvent:Disconnect()
							obj:SetCopyableSelection()
							--updateSelection()
						end
					end)

					mouseEvent = service.UserInputService.InputChanged:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseMovement then
							local upDelta = mouse.Y - codeFrame.AbsolutePosition.Y
							local downDelta = mouse.Y - codeFrame.AbsolutePosition.Y - codeFrame.AbsoluteSize.Y
							local leftDelta = mouse.X - codeFrame.AbsolutePosition.X
							local rightDelta = mouse.X - codeFrame.AbsolutePosition.X - codeFrame.AbsoluteSize.X
							scrollPowerV = 0
							scrollPowerH = 0
							if downDelta > 0 then
								scrollPowerV = math.floor(downDelta*0.05) + 1
							elseif upDelta < 0 then
								scrollPowerV = math.ceil(upDelta*0.05) - 1
							end
							if rightDelta > 0 then
								scrollPowerH = math.floor(rightDelta*0.05) + 1
							elseif leftDelta < 0 then
								scrollPowerH = math.ceil(leftDelta*0.05) - 1
							end
							updateSelection()
						end
					end)

					scrollEvent = cloneref(game:GetService("RunService")).RenderStepped:Connect(function()
						if scrollPowerV ~= 0 or scrollPowerH ~= 0 then
							obj:ScrollDelta(scrollPowerH,scrollPowerV)
							updateSelection()
						end
					end)

					obj:Refresh()
				end
			end)
		end

		local function makeFrame(obj)
			local frame = create({
				{1,"Frame",{BackgroundColor3=Color3.new(0.15686275064945,0.15686275064945,0.15686275064945),BorderSizePixel = 0,Position=UDim2.new(0.5,-300,0.5,-200),Size=UDim2.new(0,600,0,400),}},
			})
			local elems = {}
			
			local linesFrame = Instance.new("Frame")
			linesFrame.Name = "Lines"
			linesFrame.BackgroundTransparency = 1
			linesFrame.Size = UDim2.new(1,0,1,0)
			linesFrame.ClipsDescendants = true
			linesFrame.Parent = frame
			
			local lineNumbersLabel = Instance.new("TextLabel")
			lineNumbersLabel.Name = "LineNumbers"
			lineNumbersLabel.BackgroundTransparency = 1
			lineNumbersLabel.Font = Enum.Font.Code
			lineNumbersLabel.TextXAlignment = Enum.TextXAlignment.Right
			lineNumbersLabel.TextYAlignment = Enum.TextYAlignment.Top
			lineNumbersLabel.ClipsDescendants = true
			lineNumbersLabel.RichText = true
			lineNumbersLabel.Parent = frame
			
			local cursor = Instance.new("Frame")
			cursor.Name = "Cursor"
			cursor.BackgroundColor3 = Color3.fromRGB(220,220,220)
			cursor.BorderSizePixel = 0
			cursor.Parent = frame
			
			local editBox = Instance.new("TextBox")
			editBox.Name = "EditBox"
			editBox.MultiLine = true
			editBox.Visible = false
			editBox.Parent = frame
			
			lineTweens.Invis = tweenService:Create(cursor,TweenInfo.new(0.4,Enum.EasingStyle.Quart,Enum.EasingDirection.Out),{BackgroundTransparency = 1})
			lineTweens.Vis = tweenService:Create(cursor,TweenInfo.new(0.2,Enum.EasingStyle.Quart,Enum.EasingDirection.Out),{BackgroundTransparency = 0})
			
			elems.LinesFrame = linesFrame
			elems.LineNumbersLabel = lineNumbersLabel
			elems.Cursor = cursor
			elems.EditBox = editBox
			elems.ScrollCorner = create({{1,"Frame",{BackgroundColor3=Color3.new(0.15686275064945,0.15686275064945,0.15686275064945),BorderSizePixel=0,Name="ScrollCorner",Position=UDim2.new(1,-16,1,-16),Size=UDim2.new(0,16,0,16),Visible=false,}}})
			
			elems.ScrollCorner.Parent = frame
			linesFrame.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					obj:SetEditing(true,input)
				end
			end)
			
			obj.Frame = frame
			obj.Gui = frame
			obj.GuiElems = elems
			setupEditBox(obj)
			setupMouseSelection(obj)
			
			return frame
		end
		
		funcs.GetSelectionText = function(self)
			if not self:IsValidRange() then return "" end
			
			local selectionRange = self.SelectionRange
			local selX,selY = selectionRange[1][1], selectionRange[1][2]
			local sel2X,sel2Y = selectionRange[2][1], selectionRange[2][2]
			local deltaLines = sel2Y-selY
			local lines = self.Lines

			if not lines[selY+1] or not lines[sel2Y+1] then return "" end

			if deltaLines == 0 then
				return self:ConvertText(lines[selY+1]:sub(selX+1,sel2X), false)
			end

			local leftSub = lines[selY+1]:sub(selX+1)
			local rightSub = lines[sel2Y+1]:sub(1,sel2X)

			local result = leftSub.."\n" 
			for i = selY+1,sel2Y-1 do
				result = result..lines[i+1].."\n"
			end
			result = result..rightSub

			return self:ConvertText(result,false)
		end
		
		funcs.SetCopyableSelection = function(self)
			local text = self:GetSelectionText()
			local editBox = self.GuiElems.EditBox
			
			self.EditBoxCopying = true
			editBox.Text = text
			editBox.SelectionStart = 1
			editBox.CursorPosition = #editBox.Text + 1
			self.EditBoxCopying = false
		end
		
		funcs.ConnectEditBoxEvent = function(self)
			if self.EditBoxEvent then
				self.EditBoxEvent:Disconnect()
			end
			
			self.EditBoxEvent = service.UserInputService.InputBegan:Connect(function(input)
				if input.UserInputType ~= Enum.UserInputType.Keyboard then return end
				
				local keycodes = Enum.KeyCode
				local keycode = input.KeyCode
				
				local function setupMove(key,func)
					local endCon,finished
					endCon = service.UserInputService.InputEnded:Connect(function(input)
						if input.KeyCode ~= key then return end
						endCon:Disconnect()
						finished = true
					end)
					func()
					Lib.FastWait(0.5)
					while not finished do func() Lib.FastWait(0.03) end
				end
				
				if keycode == keycodes.Down then
					setupMove(keycodes.Down,function()
						self.CursorX = self.FloatCursorX
						self.CursorY = self.CursorY + 1
						self:UpdateCursor()
						self:JumpToCursor()
					end)
				elseif keycode == keycodes.Up then
					setupMove(keycodes.Up,function()
						self.CursorX = self.FloatCursorX
						self.CursorY = self.CursorY - 1
						self:UpdateCursor()
						self:JumpToCursor()
					end)
				elseif keycode == keycodes.Left then
					setupMove(keycodes.Left,function()
						local line = self.Lines[self.CursorY+1] or ""
						self.CursorX = self.CursorX - 1 - (line:sub(self.CursorX-3,self.CursorX) == tabReplacement and 3 or 0)
						if self.CursorX < 0 then
							self.CursorY = self.CursorY - 1
							local line2 = self.Lines[self.CursorY+1] or ""
							self.CursorX = #line2
						end
						self.FloatCursorX = self.CursorX
						self:UpdateCursor()
						self:JumpToCursor()
					end)
				elseif keycode == keycodes.Right then
					setupMove(keycodes.Right,function()
						local line = self.Lines[self.CursorY+1] or ""
						self.CursorX = self.CursorX + 1 + (line:sub(self.CursorX+1,self.CursorX+4) == tabReplacement and 3 or 0)
						if self.CursorX > #line then
							self.CursorY = self.CursorY + 1
							self.CursorX = 0
						end
						self.FloatCursorX = self.CursorX
						self:UpdateCursor()
						self:JumpToCursor()
					end)
				elseif keycode == keycodes.Backspace then
					setupMove(keycodes.Backspace,function()
						local startRange,endRange
						if self:IsValidRange() then
							startRange = self.SelectionRange[1]
							endRange = self.SelectionRange[2]
						else
							endRange = {self.CursorX,self.CursorY}
						end
						
						if not startRange then
							local line = self.Lines[self.CursorY+1] or ""
							self.CursorX = self.CursorX - 1 - (line:sub(self.CursorX-3,self.CursorX) == tabReplacement and 3 or 0)
							if self.CursorX < 0 then
								self.CursorY = self.CursorY - 1
								local line2 = self.Lines[self.CursorY+1] or ""
								self.CursorX = #line2
							end
							self.FloatCursorX = self.CursorX
							self:UpdateCursor()
						
							startRange = startRange or {self.CursorX,self.CursorY}
						end
						
						self:DeleteRange({startRange,endRange},false,true)
						self:ResetSelection(true)
						self:JumpToCursor()
					end)
				elseif keycode == keycodes.Delete then
					setupMove(keycodes.Delete,function()
						local startRange,endRange
						if self:IsValidRange() then
							startRange = self.SelectionRange[1]
							endRange = self.SelectionRange[2]
						else
							startRange = {self.CursorX,self.CursorY}
						end

						if not endRange then
							local line = self.Lines[self.CursorY+1] or ""
							local endCursorX = self.CursorX + 1 + (line:sub(self.CursorX+1,self.CursorX+4) == tabReplacement and 3 or 0)
							local endCursorY = self.CursorY
							if endCursorX > #line then
								endCursorY = endCursorY + 1
								endCursorX = 0
							end
							self:UpdateCursor()

							endRange = endRange or {endCursorX,endCursorY}
						end

						self:DeleteRange({startRange,endRange},false,true)
						self:ResetSelection(true)
						self:JumpToCursor()
					end)
				elseif service.UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
					if keycode == keycodes.A then
						self.SelectionRange = {{0,0},{#self.Lines[#self.Lines],#self.Lines-1}}
						self:SetCopyableSelection()
						self:Refresh()
					end
				end
			end)
		end
		
		funcs.DisconnectEditBoxEvent = function(self)
			if self.EditBoxEvent then
				self.EditBoxEvent:Disconnect()
			end
		end
		
		funcs.ResetSelection = function(self,norefresh)
			self.SelectionRange = {{-1,-1},{-1,-1}}
			if not norefresh then self:Refresh() end
		end
		
		funcs.IsValidRange = function(self,range)
			local selectionRange = range or self.SelectionRange
			local selX,selY = selectionRange[1][1], selectionRange[1][2]
			local sel2X,sel2Y = selectionRange[2][1], selectionRange[2][2]

			if selX == -1 or (selX == sel2X and selY == sel2Y) then return false end

			return true
		end
		
		funcs.DeleteRange = function(self,range,noprocess,updatemouse)
			range = range or self.SelectionRange
			if not self:IsValidRange(range) then return end
			
			local lines = self.Lines
			local selX,selY = range[1][1], range[1][2]
			local sel2X,sel2Y = range[2][1], range[2][2]
			local deltaLines = sel2Y-selY
			
			if not lines[selY+1] or not lines[sel2Y+1] then return end
			
			local leftSub = lines[selY+1]:sub(1,selX)
			local rightSub = lines[sel2Y+1]:sub(sel2X+1)
			lines[selY+1] = leftSub..rightSub
			
			local remove = table.remove
			for i = 1,deltaLines do
				remove(lines,selY+2)
			end
			
			if range == self.SelectionRange then self.SelectionRange = {{-1,-1},{-1,-1}} end
			if updatemouse then
				self.CursorX = selX
				self.CursorY = selY
				self:UpdateCursor()
			end
			
			if not noprocess then
				self:ProcessTextChange()
			end
		end
		
		funcs.AppendText = function(self,text)
			self:DeleteRange(nil,true,true)
			local lines,cursorX,cursorY = self.Lines,self.CursorX,self.CursorY
			local line = lines[cursorY+1]
			local before = line:sub(1,cursorX)
			local after = line:sub(cursorX+1)
			
			text = text:gsub("\r\n","\n")
			text = self:ConvertText(text,true) -- Tab Convert
			
			local textLines = text:split("\n")
			local insert = table.insert
			
			for i = 1,#textLines do
				local linePos = cursorY+i
				if i > 1 then insert(lines,linePos,"") end
				
				local textLine = textLines[i]
				local newBefore = (i == 1 and before or "")
				local newAfter = (i == #textLines and after or "")
			
				lines[linePos] = newBefore..textLine..newAfter
			end
			
			if #textLines > 1 then cursorX = 0 end
			
			self:ProcessTextChange()
			self.CursorX = cursorX + #textLines[#textLines]
			self.CursorY = cursorY + #textLines-1
			self:UpdateCursor()
		end
		
		funcs.ScrollDelta = function(self,x,y)
			self.ScrollV:ScrollTo(self.ScrollV.Index + y)
			self.ScrollH:ScrollTo(self.ScrollH.Index + x)
		end
		
		-- x and y starts at 0
		funcs.TabAdjust = function(self,x,y)
			local lines = self.Lines
			local line = lines[y+1]
			x=x+1
			
			if line then
				local left = line:sub(x-1,x-1)
				local middle = line:sub(x,x)
				local right = line:sub(x+1,x+1)
				local selRange = (#left > 0 and left or " ") .. (#middle > 0 and middle or " ") .. (#right > 0 and right or " ")

				for i,v in pairs(tabJumps) do
					if selRange:find(i) then
						return v
					end
				end
			end
			return 0
		end
		
		funcs.SetEditing = function(self,on,input)			
			self:UpdateCursor(input)
			
			if on then
				if self.Editable then
					self.GuiElems.EditBox.Text = ""
					self.GuiElems.EditBox:CaptureFocus()
				end
			else
				self.GuiElems.EditBox:ReleaseFocus()
			end
		end
		
		funcs.CursorAnim = function(self,on)
			local cursor = self.GuiElems.Cursor
			local animTime = tick()
			self.LastAnimTime = animTime
			
			if not on then return end
			
			lineTweens.Invis:Cancel()
			lineTweens.Vis:Cancel()
			cursor.BackgroundTransparency = 0
			
			coroutine.wrap(function()
				while self.Editable do
					Lib.FastWait(0.5)
					if self.LastAnimTime ~= animTime then return end
					lineTweens.Invis:Play()
					Lib.FastWait(0.4)
					if self.LastAnimTime ~= animTime then return end
					lineTweens.Vis:Play()
					Lib.FastWait(0.2)
				end
			end)()
		end
		
		funcs.MoveCursor = function(self,x,y)
			self.CursorX = x
			self.CursorY = y
			self:UpdateCursor()
			self:JumpToCursor()
		end
		
		funcs.JumpToCursor = function(self)
			self:Refresh()
		end
		
		funcs.UpdateCursor = function(self,input)
			local linesFrame = self.GuiElems.LinesFrame
			local cursor = self.GuiElems.Cursor			
			local hSize = math.max(0,linesFrame.AbsoluteSize.X)
			local vSize = math.max(0,linesFrame.AbsoluteSize.Y)
			local maxLines = math.ceil(vSize / self.FontSize)
			local maxCols = math.ceil(hSize / math.ceil(self.FontSize/2))
			local viewX,viewY = self.ViewX,self.ViewY
			local totalLinesStr = tostring(#self.Lines)
			local fontWidth = math.ceil(self.FontSize / 2)
			local linesOffset = #totalLinesStr*fontWidth + 4*fontWidth
			
			if input then
				local linesFrame = self.GuiElems.LinesFrame
				local frameX,frameY = linesFrame.AbsolutePosition.X,linesFrame.AbsolutePosition.Y
				local mouseX,mouseY = input.Position.X,input.Position.Y
				local fontSizeX,fontSizeY = math.ceil(self.FontSize/2),self.FontSize

				self.CursorX = self.ViewX + math.round((mouseX - frameX) / fontSizeX)
				self.CursorY = self.ViewY + math.floor((mouseY - frameY) / fontSizeY)
			end
			
			local cursorX,cursorY = self.CursorX,self.CursorY
			
			local line = self.Lines[cursorY+1] or ""
			if cursorX > #line then cursorX = #line
			elseif cursorX < 0 then cursorX = 0 end
			
			if cursorY >= #self.Lines then
				cursorY = math.max(0,#self.Lines-1)
			elseif cursorY < 0 then
				cursorY = 0
			end
			
			cursorX = cursorX + self:TabAdjust(cursorX,cursorY)
			
			-- Update modified
			self.CursorX = cursorX
			self.CursorY = cursorY
			
			local cursorVisible = (cursorX >= viewX) and (cursorY >= viewY) and (cursorX <= viewX + maxCols) and (cursorY <= viewY + maxLines)
			if cursorVisible then
				local offX = (cursorX - viewX)
				local offY = (cursorY - viewY)
				cursor.Position = UDim2.new(0,linesOffset + offX*math.ceil(self.FontSize/2) - 1,0,offY*self.FontSize)
				cursor.Size = UDim2.new(0,1,0,self.FontSize+2)
				cursor.Visible = true
				self:CursorAnim(true)
			else
				cursor.Visible = false
			end
		end

		funcs.MapNewLines = function(self)
			local newLines = {}
			local count = 1
			local text = self.Text
			local find = string.find
			local init = 1

			local pos = find(text,"\n",init,true)
			while pos do
				newLines[count] = pos
				count = count + 1
				init = pos + 1
				pos = find(text,"\n",init,true)
			end

			self.NewLines = newLines
		end

		funcs.PreHighlight = function(self)
			local start = tick()
			local text = self.Text:gsub("\\\\","  ")
			--print("BACKSLASH SUB",tick()-start)
			local textLen = #text
			local found = {}
			local foundMap = {}
			local extras = {}
			local find = string.find
			local sub = string.sub
			self.ColoredLines = {}

			local function findAll(str,pattern,typ,raw)
				local count = #found+1
				local init = 1
				local x,y,extra = find(str,pattern,init,raw)
				while x do
					found[count] = x
					foundMap[x] = typ
					if extra then
						extras[x] = extra
					end

					count = count+1
					init = y+1
					x,y,extra = find(str,pattern,init,raw)
				end
			end
			local start = tick()
			findAll(text,'"',1,true)
			findAll(text,"'",2,true)
			findAll(text,"%[(=*)%[",3)
			findAll(text,"--",4,true)
			table.sort(found)

			local newLines = self.NewLines
			local curLine = 0
			local lineTableCount = 1
			local lineStart = 0
			local lineEnd = 0
			local lastEnding = 0
			local foundHighlights = {}

			for i = 1,#found do
				local pos = found[i]
				if pos <= lastEnding then continue end

				local ending = pos
				local typ = foundMap[pos]
				if typ == 1 then
					ending = find(text,'"',pos+1,true)
					while ending and sub(text,ending-1,ending-1) == "\\" do
						ending = find(text,'"',ending+1,true)
					end
					if not ending then ending = textLen end
				elseif typ == 2 then
					ending = find(text,"'",pos+1,true)
					while ending and sub(text,ending-1,ending-1) == "\\" do
						ending = find(text,"'",ending+1,true)
					end
					if not ending then ending = textLen end
				elseif typ == 3 then
					_,ending = find(text,"]"..extras[pos].."]",pos+1,true)
					if not ending then ending = textLen end
				elseif typ == 4 then
					local ahead = foundMap[pos+2]

					if ahead == 3 then
						_,ending = find(text,"]"..extras[pos+2].."]",pos+1,true)
						if not ending then ending = textLen end
					else
						ending = find(text,"\n",pos+1,true) or textLen
					end
				end

				while pos > lineEnd do
					curLine = curLine + 1
					--lineTableCount = 1
					lineEnd = newLines[curLine] or textLen+1
				end
				while true do
					local lineTable = foundHighlights[curLine]
					if not lineTable then lineTable = {} foundHighlights[curLine] = lineTable end
					lineTable[pos] = {typ,ending}
					--lineTableCount = lineTableCount + 1

					if ending > lineEnd then
						curLine = curLine + 1
						lineEnd = newLines[curLine] or textLen+1
					else
						break
					end
				end

				lastEnding = ending
				--if i < 200 then print(curLine) end
			end
			self.PreHighlights = foundHighlights
			--print(tick()-start)
			--print(#found,curLine)
		end

		funcs.HighlightLine = function(self,line)
			local cached = self.ColoredLines[line]
			if cached then return cached end

			local sub = string.sub
			local find = string.find
			local match = string.match
			local highlights = {}
			local preHighlights = self.PreHighlights[line] or {}
			local lineText = self.Lines[line] or ""
			local lineLen = #lineText
			local lastEnding = 0
			local currentType = 0
			local lastWord = nil
			local wordBeginsDotted = false
			local funcStatus = 0
			local lineStart = self.NewLines[line-1] or 0

			local preHighlightMap = {}
			for pos,data in next,preHighlights do
				local relativePos = pos-lineStart
				if relativePos < 1 then
					currentType = data[1]
					lastEnding = data[2] - lineStart
					--warn(pos,data[2])
				else
					preHighlightMap[relativePos] = {data[1],data[2]-lineStart}
				end
			end

			for col = 1,#lineText do
				if col <= lastEnding then highlights[col] = currentType continue end

				local pre = preHighlightMap[col]
				if pre then
					currentType = pre[1]
					lastEnding = pre[2]
					highlights[col] = currentType
					wordBeginsDotted = false
					lastWord = nil
					funcStatus = 0
				else
					local char = sub(lineText,col,col)
					if find(char,"[%a_]") then
						local word = match(lineText,"[%a%d_]+",col)
						local wordType = (keywords[word] and 7) or (builtIns[word] and 8)

						lastEnding = col+#word-1

						if wordType ~= 7 then
							if wordBeginsDotted then
								local prevBuiltIn = lastWord and builtIns[lastWord]
								wordType = (prevBuiltIn and type(prevBuiltIn) == "table" and prevBuiltIn[word] and 8) or 10
							end

							if wordType ~= 8 then
								local x,y,br = find(lineText,"^%s*([%({\"'])",lastEnding+1)
								if x then
									wordType = (funcStatus > 0 and br == "(" and 16) or 9
									funcStatus = 0
								end
							end
						else
							wordType = specialKeywordsTypes[word] or wordType
							funcStatus = (word == "function" and 1 or 0)
						end

						lastWord = word
						wordBeginsDotted = false
						if funcStatus > 0 then funcStatus = 1 end

						if wordType then
							currentType = wordType
							highlights[col] = currentType
						else
							currentType = nil
						end
					elseif find(char,"%p") then
						local isDot = (char == ".")
						local isNum = isDot and find(sub(lineText,col+1,col+1),"%d")
						highlights[col] = (isNum and 6 or 5)

						if not isNum then
							local dotStr = isDot and match(lineText,"%.%.?%.?",col)
							if dotStr and #dotStr > 1 then
								currentType = 5
								lastEnding = col+#dotStr-1
								wordBeginsDotted = false
								lastWord = nil
								funcStatus = 0
							else
								if isDot then
									if wordBeginsDotted then
										lastWord = nil
									else
										wordBeginsDotted = true
									end
								else
									wordBeginsDotted = false
									lastWord = nil
								end

								funcStatus = ((isDot or char == ":") and funcStatus == 1 and 2) or 0
							end
						end
					elseif find(char,"%d") then
						local _,endPos = find(lineText,"%x+",col)
						local endPart = sub(lineText,endPos,endPos+1)
						if (endPart == "e+" or endPart == "e-") and find(sub(lineText,endPos+2,endPos+2),"%d") then
							endPos = endPos + 1
						end
						currentType = 6
						lastEnding = endPos
						highlights[col] = 6
						wordBeginsDotted = false
						lastWord = nil
						funcStatus = 0
					else
						highlights[col] = currentType
						local _,endPos = find(lineText,"%s+",col)
						if endPos then
							lastEnding = endPos
						end
					end
				end
			end

			self.ColoredLines[line] = highlights
			return highlights
		end

		funcs.Refresh = function(self)
			local start = tick()

			local linesFrame = self.Frame.Lines
			local hSize = math.max(0,linesFrame.AbsoluteSize.X)
			local vSize = math.max(0,linesFrame.AbsoluteSize.Y)
			local maxLines = math.ceil(vSize / self.FontSize)
			local maxCols = math.ceil(hSize / math.ceil(self.FontSize/2))
			local gsub = string.gsub
			local sub = string.sub

			local viewX,viewY = self.ViewX,self.ViewY

			local lineNumberStr = ""

			for row = 1,maxLines do
				local lineFrame = self.LineFrames[row]
				if not lineFrame then
					lineFrame = Instance.new("Frame")
					lineFrame.Name = "Line"
					lineFrame.Position = UDim2.new(0,0,0,(row-1)*self.FontSize)
					lineFrame.Size = UDim2.new(1,0,0,self.FontSize)
					lineFrame.BorderSizePixel = 0
					lineFrame.BackgroundTransparency = 1
					
					local selectionHighlight = Instance.new("Frame")
					selectionHighlight.Name = "SelectionHighlight"
					selectionHighlight.BorderSizePixel = 0
					selectionHighlight.BackgroundColor3 = Settings.Theme.Syntax.SelectionBack
					selectionHighlight.Parent = lineFrame
					
					local label = Instance.new("TextLabel")
					label.Name = "Label"
					label.BackgroundTransparency = 1
					label.Font = Enum.Font.Code
					label.TextSize = self.FontSize
					label.Size = UDim2.new(1,0,0,self.FontSize)
					label.RichText = true
					label.TextXAlignment = Enum.TextXAlignment.Left
					label.TextColor3 = self.Colors.Text
					label.ZIndex = 2
					label.Parent = lineFrame
					
					lineFrame.Parent = linesFrame
					self.LineFrames[row] = lineFrame
				end

				local relaY = viewY + row
				local lineText = self.Lines[relaY] or ""
				local resText = ""
				local highlights = self:HighlightLine(relaY)
				local colStart = viewX + 1

				local richTemplates = self.RichTemplates
				local textTemplate = richTemplates.Text
				local selectionTemplate = richTemplates.Selection
				local curType = highlights[colStart]
				local curTemplate = richTemplates[typeMap[curType]] or textTemplate
				
				-- Selection Highlight
				local selectionRange = self.SelectionRange
				local selPos1 = selectionRange[1]
				local selPos2 = selectionRange[2]
				local selRow,selColumn = selPos1[2],selPos1[1]
				local sel2Row,sel2Column = selPos2[2],selPos2[1]
				local selRelaX,selRelaY = viewX,relaY-1
				
				if selRelaY >= selPos1[2] and selRelaY <= selPos2[2] then
					local fontSizeX = math.ceil(self.FontSize/2)
					local posX = (selRelaY == selPos1[2] and selPos1[1] or 0) - viewX
					local sizeX = (selRelaY == selPos2[2] and selPos2[1]-posX-viewX or maxCols+viewX)

					lineFrame.SelectionHighlight.Position = UDim2.new(0,posX*fontSizeX,0,0)
					lineFrame.SelectionHighlight.Size = UDim2.new(0,sizeX*fontSizeX,1,0)
					lineFrame.SelectionHighlight.Visible = true
				else
					lineFrame.SelectionHighlight.Visible = false
				end
				
				-- Selection Text Color for first char
				local inSelection = selRelaY >= selRow and selRelaY <= sel2Row and (selRelaY == selRow and viewX >= selColumn or selRelaY ~= selRow) and (selRelaY == sel2Row and viewX < sel2Column or selRelaY ~= sel2Row)
				if inSelection then
					curType = -999
					curTemplate = selectionTemplate
				end
				
				for col = 2,maxCols do
					local relaX = viewX + col
					local selRelaX = relaX-1
					local posType = highlights[relaX]
					
					-- Selection Text Color
					local inSelection = selRelaY >= selRow and selRelaY <= sel2Row and (selRelaY == selRow and selRelaX >= selColumn or selRelaY ~= selRow) and (selRelaY == sel2Row and selRelaX < sel2Column or selRelaY ~= sel2Row)
					if inSelection then
						posType = -999
					end
					
					if posType ~= curType then
						local template = (inSelection and selectionTemplate) or richTemplates[typeMap[posType]] or textTemplate
						
						if template ~= curTemplate then
							local nextText = gsub(sub(lineText,colStart,relaX-1),"['\"<>&]",richReplace)
							resText = resText .. (curTemplate ~= textTemplate and (curTemplate .. nextText .. "</font>") or nextText)
							colStart = relaX
							curTemplate = template
						end
						curType = posType
					end
				end

				local lastText = gsub(sub(lineText,colStart,viewX+maxCols),"['\"<>&]",richReplace)
				--warn("SUB",colStart,viewX+maxCols-1)
				if #lastText > 0 then
					resText = resText .. (curTemplate ~= textTemplate and (curTemplate .. lastText .. "</font>") or lastText)
				end

				if self.Lines[relaY] then
					lineNumberStr = lineNumberStr .. (relaY == self.CursorY and ("<b>"..relaY.."</b>\n") or relaY .. "\n")
				end

				lineFrame.Label.Text = resText
			end

			for i = maxLines+1,#self.LineFrames do
				self.LineFrames[i]:Destroy()
				self.LineFrames[i] = nil
			end

			self.Frame.LineNumbers.Text = lineNumberStr
			self:UpdateCursor()

			--print("REFRESH TIME",tick()-start)
		end

		funcs.UpdateView = function(self)
			local totalLinesStr = tostring(#self.Lines)
			local fontWidth = math.ceil(self.FontSize / 2)
			local linesOffset = #totalLinesStr*fontWidth + 4*fontWidth

			local linesFrame = self.Frame.Lines
			local hSize = linesFrame.AbsoluteSize.X
			local vSize = linesFrame.AbsoluteSize.Y
			local maxLines = math.ceil(vSize / self.FontSize)
			local totalWidth = self.MaxTextCols*fontWidth
			local scrollV = self.ScrollV
			local scrollH = self.ScrollH

			scrollV.VisibleSpace = maxLines
			scrollV.TotalSpace = #self.Lines + 1
			scrollH.VisibleSpace = math.ceil(hSize/fontWidth)
			scrollH.TotalSpace = self.MaxTextCols + 1

			scrollV.Gui.Visible = #self.Lines + 1 > maxLines
			scrollH.Gui.Visible = totalWidth > hSize

			local oldOffsets = self.FrameOffsets
			self.FrameOffsets = Vector2.new(scrollV.Gui.Visible and -16 or 0, scrollH.Gui.Visible and -16 or 0)
			if oldOffsets ~= self.FrameOffsets then
				self:UpdateView()
			else
				scrollV:ScrollTo(self.ViewY,true)
				scrollH:ScrollTo(self.ViewX,true)

				if scrollV.Gui.Visible and scrollH.Gui.Visible then
					scrollV.Gui.Size = UDim2.new(0,16,1,-16)
					scrollH.Gui.Size = UDim2.new(1,-16,0,16)
					self.GuiElems.ScrollCorner.Visible = true
				else
					scrollV.Gui.Size = UDim2.new(0,16,1,0)
					scrollH.Gui.Size = UDim2.new(1,0,0,16)
					self.GuiElems.ScrollCorner.Visible = false
				end

				self.ViewY = scrollV.Index
				self.ViewX = scrollH.Index
				self.Frame.Lines.Position = UDim2.new(0,linesOffset,0,0)
				self.Frame.Lines.Size = UDim2.new(1,-linesOffset+oldOffsets.X,1,oldOffsets.Y)
				self.Frame.LineNumbers.Position = UDim2.new(0,fontWidth,0,0)
				self.Frame.LineNumbers.Size = UDim2.new(0,#totalLinesStr*fontWidth,1,oldOffsets.Y)
				self.Frame.LineNumbers.TextSize = self.FontSize
			end
		end

		funcs.ProcessTextChange = function(self)
			local maxCols = 0
			local lines = self.Lines
			
			for i = 1,#lines do
				local lineLen = #lines[i]
				if lineLen > maxCols then
					maxCols = lineLen
				end
			end
			
			self.MaxTextCols = maxCols
			self:UpdateView()	
			self.Text = table.concat(self.Lines,"\n")
			self:MapNewLines()
			self:PreHighlight()
			self:Refresh()
			--self.TextChanged:Fire()
		end
		
		funcs.ConvertText = function(self,text,toEditor)
			if toEditor then
				return text:gsub("\t",(" %s%s "):format(tabSub,tabSub))
			else
				return text:gsub((" %s%s "):format(tabSub,tabSub),"\t")
			end
		end

		funcs.GetText = function(self) -- TODO: better (use new tab format)
			local source = table.concat(self.Lines,"\n")
			return self:ConvertText(source,false) -- Tab Convert
		end

		funcs.SetText = function(self,txt)
			txt = self:ConvertText(txt,true) -- Tab Convert
			local lines = self.Lines
			table.clear(lines)
			local count = 1

			for line in txt:gmatch("([^\n\r]*)[\n\r]?") do
				local len = #line
				lines[count] = line
				count = count + 1
			end
			
			self:ProcessTextChange()
		end

		funcs.MakeRichTemplates = function(self)
			local floor = math.floor
			local templates = {}

			for name,color in pairs(self.Colors) do
				templates[name] = ('<font color="rgb(%s,%s,%s)">'):format(floor(color.r*255),floor(color.g*255),floor(color.b*255))
			end

			self.RichTemplates = templates
		end

		funcs.ApplyTheme = function(self)
			local colors = Settings.Theme.Syntax
			self.Colors = colors
			self.Frame.LineNumbers.TextColor3 = colors.Text
			self.Frame.BackgroundColor3 = colors.Background
		end

		local mt = {__index = funcs}

		local function new()
			if not builtInInited then initBuiltIn() end

			local scrollV = Lib.ScrollBar.new()
			local scrollH = Lib.ScrollBar.new(true)
			scrollH.Gui.Position = UDim2.new(0,0,1,-16)
			local obj = setmetatable({
				FontSize = 15,
				ViewX = 0,
				ViewY = 0,
				Colors = Settings.Theme.Syntax,
				ColoredLines = {},
				Lines = {""},
				LineFrames = {},
				Editable = true,
				Editing = false,
				CursorX = 0,
				CursorY = 0,
				FloatCursorX = 0,
				Text = "",
				PreHighlights = {},
				SelectionRange = {{-1,-1},{-1,-1}},
				NewLines = {},
				FrameOffsets = Vector2.new(0,0),
				MaxTextCols = 0,
				ScrollV = scrollV,
				ScrollH = scrollH
			},mt)

			scrollV.WheelIncrement = 3
			scrollH.Increment = 2
			scrollH.WheelIncrement = 7

			scrollV.Scrolled:Connect(function()
				obj.ViewY = scrollV.Index
				obj:Refresh()
			end)

			scrollH.Scrolled:Connect(function()
				obj.ViewX = scrollH.Index
				obj:Refresh()
			end)

			makeFrame(obj)
			obj:MakeRichTemplates()
			obj:ApplyTheme()
			scrollV:SetScrollFrame(obj.Frame.Lines)
			scrollV.Gui.Parent = obj.Frame
			scrollH.Gui.Parent = obj.Frame

			obj:UpdateView()
			obj.Frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
				obj:UpdateView()
				obj:Refresh()
			end)

			return obj
		end

		return {new = new}
	end)()

	Lib.Checkbox = (function()
		local funcs = {}
		local c3 = Color3.fromRGB
		local v2 = Vector2.new
		local ud2s = UDim2.fromScale
		local ud2o = UDim2.fromOffset
		local ud = UDim.new
		local max = math.max
		local new = Instance.new
		local TweenSize = new("Frame").TweenSize
		local ti = TweenInfo.new
		local delay = delay

		local function ripple(object, color)
			local circle = new('Frame')
			circle.BackgroundColor3 = color
			circle.BackgroundTransparency = 0.75
			circle.BorderSizePixel = 0
			circle.AnchorPoint = v2(0.5, 0.5)
			circle.Size = ud2o()
			circle.Position = ud2s(0.5, 0.5)
			circle.Parent = object
			local rounding = new('UICorner')
			rounding.CornerRadius = ud(1)
			rounding.Parent = circle

			local abssz = object.AbsoluteSize
			local size = max(abssz.X, abssz.Y) * 5/3

			TweenSize(circle, ud2o(size, size), "Out", "Quart", 0.4)
			service.TweenService:Create(circle, ti(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {BackgroundTransparency = 1}):Play()

			service.Debris:AddItem(circle, 0.4)
		end

		local function initGui(self,frame)
			local checkbox = frame or create({
				{1,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="Checkbox",Position=UDim2.new(0,3,0,3),Size=UDim2.new(0,16,0,16),}},
				{2,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="ripples",Parent={1},Size=UDim2.new(1,0,1,0),}},
				{3,"Frame",{BackgroundColor3=Color3.new(0.10196078568697,0.10196078568697,0.10196078568697),BorderSizePixel=0,Name="outline",Parent={1},Size=UDim2.new(0,16,0,16),}},
				{4,"Frame",{BackgroundColor3=Color3.new(0.14117647707462,0.14117647707462,0.14117647707462),BorderSizePixel=0,Name="filler",Parent={3},Position=UDim2.new(0,1,0,1),Size=UDim2.new(0,14,0,14),}},
				{5,"Frame",{BackgroundColor3=Color3.new(0.90196084976196,0.90196084976196,0.90196084976196),BorderSizePixel=0,Name="top",Parent={4},Size=UDim2.new(0,16,0,0),}},
				{6,"Frame",{AnchorPoint=Vector2.new(0,1),BackgroundColor3=Color3.new(0.90196084976196,0.90196084976196,0.90196084976196),BorderSizePixel=0,Name="bottom",Parent={4},Position=UDim2.new(0,0,0,14),Size=UDim2.new(0,16,0,0),}},
				{7,"Frame",{BackgroundColor3=Color3.new(0.90196084976196,0.90196084976196,0.90196084976196),BorderSizePixel=0,Name="left",Parent={4},Size=UDim2.new(0,0,0,16),}},
				{8,"Frame",{AnchorPoint=Vector2.new(1,0),BackgroundColor3=Color3.new(0.90196084976196,0.90196084976196,0.90196084976196),BorderSizePixel=0,Name="right",Parent={4},Position=UDim2.new(0,14,0,0),Size=UDim2.new(0,0,0,16),}},
				{9,"Frame",{AnchorPoint=Vector2.new(0.5,0.5),BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,ClipsDescendants=true,Name="checkmark",Parent={4},Position=UDim2.new(0.5,0,0.5,0),Size=UDim2.new(0,0,0,20),}},
				{10,"ImageLabel",{AnchorPoint=Vector2.new(0.5,0.5),BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Image="rbxassetid://6234266378",Parent={9},Position=UDim2.new(0.5,0,0.5,0),ScaleType=3,Size=UDim2.new(0,15,0,11),}},
				{11,"ImageLabel",{AnchorPoint=Vector2.new(0.5,0.5),BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://6401617475",ImageColor3=Color3.new(0.20784313976765,0.69803923368454,0.98431372642517),Name="checkmark2",Parent={4},Position=UDim2.new(0.5,0,0.5,0),Size=UDim2.new(0,12,0,12),Visible=false,}},
				{12,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://6425281788",ImageTransparency=0.20000000298023,Name="middle",Parent={4},ScaleType=2,Size=UDim2.new(1,0,1,0),TileSize=UDim2.new(0,2,0,2),Visible=false,}},
				{13,"UICorner",{CornerRadius=UDim.new(0,2),Parent={3},}},
			})
			local outline = checkbox.outline
			local filler = outline.filler
			local checkmark = filler.checkmark
			local ripples_container = checkbox.ripples

			-- walls
			local top, bottom, left, right = filler.top, filler.bottom, filler.left, filler.right

			self.Gui = checkbox
			self.GuiElems = {
				Top = top,
				Bottom = bottom,
				Left = left,
				Right = right,
				Outline = outline,
				Filler = filler,
				Checkmark = checkmark,
				Checkmark2 = filler.checkmark2,
				Middle = filler.middle
			}

			checkbox.InputBegan:Connect(function(i)
				if i.UserInputType == Enum.UserInputType.MouseButton1 then
					local release
					release = service.UserInputService.InputEnded:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseButton1 then
							release:Disconnect()

							if Lib.CheckMouseInGui(checkbox) then
								if self.Style == 0 then
									ripple(ripples_container, self.Disabled and self.Colors.Disabled or self.Colors.Primary)
								end

								if not self.Disabled then
									self:SetState(not self.Toggled,true)
								else
									self:Paint()
								end

								self.OnInput:Fire()
							end
						end
					end)
				end
			end)

			self:Paint()
		end

		funcs.Collapse = function(self,anim)
			local guiElems = self.GuiElems
			if anim then
				TweenSize(guiElems.Top, ud2o(14, 14), "In", "Quart", 4/15, true)
				TweenSize(guiElems.Bottom, ud2o(14, 14), "In", "Quart", 4/15, true)
				TweenSize(guiElems.Left, ud2o(14, 14), "In", "Quart", 4/15, true)
				TweenSize(guiElems.Right, ud2o(14, 14), "In", "Quart", 4/15, true)
			else
				guiElems.Top.Size = ud2o(14, 14)
				guiElems.Bottom.Size = ud2o(14, 14)
				guiElems.Left.Size = ud2o(14, 14)
				guiElems.Right.Size = ud2o(14, 14)
			end
		end

		funcs.Expand = function(self,anim)
			local guiElems = self.GuiElems
			if anim then
				TweenSize(guiElems.Top, ud2o(14, 0), "InOut", "Quart", 4/15, true)
				TweenSize(guiElems.Bottom, ud2o(14, 0), "InOut", "Quart", 4/15, true)
				TweenSize(guiElems.Left, ud2o(0, 14), "InOut", "Quart", 4/15, true)
				TweenSize(guiElems.Right, ud2o(0, 14), "InOut", "Quart", 4/15, true)
			else
				guiElems.Top.Size = ud2o(14, 0)
				guiElems.Bottom.Size = ud2o(14, 0)
				guiElems.Left.Size = ud2o(0, 14)
				guiElems.Right.Size = ud2o(0, 14)
			end
		end

		funcs.Paint = function(self)
			local guiElems = self.GuiElems

			if self.Style == 0 then
				local color_base = self.Disabled and self.Colors.Disabled
				guiElems.Outline.BackgroundColor3 = color_base or (self.Toggled and self.Colors.Primary) or self.Colors.Secondary
				local walls_color = color_base or self.Colors.Primary
				guiElems.Top.BackgroundColor3 = walls_color
				guiElems.Bottom.BackgroundColor3 = walls_color
				guiElems.Left.BackgroundColor3 = walls_color
				guiElems.Right.BackgroundColor3 = walls_color
			else
				guiElems.Outline.BackgroundColor3 = self.Disabled and self.Colors.Disabled or self.Colors.Secondary
				guiElems.Filler.BackgroundColor3 = self.Disabled and self.Colors.DisabledBackground or self.Colors.Background
				guiElems.Checkmark2.ImageColor3 = self.Disabled and self.Colors.DisabledCheck or self.Colors.Primary
			end
		end

		funcs.SetState = function(self,val,anim)
			self.Toggled = val

			if self.OutlineColorTween then self.OutlineColorTween:Cancel() end
			local setStateTime = tick()
			self.LastSetStateTime = setStateTime

			if self.Toggled then
				if self.Style == 0 then
					if anim then
						self.OutlineColorTween = service.TweenService:Create(self.GuiElems.Outline, ti(4/15, Enum.EasingStyle.Circular, Enum.EasingDirection.Out), {BackgroundColor3 = self.Colors.Primary})
						self.OutlineColorTween:Play()
						delay(0.15, function()
							if setStateTime ~= self.LastSetStateTime then return end
							self:Paint()
							TweenSize(self.GuiElems.Checkmark, ud2o(14, 20), "Out", "Bounce", 2/15, true)
						end)
					else
						self.GuiElems.Outline.BackgroundColor3 = self.Colors.Primary
						self:Paint()
						self.GuiElems.Checkmark.Size = ud2o(14, 20)
					end
					self:Collapse(anim)
				else
					self:Paint()
					self.GuiElems.Checkmark2.Visible = true
					self.GuiElems.Middle.Visible = false
				end
			else
				if self.Style == 0 then
					if anim then
						self.OutlineColorTween = service.TweenService:Create(self.GuiElems.Outline, ti(4/15, Enum.EasingStyle.Circular, Enum.EasingDirection.In), {BackgroundColor3 = self.Colors.Secondary})
						self.OutlineColorTween:Play()
						delay(0.15, function()
							if setStateTime ~= self.LastSetStateTime then return end
							self:Paint()
							TweenSize(self.GuiElems.Checkmark, ud2o(0, 20), "Out", "Quad", 1/15, true)
						end)
					else
						self.GuiElems.Outline.BackgroundColor3 = self.Colors.Secondary
						self:Paint()
						self.GuiElems.Checkmark.Size = ud2o(0, 20)
					end
					self:Expand(anim)
				else
					self:Paint()
					self.GuiElems.Checkmark2.Visible = false
					self.GuiElems.Middle.Visible = self.Toggled == nil
				end
			end
		end

		local mt = {__index = funcs}

		local function new(style)
			local obj = setmetatable({
				Toggled = false,
				Disabled = false,
				OnInput = Lib.Signal.new(),
				Style = style or 0,
				Colors = {
					Background = c3(36,36,36),
					Primary = c3(49,176,230),
					Secondary = c3(25,25,25),
					Disabled = c3(64,64,64),
					DisabledBackground = c3(52,52,52),
					DisabledCheck = c3(80,80,80)
				}
			},mt)
			initGui(obj)
			return obj
		end

		local function fromFrame(frame)
			local obj = setmetatable({
				Toggled = false,
				Disabled = false,
				Colors = {
					Background = c3(36,36,36),
					Primary = c3(49,176,230),
					Secondary = c3(25,25,25),
					Disabled = c3(64,64,64),
					DisabledBackground = c3(52,52,52)
				}
			},mt)
			initGui(obj,frame)
			return obj
		end

		return {new = new, fromFrame}
	end)()

	Lib.BrickColorPicker = (function()
		local funcs = {}
		local paletteCount = 0
		local mouse = service.Players.LocalPlayer:GetMouse()
		local hexStartX = 4
		local hexSizeX = 27
		local hexTriangleStart = 1
		local hexTriangleSize = 8

		local bottomColors = {
			Color3.fromRGB(17,17,17),
			Color3.fromRGB(99,95,98),
			Color3.fromRGB(163,162,165),
			Color3.fromRGB(205,205,205),
			Color3.fromRGB(223,223,222),
			Color3.fromRGB(237,234,234),
			Color3.fromRGB(27,42,53),
			Color3.fromRGB(91,93,105),
			Color3.fromRGB(159,161,172),
			Color3.fromRGB(202,203,209),
			Color3.fromRGB(231,231,236),
			Color3.fromRGB(248,248,248)
		}

		local function isMouseInHexagon(hex)
			local relativeX = mouse.X - hex.AbsolutePosition.X
			local relativeY = mouse.Y - hex.AbsolutePosition.Y
			if relativeX >= hexStartX and relativeX < hexStartX + hexSizeX then
				relativeX = relativeX - 4
				local relativeWidth = (13-math.min(relativeX,26 - relativeX))/13
				if relativeY >= hexTriangleStart + hexTriangleSize*relativeWidth and relativeY < hex.AbsoluteSize.Y - hexTriangleStart - hexTriangleSize*relativeWidth then
					return true
				end
			end

			return false
		end

		local function hexInput(self,hex,color)
			hex.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 and isMouseInHexagon(hex) then
					self.OnSelect:Fire(color)
					self:Close()
				end
			end)

			hex.InputChanged:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement and isMouseInHexagon(hex) then
					self.OnPreview:Fire(color)
				end
			end)
		end

		local function createGui(self)
			local gui = create({
				{1,"ScreenGui",{Name="BrickColor",}},
				{2,"Frame",{Active=true,BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderColor3=Color3.new(0.1294117718935,0.1294117718935,0.1294117718935),Parent={1},Position=UDim2.new(0.40000000596046,0,0.40000000596046,0),Size=UDim2.new(0,337,0,380),}},
				{3,"TextButton",{BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),BorderSizePixel=0,Font=3,Name="MoreColors",Parent={2},Position=UDim2.new(0,5,1,-30),Size=UDim2.new(1,-10,0,25),Text="More Colors",TextColor3=Color3.new(1,1,1),TextSize=14,}},
				{4,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Image="rbxassetid://1281023007",ImageColor3=Color3.new(0.33333334326744,0.33333334326744,0.49803924560547),Name="Hex",Parent={2},Size=UDim2.new(0,35,0,35),Visible=false,}},
			})
			local colorFrame = gui.Frame
			local hex = colorFrame.Hex

			for row = 1,13 do
				local columns = math.min(row,14-row)+6
				for column = 1,columns do
					local nextColor = BrickColor.palette(paletteCount).Color
					local newHex = hex:Clone()
					newHex.Position = UDim2.new(0, (column-1)*25-(columns-7)*13+3*26 + 1, 0, (row-1)*23 + 4)
					newHex.ImageColor3 = nextColor
					newHex.Visible = true
					hexInput(self,newHex,nextColor)
					newHex.Parent = colorFrame
					paletteCount = paletteCount + 1
				end
			end

			for column = 1,12 do
				local nextColor = bottomColors[column]
				local newHex = hex:Clone()
				newHex.Position = UDim2.new(0, (column-1)*25-(12-7)*13+3*26 + 3, 0, 308)
				newHex.ImageColor3 = nextColor
				newHex.Visible = true
				hexInput(self,newHex,nextColor)
				newHex.Parent = colorFrame
				paletteCount = paletteCount + 1
			end

			colorFrame.MoreColors.MouseButton1Click:Connect(function()
				self.OnMoreColors:Fire()
				self:Close()
			end)

			self.Gui = gui
		end

		funcs.SetMoreColorsVisible = function(self,vis)
			local colorFrame = self.Gui.Frame
			colorFrame.Size = UDim2.new(0,337,0,380 - (not vis and 33 or 0))
			colorFrame.MoreColors.Visible = vis
		end

		funcs.Show = function(self,x,y,prevColor)
			self.PrevColor = prevColor or self.PrevColor

			local reverseY = false

			local x,y = x or mouse.X, y or mouse.Y
			local maxX,maxY = mouse.ViewSizeX,mouse.ViewSizeY
			Lib.ShowGui(self.Gui)
			local sizeX,sizeY = self.Gui.Frame.AbsoluteSize.X,self.Gui.Frame.AbsoluteSize.Y

			if x + sizeX > maxX then x = self.ReverseX and x - sizeX or maxX - sizeX end
			if y + sizeY > maxY then reverseY = true end

			local closable = false
			if self.CloseEvent then self.CloseEvent:Disconnect() end
			self.CloseEvent = service.UserInputService.InputBegan:Connect(function(input)
				if not closable or input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end

				if not Lib.CheckMouseInGui(self.Gui.Frame) then
					self.CloseEvent:Disconnect()
					self:Close()
				end
			end)

			if reverseY then
				local newY = y - sizeY - (self.ReverseYOffset or 0)
				y = newY >= 0 and newY or 0
			end

			self.Gui.Frame.Position = UDim2.new(0,x,0,y)

			Lib.FastWait()
			closable = true
		end

		funcs.Close = function(self)
			self.Gui.Parent = nil
			self.OnCancel:Fire()
		end

		local mt = {__index = funcs}

		local function new()
			local obj = setmetatable({
				OnPreview = Lib.Signal.new(),
				OnSelect = Lib.Signal.new(),
				OnCancel = Lib.Signal.new(),
				OnMoreColors = Lib.Signal.new(),
				PrevColor = Color3.new(0,0,0)
			},mt)
			createGui(obj)
			return obj
		end

		return {new = new}
	end)()

	Lib.ColorPicker = (function() -- TODO: Convert to newer class model
		local funcs = {}

		local function new()
			local newMt = setmetatable({},{})

			newMt.OnSelect = Lib.Signal.new()
			newMt.OnCancel = Lib.Signal.new()
			newMt.OnPreview = Lib.Signal.new()

			local guiContents = create({
				{1,"Frame",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderSizePixel=0,ClipsDescendants=true,Name="Content",Position=UDim2.new(0,0,0,20),Size=UDim2.new(1,0,1,-20),}},
				{2,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Name="BasicColors",Parent={1},Position=UDim2.new(0,5,0,5),Size=UDim2.new(0,180,0,200),}},
				{3,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={2},Position=UDim2.new(0,0,0,-5),Size=UDim2.new(1,0,0,26),Text="Basic Colors",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{4,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Blue",Parent={1},Position=UDim2.new(1,-63,0,255),Size=UDim2.new(0,52,0,16),}},
				{5,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),Font=3,Name="Input",Parent={4},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,50,0,16),Text="0",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{6,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="ArrowFrame",Parent={5},Position=UDim2.new(1,-16,0,0),Size=UDim2.new(0,16,1,0),}},
				{7,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Up",Parent={6},Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{8,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={7},Size=UDim2.new(0,16,0,8),}},
				{9,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={8},Position=UDim2.new(0,8,0,3),Size=UDim2.new(0,1,0,1),}},
				{10,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={8},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{11,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={8},Position=UDim2.new(0,6,0,5),Size=UDim2.new(0,5,0,1),}},
				{12,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Down",Parent={6},Position=UDim2.new(0,0,0,8),Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{13,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={12},Size=UDim2.new(0,16,0,8),}},
				{14,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={13},Position=UDim2.new(0,8,0,5),Size=UDim2.new(0,1,0,1),}},
				{15,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={13},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{16,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={13},Position=UDim2.new(0,6,0,3),Size=UDim2.new(0,5,0,1),}},
				{17,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={4},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Blue:",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{18,"Frame",{BackgroundColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),BorderSizePixel=0,ClipsDescendants=true,Name="ColorSpaceFrame",Parent={1},Position=UDim2.new(1,-261,0,4),Size=UDim2.new(0,222,0,202),}},
				{19,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),BorderSizePixel=0,Image="rbxassetid://1072518406",Name="ColorSpace",Parent={18},Position=UDim2.new(0,1,0,1),Size=UDim2.new(0,220,0,200),}},
				{20,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="Scope",Parent={19},Position=UDim2.new(0,210,0,190),Size=UDim2.new(0,20,0,20),}},
				{21,"Frame",{BackgroundColor3=Color3.new(0,0,0),BorderSizePixel=0,Name="Line",Parent={20},Position=UDim2.new(0,9,0,0),Size=UDim2.new(0,2,0,20),}},
				{22,"Frame",{BackgroundColor3=Color3.new(0,0,0),BorderSizePixel=0,Name="Line",Parent={20},Position=UDim2.new(0,0,0,9),Size=UDim2.new(0,20,0,2),}},
				{23,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Name="CustomColors",Parent={1},Position=UDim2.new(0,5,0,210),Size=UDim2.new(0,180,0,90),}},
				{24,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={23},Size=UDim2.new(1,0,0,20),Text="Custom Colors (RC = Set)",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{25,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Green",Parent={1},Position=UDim2.new(1,-63,0,233),Size=UDim2.new(0,52,0,16),}},
				{26,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),Font=3,Name="Input",Parent={25},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,50,0,16),Text="0",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{27,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="ArrowFrame",Parent={26},Position=UDim2.new(1,-16,0,0),Size=UDim2.new(0,16,1,0),}},
				{28,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Up",Parent={27},Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{29,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={28},Size=UDim2.new(0,16,0,8),}},
				{30,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={29},Position=UDim2.new(0,8,0,3),Size=UDim2.new(0,1,0,1),}},
				{31,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={29},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{32,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={29},Position=UDim2.new(0,6,0,5),Size=UDim2.new(0,5,0,1),}},
				{33,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Down",Parent={27},Position=UDim2.new(0,0,0,8),Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{34,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={33},Size=UDim2.new(0,16,0,8),}},
				{35,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={34},Position=UDim2.new(0,8,0,5),Size=UDim2.new(0,1,0,1),}},
				{36,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={34},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{37,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={34},Position=UDim2.new(0,6,0,3),Size=UDim2.new(0,5,0,1),}},
				{38,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={25},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Green:",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{39,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Hue",Parent={1},Position=UDim2.new(1,-180,0,211),Size=UDim2.new(0,52,0,16),}},
				{40,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),Font=3,Name="Input",Parent={39},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,50,0,16),Text="0",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{41,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="ArrowFrame",Parent={40},Position=UDim2.new(1,-16,0,0),Size=UDim2.new(0,16,1,0),}},
				{42,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Up",Parent={41},Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{43,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={42},Size=UDim2.new(0,16,0,8),}},
				{44,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={43},Position=UDim2.new(0,8,0,3),Size=UDim2.new(0,1,0,1),}},
				{45,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={43},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{46,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={43},Position=UDim2.new(0,6,0,5),Size=UDim2.new(0,5,0,1),}},
				{47,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Down",Parent={41},Position=UDim2.new(0,0,0,8),Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{48,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={47},Size=UDim2.new(0,16,0,8),}},
				{49,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={48},Position=UDim2.new(0,8,0,5),Size=UDim2.new(0,1,0,1),}},
				{50,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={48},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{51,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={48},Position=UDim2.new(0,6,0,3),Size=UDim2.new(0,5,0,1),}},
				{52,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={39},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Hue:",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{53,"Frame",{BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Name="Preview",Parent={1},Position=UDim2.new(1,-260,0,211),Size=UDim2.new(0,35,1,-245),}},
				{54,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Red",Parent={1},Position=UDim2.new(1,-63,0,211),Size=UDim2.new(0,52,0,16),}},
				{55,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),Font=3,Name="Input",Parent={54},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,50,0,16),Text="0",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{56,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="ArrowFrame",Parent={55},Position=UDim2.new(1,-16,0,0),Size=UDim2.new(0,16,1,0),}},
				{57,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Up",Parent={56},Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{58,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={57},Size=UDim2.new(0,16,0,8),}},
				{59,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={58},Position=UDim2.new(0,8,0,3),Size=UDim2.new(0,1,0,1),}},
				{60,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={58},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{61,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={58},Position=UDim2.new(0,6,0,5),Size=UDim2.new(0,5,0,1),}},
				{62,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Down",Parent={56},Position=UDim2.new(0,0,0,8),Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{63,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={62},Size=UDim2.new(0,16,0,8),}},
				{64,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={63},Position=UDim2.new(0,8,0,5),Size=UDim2.new(0,1,0,1),}},
				{65,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={63},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{66,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={63},Position=UDim2.new(0,6,0,3),Size=UDim2.new(0,5,0,1),}},
				{67,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={54},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Red:",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{68,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Sat",Parent={1},Position=UDim2.new(1,-180,0,233),Size=UDim2.new(0,52,0,16),}},
				{69,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),Font=3,Name="Input",Parent={68},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,50,0,16),Text="0",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{70,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="ArrowFrame",Parent={69},Position=UDim2.new(1,-16,0,0),Size=UDim2.new(0,16,1,0),}},
				{71,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Up",Parent={70},Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{72,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={71},Size=UDim2.new(0,16,0,8),}},
				{73,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={72},Position=UDim2.new(0,8,0,3),Size=UDim2.new(0,1,0,1),}},
				{74,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={72},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{75,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={72},Position=UDim2.new(0,6,0,5),Size=UDim2.new(0,5,0,1),}},
				{76,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Down",Parent={70},Position=UDim2.new(0,0,0,8),Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{77,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={76},Size=UDim2.new(0,16,0,8),}},
				{78,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={77},Position=UDim2.new(0,8,0,5),Size=UDim2.new(0,1,0,1),}},
				{79,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={77},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{80,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={77},Position=UDim2.new(0,6,0,3),Size=UDim2.new(0,5,0,1),}},
				{81,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={68},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Sat:",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{82,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Val",Parent={1},Position=UDim2.new(1,-180,0,255),Size=UDim2.new(0,52,0,16),}},
				{83,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),Font=3,Name="Input",Parent={82},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,50,0,16),Text="255",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{84,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="ArrowFrame",Parent={83},Position=UDim2.new(1,-16,0,0),Size=UDim2.new(0,16,1,0),}},
				{85,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Up",Parent={84},Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{86,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={85},Size=UDim2.new(0,16,0,8),}},
				{87,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={86},Position=UDim2.new(0,8,0,3),Size=UDim2.new(0,1,0,1),}},
				{88,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={86},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{89,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={86},Position=UDim2.new(0,6,0,5),Size=UDim2.new(0,5,0,1),}},
				{90,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="Down",Parent={84},Position=UDim2.new(0,0,0,8),Size=UDim2.new(1,0,0,8),Text="",TextSize=14,}},
				{91,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={90},Size=UDim2.new(0,16,0,8),}},
				{92,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={91},Position=UDim2.new(0,8,0,5),Size=UDim2.new(0,1,0,1),}},
				{93,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={91},Position=UDim2.new(0,7,0,4),Size=UDim2.new(0,3,0,1),}},
				{94,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={91},Position=UDim2.new(0,6,0,3),Size=UDim2.new(0,5,0,1),}},
				{95,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={82},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Val:",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{96,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Font=3,Name="Cancel",Parent={1},Position=UDim2.new(1,-105,1,-28),Size=UDim2.new(0,100,0,25),Text="Cancel",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,}},
				{97,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Font=3,Name="Ok",Parent={1},Position=UDim2.new(1,-210,1,-28),Size=UDim2.new(0,100,0,25),Text="OK",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,}},
				{98,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Image="rbxassetid://1072518502",Name="ColorStrip",Parent={1},Position=UDim2.new(1,-30,0,5),Size=UDim2.new(0,13,0,200),}},
				{99,"Frame",{BackgroundColor3=Color3.new(0.3137255012989,0.3137255012989,0.3137255012989),BackgroundTransparency=1,BorderSizePixel=0,Name="ArrowFrame",Parent={1},Position=UDim2.new(1,-16,0,1),Size=UDim2.new(0,5,0,208),}},
				{100,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={99},Position=UDim2.new(0,-2,0,-4),Size=UDim2.new(0,8,0,16),}},
				{101,"Frame",{BackgroundColor3=Color3.new(0,0,0),BorderSizePixel=0,Parent={100},Position=UDim2.new(0,2,0,8),Size=UDim2.new(0,1,0,1),}},
				{102,"Frame",{BackgroundColor3=Color3.new(0,0,0),BorderSizePixel=0,Parent={100},Position=UDim2.new(0,3,0,7),Size=UDim2.new(0,1,0,3),}},
				{103,"Frame",{BackgroundColor3=Color3.new(0,0,0),BorderSizePixel=0,Parent={100},Position=UDim2.new(0,4,0,6),Size=UDim2.new(0,1,0,5),}},
				{104,"Frame",{BackgroundColor3=Color3.new(0,0,0),BorderSizePixel=0,Parent={100},Position=UDim2.new(0,5,0,5),Size=UDim2.new(0,1,0,7),}},
				{105,"Frame",{BackgroundColor3=Color3.new(0,0,0),BorderSizePixel=0,Parent={100},Position=UDim2.new(0,6,0,4),Size=UDim2.new(0,1,0,9),}},
			})
			local window = Lib.Window.new()
			window.Resizable = false
			window.Alignable = false
			window:SetTitle("Color Picker")
			window:Resize(450,330)
			for i,v in pairs(guiContents:GetChildren()) do
				v.Parent = window.GuiElems.Content
			end
			newMt.Window = window
			newMt.Gui = window.Gui
			local pickerGui = window.Gui.Main
			local pickerTopBar = pickerGui.TopBar
			local pickerFrame = pickerGui.Content
			local colorSpace = pickerFrame.ColorSpaceFrame.ColorSpace
			local colorStrip = pickerFrame.ColorStrip
			local previewFrame = pickerFrame.Preview
			local basicColorsFrame = pickerFrame.BasicColors
			local customColorsFrame = pickerFrame.CustomColors
			local okButton = pickerFrame.Ok
			local cancelButton = pickerFrame.Cancel
			local closeButton = pickerTopBar.Close

			local colorScope = colorSpace.Scope
			local colorArrow = pickerFrame.ArrowFrame.Arrow

			local hueInput = pickerFrame.Hue.Input
			local satInput = pickerFrame.Sat.Input
			local valInput = pickerFrame.Val.Input

			local redInput = pickerFrame.Red.Input
			local greenInput = pickerFrame.Green.Input
			local blueInput = pickerFrame.Blue.Input

			local user = cloneref(game:GetService("UserInputService"))
			local mouse = cloneref(game:GetService("Players")).LocalPlayer:GetMouse()

			local hue,sat,val = 0,0,1
			local red,green,blue = 1,1,1
			local chosenColor = Color3.new(0,0,0)

			local basicColors = {Color3.new(0,0,0),Color3.new(0.66666668653488,0,0),Color3.new(0,0.33333334326744,0),Color3.new(0.66666668653488,0.33333334326744,0),Color3.new(0,0.66666668653488,0),Color3.new(0.66666668653488,0.66666668653488,0),Color3.new(0,1,0),Color3.new(0.66666668653488,1,0),Color3.new(0,0,0.49803924560547),Color3.new(0.66666668653488,0,0.49803924560547),Color3.new(0,0.33333334326744,0.49803924560547),Color3.new(0.66666668653488,0.33333334326744,0.49803924560547),Color3.new(0,0.66666668653488,0.49803924560547),Color3.new(0.66666668653488,0.66666668653488,0.49803924560547),Color3.new(0,1,0.49803924560547),Color3.new(0.66666668653488,1,0.49803924560547),Color3.new(0,0,1),Color3.new(0.66666668653488,0,1),Color3.new(0,0.33333334326744,1),Color3.new(0.66666668653488,0.33333334326744,1),Color3.new(0,0.66666668653488,1),Color3.new(0.66666668653488,0.66666668653488,1),Color3.new(0,1,1),Color3.new(0.66666668653488,1,1),Color3.new(0.33333334326744,0,0),Color3.new(1,0,0),Color3.new(0.33333334326744,0.33333334326744,0),Color3.new(1,0.33333334326744,0),Color3.new(0.33333334326744,0.66666668653488,0),Color3.new(1,0.66666668653488,0),Color3.new(0.33333334326744,1,0),Color3.new(1,1,0),Color3.new(0.33333334326744,0,0.49803924560547),Color3.new(1,0,0.49803924560547),Color3.new(0.33333334326744,0.33333334326744,0.49803924560547),Color3.new(1,0.33333334326744,0.49803924560547),Color3.new(0.33333334326744,0.66666668653488,0.49803924560547),Color3.new(1,0.66666668653488,0.49803924560547),Color3.new(0.33333334326744,1,0.49803924560547),Color3.new(1,1,0.49803924560547),Color3.new(0.33333334326744,0,1),Color3.new(1,0,1),Color3.new(0.33333334326744,0.33333334326744,1),Color3.new(1,0.33333334326744,1),Color3.new(0.33333334326744,0.66666668653488,1),Color3.new(1,0.66666668653488,1),Color3.new(0.33333334326744,1,1),Color3.new(1,1,1)}
			local customColors = {}

			local function updateColor(noupdate)
				local relativeX,relativeY,relativeStripY = 219 - hue*219, 199 - sat*199, 199 - val*199
				local hsvColor = Color3.fromHSV(hue,sat,val)

				if noupdate == 2 or not noupdate then
					hueInput.Text = tostring(math.ceil(359*hue))
					satInput.Text = tostring(math.ceil(255*sat))
					valInput.Text = tostring(math.floor(255*val))
				end
				if noupdate == 1 or not noupdate then
					redInput.Text = tostring(math.floor(255*red))
					greenInput.Text = tostring(math.floor(255*green))
					blueInput.Text = tostring(math.floor(255*blue))
				end

				chosenColor = Color3.new(red,green,blue)

				colorScope.Position = UDim2.new(0,relativeX-9,0,relativeY-9)
				colorStrip.ImageColor3 = Color3.fromHSV(hue,sat,1)
				colorArrow.Position = UDim2.new(0,-2,0,relativeStripY-4)
				previewFrame.BackgroundColor3 = chosenColor

				newMt.Color = chosenColor
				newMt.OnPreview:Fire(chosenColor)
			end

			local function colorSpaceInput()
				local relativeX = mouse.X - colorSpace.AbsolutePosition.X
				local relativeY = mouse.Y - colorSpace.AbsolutePosition.Y

				if relativeX < 0 then relativeX = 0 elseif relativeX > 219 then relativeX = 219 end
				if relativeY < 0 then relativeY = 0 elseif relativeY > 199 then relativeY = 199 end

				hue = (219 - relativeX)/219
				sat = (199 - relativeY)/199

				local hsvColor = Color3.fromHSV(hue,sat,val)
				red,green,blue = hsvColor.r,hsvColor.g,hsvColor.b

				updateColor()
			end

			local function colorStripInput()
				local relativeY = mouse.Y - colorStrip.AbsolutePosition.Y

				if relativeY < 0 then relativeY = 0 elseif relativeY > 199 then relativeY = 199 end	

				val = (199 - relativeY)/199

				local hsvColor = Color3.fromHSV(hue,sat,val)
				red,green,blue = hsvColor.r,hsvColor.g,hsvColor.b

				updateColor()
			end

			local function hookButtons(frame,func)
				frame.ArrowFrame.Up.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						frame.ArrowFrame.Up.BackgroundTransparency = 0.5
					elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
						local releaseEvent,runEvent

						local startTime = tick()
						local pressing = true
						local startNum = tonumber(frame.Text)

						if not startNum then return end

						releaseEvent = user.InputEnded:Connect(function(input)
							if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
							releaseEvent:Disconnect()
							pressing = false
						end)

						startNum = startNum + 1
						func(startNum)
						while pressing do
							if tick()-startTime > 0.3 then
								startNum = startNum + 1
								func(startNum)
							end
							wait(0.1)
						end
					end
				end)

				frame.ArrowFrame.Up.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						frame.ArrowFrame.Up.BackgroundTransparency = 1
					end
				end)

				frame.ArrowFrame.Down.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						frame.ArrowFrame.Down.BackgroundTransparency = 0.5
					elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
						local releaseEvent,runEvent

						local startTime = tick()
						local pressing = true
						local startNum = tonumber(frame.Text)

						if not startNum then return end

						releaseEvent = user.InputEnded:Connect(function(input)
							if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
							releaseEvent:Disconnect()
							pressing = false
						end)

						startNum = startNum - 1
						func(startNum)
						while pressing do
							if tick()-startTime > 0.3 then
								startNum = startNum - 1
								func(startNum)
							end
							wait(0.1)
						end
					end
				end)

				frame.ArrowFrame.Down.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						frame.ArrowFrame.Down.BackgroundTransparency = 1
					end
				end)
			end

			colorSpace.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					local releaseEvent,mouseEvent

					releaseEvent = user.InputEnded:Connect(function(input)
						if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
						releaseEvent:Disconnect()
						mouseEvent:Disconnect()
					end)

					mouseEvent = user.InputChanged:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseMovement then
							colorSpaceInput()
						end
					end)

					colorSpaceInput()
				end
			end)

			colorStrip.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					local releaseEvent,mouseEvent

					releaseEvent = user.InputEnded:Connect(function(input)
						if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
						releaseEvent:Disconnect()
						mouseEvent:Disconnect()
					end)

					mouseEvent = user.InputChanged:Connect(function(input)
						if input.UserInputType == Enum.UserInputType.MouseMovement then
							colorStripInput()
						end
					end)

					colorStripInput()
				end
			end)

			local function updateHue(str)
				local num = tonumber(str)
				if num then
					hue = math.clamp(math.floor(num),0,359)/359
					local hsvColor = Color3.fromHSV(hue,sat,val)
					red,green,blue = hsvColor.r,hsvColor.g,hsvColor.b
					hueInput.Text = tostring(hue*359)
					updateColor(1)
				end
			end
			hueInput.FocusLost:Connect(function() updateHue(hueInput.Text) end) hookButtons(hueInput,updateHue)

			local function updateSat(str)
				local num = tonumber(str)
				if num then
					sat = math.clamp(math.floor(num),0,255)/255
					local hsvColor = Color3.fromHSV(hue,sat,val)
					red,green,blue = hsvColor.r,hsvColor.g,hsvColor.b
					satInput.Text = tostring(sat*255)
					updateColor(1)
				end
			end
			satInput.FocusLost:Connect(function() updateSat(satInput.Text) end) hookButtons(satInput,updateSat)

			local function updateVal(str)
				local num = tonumber(str)
				if num then
					val = math.clamp(math.floor(num),0,255)/255
					local hsvColor = Color3.fromHSV(hue,sat,val)
					red,green,blue = hsvColor.r,hsvColor.g,hsvColor.b
					valInput.Text = tostring(val*255)
					updateColor(1)
				end
			end
			valInput.FocusLost:Connect(function() updateVal(valInput.Text) end) hookButtons(valInput,updateVal)

			local function updateRed(str)
				local num = tonumber(str)
				if num then
					red = math.clamp(math.floor(num),0,255)/255
					local newColor = Color3.new(red,green,blue)
					hue,sat,val = Color3.toHSV(newColor)
					redInput.Text = tostring(red*255)
					updateColor(2)
				end
			end
			redInput.FocusLost:Connect(function() updateRed(redInput.Text) end) hookButtons(redInput,updateRed)

			local function updateGreen(str)
				local num = tonumber(str)
				if num then
					green = math.clamp(math.floor(num),0,255)/255
					local newColor = Color3.new(red,green,blue)
					hue,sat,val = Color3.toHSV(newColor)
					greenInput.Text = tostring(green*255)
					updateColor(2)
				end
			end
			greenInput.FocusLost:Connect(function() updateGreen(greenInput.Text) end) hookButtons(greenInput,updateGreen)

			local function updateBlue(str)
				local num = tonumber(str)
				if num then
					blue = math.clamp(math.floor(num),0,255)/255
					local newColor = Color3.new(red,green,blue)
					hue,sat,val = Color3.toHSV(newColor)
					blueInput.Text = tostring(blue*255)
					updateColor(2)
				end
			end
			blueInput.FocusLost:Connect(function() updateBlue(blueInput.Text) end) hookButtons(blueInput,updateBlue)

			local colorChoice = Instance.new("TextButton")
			colorChoice.Name = "Choice"
			colorChoice.Size = UDim2.new(0,25,0,18)
			colorChoice.BorderColor3 = Color3.fromRGB(55,55,55)
			colorChoice.Text = ""
			colorChoice.AutoButtonColor = false

			local row = 0
			local column = 0
			for i,v in pairs(basicColors) do
				local newColor = colorChoice:Clone()
				newColor.BackgroundColor3 = v
				newColor.Position = UDim2.new(0,1 + 30*column,0,21 + 23*row)

				newColor.MouseButton1Click:Connect(function()
					red,green,blue = v.r,v.g,v.b
					local newColor = Color3.new(red,green,blue)
					hue,sat,val = Color3.toHSV(newColor)
					updateColor()
				end)	

				newColor.Parent = basicColorsFrame
				column = column + 1
				if column == 6 then row = row + 1 column = 0 end
			end

			row = 0
			column = 0
			for i = 1,12 do
				local color = customColors[i] or Color3.new(0,0,0)
				local newColor = colorChoice:Clone()
				newColor.BackgroundColor3 = color
				newColor.Position = UDim2.new(0,1 + 30*column,0,20 + 23*row)

				newColor.MouseButton1Click:Connect(function()
					local curColor = customColors[i] or Color3.new(0,0,0)
					red,green,blue = curColor.r,curColor.g,curColor.b
					hue,sat,val = Color3.toHSV(curColor)
					updateColor()
				end)

				newColor.MouseButton2Click:Connect(function()
					customColors[i] = chosenColor
					newColor.BackgroundColor3 = chosenColor
				end)

				newColor.Parent = customColorsFrame
				column = column + 1
				if column == 6 then row = row + 1 column = 0 end
			end

			okButton.MouseButton1Click:Connect(function() newMt.OnSelect:Fire(chosenColor) window:Close() end)
			okButton.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then okButton.BackgroundTransparency = 0.4 end end)
			okButton.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then okButton.BackgroundTransparency = 0 end end)

			cancelButton.MouseButton1Click:Connect(function() newMt.OnCancel:Fire() window:Close() end)
			cancelButton.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then cancelButton.BackgroundTransparency = 0.4 end end)
			cancelButton.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then cancelButton.BackgroundTransparency = 0 end end)

			updateColor()

			newMt.SetColor = function(self,color)
				red,green,blue = color.r,color.g,color.b
				hue,sat,val = Color3.toHSV(color)
				updateColor()
			end

			newMt.Show = function(self)
				self.Window:Show()
			end

			return newMt
		end

		return {new = new}
	end)()

	Lib.NumberSequenceEditor = (function()
		local function new() -- TODO: Convert to newer class model
			local newMt = setmetatable({},{})
			newMt.OnSelect = Lib.Signal.new()
			newMt.OnCancel = Lib.Signal.new()
			newMt.OnPreview = Lib.Signal.new()

			local guiContents = create({
				{1,"Frame",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderSizePixel=0,ClipsDescendants=true,Name="Content",Position=UDim2.new(0,0,0,20),Size=UDim2.new(1,0,1,-20),}},
				{2,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Time",Parent={1},Position=UDim2.new(0,40,0,210),Size=UDim2.new(0,60,0,20),}},
				{3,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),ClipsDescendants=true,Font=3,Name="Input",Parent={2},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,58,0,20),Text="0",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{4,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={2},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Time",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{5,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Font=3,Name="Close",Parent={1},Position=UDim2.new(1,-90,0,210),Size=UDim2.new(0,80,0,20),Text="Close",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,}},
				{6,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Font=3,Name="Reset",Parent={1},Position=UDim2.new(1,-180,0,210),Size=UDim2.new(0,80,0,20),Text="Reset",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,}},
				{7,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Font=3,Name="Delete",Parent={1},Position=UDim2.new(0,380,0,210),Size=UDim2.new(0,80,0,20),Text="Delete",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,}},
				{8,"Frame",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Name="NumberLineOutlines",Parent={1},Position=UDim2.new(0,10,0,20),Size=UDim2.new(1,-20,0,170),}},
				{9,"Frame",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),Name="NumberLine",Parent={1},Position=UDim2.new(0,10,0,20),Size=UDim2.new(1,-20,0,170),}},
				{10,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Value",Parent={1},Position=UDim2.new(0,170,0,210),Size=UDim2.new(0,60,0,20),}},
				{11,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={10},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Value",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{12,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),ClipsDescendants=true,Font=3,Name="Input",Parent={10},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,58,0,20),Text="0",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{13,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Envelope",Parent={1},Position=UDim2.new(0,300,0,210),Size=UDim2.new(0,60,0,20),}},
				{14,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),ClipsDescendants=true,Font=3,Name="Input",Parent={13},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,58,0,20),Text="0",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{15,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={13},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Envelope",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
			})
			local window = Lib.Window.new()
			window.Resizable = false
			window:Resize(680,265)
			window:SetTitle("NumberSequence Editor")
			newMt.Window = window
			newMt.Gui = window.Gui
			for i,v in pairs(guiContents:GetChildren()) do
				v.Parent = window.GuiElems.Content
			end
			local gui = window.Gui
			local pickerGui = gui.Main
			local pickerTopBar = pickerGui.TopBar
			local pickerFrame = pickerGui.Content
			local numberLine = pickerFrame.NumberLine
			local numberLineOutlines = pickerFrame.NumberLineOutlines
			local timeBox = pickerFrame.Time.Input
			local valueBox = pickerFrame.Value.Input
			local envelopeBox = pickerFrame.Envelope.Input
			local deleteButton = pickerFrame.Delete
			local resetButton = pickerFrame.Reset
			local closeButton = pickerFrame.Close
			local topClose = pickerTopBar.Close

			local points = {{1,0,3},{8,0.05,1},{5,0.6,2},{4,0.7,4},{6,1,4}}
			local lines = {}
			local eLines = {}
			local beginPoint = points[1]
			local endPoint = points[#points]
			local currentlySelected = nil
			local currentPoint = nil
			local resetSequence = nil

			local user = cloneref(game:GetService("UserInputService"))
			local mouse = cloneref(game:GetService("Players")).LocalPlayer:GetMouse()

			for i = 2,10 do
				local newLine = Instance.new("Frame")
				newLine.BackgroundTransparency = 0.5
				newLine.BackgroundColor3 = Color3.new(96/255,96/255,96/255)
				newLine.BorderSizePixel = 0
				newLine.Size = UDim2.new(0,1,1,0)
				newLine.Position = UDim2.new((i-1)/(11-1),0,0,0)
				newLine.Parent = numberLineOutlines
			end

			for i = 2,4 do
				local newLine = Instance.new("Frame")
				newLine.BackgroundTransparency = 0.5
				newLine.BackgroundColor3 = Color3.new(96/255,96/255,96/255)
				newLine.BorderSizePixel = 0
				newLine.Size = UDim2.new(1,0,0,1)
				newLine.Position = UDim2.new(0,0,(i-1)/(5-1),0)
				newLine.Parent = numberLineOutlines
			end

			local lineTemp = Instance.new("Frame")
			lineTemp.BackgroundColor3 = Color3.new(0,0,0)
			lineTemp.BorderSizePixel = 0
			lineTemp.Size = UDim2.new(0,1,0,1)

			local sequenceLine = Instance.new("Frame")
			sequenceLine.BackgroundColor3 = Color3.new(0,0,0)
			sequenceLine.BorderSizePixel = 0
			sequenceLine.Size = UDim2.new(0,1,0,0)

			for i = 1,numberLine.AbsoluteSize.X do
				local line = sequenceLine:Clone()
				eLines[i] = line
				line.Name = "E"..tostring(i)
				line.BackgroundTransparency = 0.5
				line.BackgroundColor3 = Color3.new(199/255,44/255,28/255)
				line.Position = UDim2.new(0,i-1,0,0)
				line.Parent = numberLine
			end

			for i = 1,numberLine.AbsoluteSize.X do
				local line = sequenceLine:Clone()
				lines[i] = line
				line.Name = tostring(i)
				line.Position = UDim2.new(0,i-1,0,0)
				line.Parent = numberLine
			end

			local envelopeDrag = Instance.new("Frame")
			envelopeDrag.BackgroundTransparency = 1
			envelopeDrag.BackgroundColor3 = Color3.new(0,0,0)
			envelopeDrag.BorderSizePixel = 0
			envelopeDrag.Size = UDim2.new(0,7,0,20)
			envelopeDrag.Visible = false
			envelopeDrag.ZIndex = 2
			local envelopeDragLine = Instance.new("Frame",envelopeDrag)
			envelopeDragLine.Name = "Line"
			envelopeDragLine.BackgroundColor3 = Color3.new(0,0,0)
			envelopeDragLine.BorderSizePixel = 0
			envelopeDragLine.Position = UDim2.new(0,3,0,0)
			envelopeDragLine.Size = UDim2.new(0,1,0,20)
			envelopeDragLine.ZIndex = 2

			local envelopeDragTop,envelopeDragBottom = envelopeDrag:Clone(),envelopeDrag:Clone()
			envelopeDragTop.Parent = numberLine
			envelopeDragBottom.Parent = numberLine

			local function buildSequence()
				local newPoints = {}
				for i,v in pairs(points) do
					table.insert(newPoints,NumberSequenceKeypoint.new(v[2],v[1],v[3]))
				end
				newMt.Sequence = NumberSequence.new(newPoints)
				newMt.OnSelect:Fire(newMt.Sequence)
			end

			local function round(num,places)
				local multi = 10^places
				return math.floor(num*multi + 0.5)/multi
			end

			local function updateInputs(point)
				if point then
					currentPoint = point
					local rawT,rawV,rawE = point[2],point[1],point[3]
					timeBox.Text = round(rawT,(rawT < 0.01 and 5) or (rawT < 0.1 and 4) or 3)
					valueBox.Text = round(rawV,(rawV < 0.01 and 5) or (rawV < 0.1 and 4) or (rawV < 1 and 3) or 2)
					envelopeBox.Text = round(rawE,(rawE < 0.01 and 5) or (rawE < 0.1 and 4) or (rawV < 1 and 3) or 2)

					local envelopeDistance = numberLine.AbsoluteSize.Y*(point[3]/10)
					envelopeDragTop.Position = UDim2.new(0,point[4].Position.X.Offset-1,0,point[4].Position.Y.Offset-envelopeDistance-17)
					envelopeDragTop.Visible = true
					envelopeDragBottom.Position = UDim2.new(0,point[4].Position.X.Offset-1,0,point[4].Position.Y.Offset+envelopeDistance+2)
					envelopeDragBottom.Visible = true
				end
			end

			envelopeDragTop.InputBegan:Connect(function(input)
				if input.UserInputType ~= Enum.UserInputType.MouseButton1 or not currentPoint or Lib.CheckMouseInGui(currentPoint[4].Select) then return end
				local mouseEvent,releaseEvent
				local maxSize = numberLine.AbsoluteSize.Y

				local mouseDelta = math.abs(envelopeDragTop.AbsolutePosition.Y - mouse.Y)

				envelopeDragTop.Line.Position = UDim2.new(0,2,0,0)
				envelopeDragTop.Line.Size = UDim2.new(0,3,0,20)

				releaseEvent = user.InputEnded:Connect(function(input)
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
					mouseEvent:Disconnect()
					releaseEvent:Disconnect()
					envelopeDragTop.Line.Position = UDim2.new(0,3,0,0)
					envelopeDragTop.Line.Size = UDim2.new(0,1,0,20)
				end)

				mouseEvent = user.InputChanged:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						local topDiff = (currentPoint[4].AbsolutePosition.Y+2)-(mouse.Y-mouseDelta)-19
						local newEnvelope = 10*(math.max(topDiff,0)/maxSize)
						local maxEnvelope = math.min(currentPoint[1],10-currentPoint[1])
						currentPoint[3] = math.min(newEnvelope,maxEnvelope)
						newMt:Redraw()
						buildSequence()
						updateInputs(currentPoint)
					end
				end)
			end)

			envelopeDragBottom.InputBegan:Connect(function(input)
				if input.UserInputType ~= Enum.UserInputType.MouseButton1 or not currentPoint or Lib.CheckMouseInGui(currentPoint[4].Select) then return end
				local mouseEvent,releaseEvent
				local maxSize = numberLine.AbsoluteSize.Y

				local mouseDelta = math.abs(envelopeDragBottom.AbsolutePosition.Y - mouse.Y)

				envelopeDragBottom.Line.Position = UDim2.new(0,2,0,0)
				envelopeDragBottom.Line.Size = UDim2.new(0,3,0,20)

				releaseEvent = user.InputEnded:Connect(function(input)
					if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
					mouseEvent:Disconnect()
					releaseEvent:Disconnect()
					envelopeDragBottom.Line.Position = UDim2.new(0,3,0,0)
					envelopeDragBottom.Line.Size = UDim2.new(0,1,0,20)
				end)

				mouseEvent = user.InputChanged:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						local bottomDiff = (mouse.Y+(20-mouseDelta))-(currentPoint[4].AbsolutePosition.Y+2)-19
						local newEnvelope = 10*(math.max(bottomDiff,0)/maxSize)
						local maxEnvelope = math.min(currentPoint[1],10-currentPoint[1])
						currentPoint[3] = math.min(newEnvelope,maxEnvelope)
						newMt:Redraw()
						buildSequence()
						updateInputs(currentPoint)
					end
				end)
			end)

			local function placePoint(point)
				local newPoint = Instance.new("Frame")
				newPoint.Name = "Point"
				newPoint.BorderSizePixel = 0
				newPoint.Size = UDim2.new(0,5,0,5)
				newPoint.Position = UDim2.new(0,math.floor((numberLine.AbsoluteSize.X-1) * point[2])-2,0,numberLine.AbsoluteSize.Y*(10-point[1])/10-2)
				newPoint.BackgroundColor3 = Color3.new(0,0,0)

				local newSelect = Instance.new("Frame")
				newSelect.Name = "Select"
				newSelect.BackgroundTransparency = 1
				newSelect.BackgroundColor3 = Color3.new(199/255,44/255,28/255)
				newSelect.Position = UDim2.new(0,-2,0,-2)
				newSelect.Size = UDim2.new(0,9,0,9)
				newSelect.Parent = newPoint

				newPoint.Parent = numberLine

				newSelect.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						for i,v in pairs(points) do v[4].Select.BackgroundTransparency = 1 end
						newSelect.BackgroundTransparency = 0
						updateInputs(point)
					end
					if input.UserInputType == Enum.UserInputType.MouseButton1 and not currentlySelected then
						currentPoint = point
						local mouseEvent,releaseEvent
						currentlySelected = true
						newSelect.BackgroundColor3 = Color3.new(249/255,191/255,59/255)

						local oldEnvelope = point[3]

						releaseEvent = user.InputEnded:Connect(function(input)
							if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
							mouseEvent:Disconnect()
							releaseEvent:Disconnect()
							currentlySelected = nil
							newSelect.BackgroundColor3 = Color3.new(199/255,44/255,28/255)
						end)

						mouseEvent = user.InputChanged:Connect(function(input)
							if input.UserInputType == Enum.UserInputType.MouseMovement then
								local maxX = numberLine.AbsoluteSize.X-1
								local relativeX = mouse.X - numberLine.AbsolutePosition.X
								if relativeX < 0 then relativeX = 0 end
								if relativeX > maxX then relativeX = maxX end
								local maxY = numberLine.AbsoluteSize.Y-1
								local relativeY = mouse.Y - numberLine.AbsolutePosition.Y
								if relativeY < 0 then relativeY = 0 end
								if relativeY > maxY then relativeY = maxY end
								if point ~= beginPoint and point ~= endPoint then
									point[2] = relativeX/maxX
								end
								point[1] = 10-(relativeY/maxY)*10
								local maxEnvelope = math.min(point[1],10-point[1])
								point[3] = math.min(oldEnvelope,maxEnvelope)
								newMt:Redraw()
								updateInputs(point)
								for i,v in pairs(points) do v[4].Select.BackgroundTransparency = 1 end
								newSelect.BackgroundTransparency = 0
								buildSequence()
							end
						end)
					end
				end)

				return newPoint
			end

			local function placePoints()
				for i,v in pairs(points) do
					v[4] = placePoint(v)
				end
			end

			local function redraw(self)
				local numberLineSize = numberLine.AbsoluteSize
				table.sort(points,function(a,b) return a[2] < b[2] end)
				for i,v in pairs(points) do
					v[4].Position = UDim2.new(0,math.floor((numberLineSize.X-1) * v[2])-2,0,(numberLineSize.Y-1)*(10-v[1])/10-2)
				end
				lines[1].Size = UDim2.new(0,1,0,0)
				for i = 1,#points-1 do
					local fromPoint = points[i]
					local toPoint = points[i+1]
					local deltaY = toPoint[4].Position.Y.Offset-fromPoint[4].Position.Y.Offset
					local deltaX = toPoint[4].Position.X.Offset-fromPoint[4].Position.X.Offset
					local slope = deltaY/deltaX

					local fromEnvelope = fromPoint[3]
					local nextEnvelope = toPoint[3]

					local currentRise = math.abs(slope)
					local totalRise = 0
					local maxRise = math.abs(toPoint[4].Position.Y.Offset-fromPoint[4].Position.Y.Offset)

					for lineCount = math.min(fromPoint[4].Position.X.Offset+1,toPoint[4].Position.X.Offset),toPoint[4].Position.X.Offset do
						if deltaX == 0 and deltaY == 0 then return end
						local riseNow = math.floor(currentRise)
						local line = lines[lineCount+3]
						if line then
							if totalRise+riseNow > maxRise then riseNow = maxRise-totalRise end
							if math.sign(slope) == -1 then
								line.Position = UDim2.new(0,lineCount+2,0,fromPoint[4].Position.Y.Offset + -(totalRise+riseNow)+2)
							else
								line.Position = UDim2.new(0,lineCount+2,0,fromPoint[4].Position.Y.Offset + totalRise+2)
							end
							line.Size = UDim2.new(0,1,0,math.max(riseNow,1))
						end
						totalRise = totalRise + riseNow
						currentRise = currentRise - riseNow + math.abs(slope)

						local envPercent = (lineCount-fromPoint[4].Position.X.Offset)/(toPoint[4].Position.X.Offset-fromPoint[4].Position.X.Offset)
						local envLerp = fromEnvelope+(nextEnvelope-fromEnvelope)*envPercent
						local relativeSize = (envLerp/10)*numberLineSize.Y						

						local line = eLines[lineCount + 3]
						if line then
							line.Position = UDim2.new(0,lineCount+2,0,lines[lineCount+3].Position.Y.Offset-math.floor(relativeSize))
							line.Size = UDim2.new(0,1,0,math.floor(relativeSize*2))
						end
					end
				end
			end
			newMt.Redraw = redraw

			local function loadSequence(self,seq)
				resetSequence = seq
				for i,v in pairs(points) do if v[4] then v[4]:Destroy() end end
				points = {}
				for i,v in pairs(seq.Keypoints) do
					local maxEnvelope = math.min(v.Value,10-v.Value)
					local newPoint = {v.Value,v.Time,math.min(v.Envelope,maxEnvelope)}
					newPoint[4] = placePoint(newPoint)
					table.insert(points,newPoint)
				end
				beginPoint = points[1]
				endPoint = points[#points]
				currentlySelected = nil
				redraw()
				envelopeDragTop.Visible = false
				envelopeDragBottom.Visible = false
			end
			newMt.SetSequence = loadSequence

			timeBox.FocusLost:Connect(function()
				local point = currentPoint
				local num = tonumber(timeBox.Text)
				if point and num and point ~= beginPoint and point ~= endPoint then
					num = math.clamp(num,0,1)
					point[2] = num
					redraw()
					buildSequence()
					updateInputs(point)
				end
			end)

			valueBox.FocusLost:Connect(function()
				local point = currentPoint
				local num = tonumber(valueBox.Text)
				if point and num then
					local oldEnvelope = point[3]
					num = math.clamp(num,0,10)
					point[1] = num
					local maxEnvelope = math.min(point[1],10-point[1])
					point[3] = math.min(oldEnvelope,maxEnvelope)
					redraw()
					buildSequence()
					updateInputs(point)
				end
			end)

			envelopeBox.FocusLost:Connect(function()
				local point = currentPoint
				local num = tonumber(envelopeBox.Text)
				if point and num then
					num = math.clamp(num,0,5)
					local maxEnvelope = math.min(point[1],10-point[1])
					point[3] = math.min(num,maxEnvelope)
					redraw()
					buildSequence()
					updateInputs(point)
				end
			end)

			local function buttonAnimations(button,inverse)
				button.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then button.BackgroundTransparency = (inverse and 0.5 or 0.4) end end)
				button.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then button.BackgroundTransparency = (inverse and 1 or 0) end end)
			end

			numberLine.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 and #points < 20 then
					if Lib.CheckMouseInGui(envelopeDragTop) or Lib.CheckMouseInGui(envelopeDragBottom) then return end
					for i,v in pairs(points) do
						if Lib.CheckMouseInGui(v[4].Select) then return end
					end
					local maxX = numberLine.AbsoluteSize.X-1
					local relativeX = mouse.X - numberLine.AbsolutePosition.X
					if relativeX < 0 then relativeX = 0 end
					if relativeX > maxX then relativeX = maxX end
					local maxY = numberLine.AbsoluteSize.Y-1
					local relativeY = mouse.Y - numberLine.AbsolutePosition.Y
					if relativeY < 0 then relativeY = 0 end
					if relativeY > maxY then relativeY = maxY end

					local raw = relativeX/maxX
					local newPoint = {10-(relativeY/maxY)*10,raw,0}
					newPoint[4] = placePoint(newPoint)
					table.insert(points,newPoint)
					redraw()
					buildSequence()
				end
			end)

			deleteButton.MouseButton1Click:Connect(function()
				if currentPoint and currentPoint ~= beginPoint and currentPoint ~= endPoint then
					for i,v in pairs(points) do
						if v == currentPoint then
							v[4]:Destroy()
							table.remove(points,i)
							break
						end
					end
					currentlySelected = nil
					redraw()
					buildSequence()
					updateInputs(points[1])
				end
			end)

			resetButton.MouseButton1Click:Connect(function()
				if resetSequence then
					newMt:SetSequence(resetSequence)
					buildSequence()
				end
			end)

			closeButton.MouseButton1Click:Connect(function()
				window:Close()
			end)

			buttonAnimations(deleteButton)
			buttonAnimations(resetButton)
			buttonAnimations(closeButton)

			placePoints()
			redraw()

			newMt.Show = function(self)
				window:Show()
			end

			return newMt
		end

		return {new = new}
	end)()

	Lib.ColorSequenceEditor = (function() -- TODO: Convert to newer class model
		local function new()
			local newMt = setmetatable({},{})
			newMt.OnSelect = Lib.Signal.new()
			newMt.OnCancel = Lib.Signal.new()
			newMt.OnPreview = Lib.Signal.new()
			newMt.OnPickColor = Lib.Signal.new()

			local guiContents = create({
				{1,"Frame",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderSizePixel=0,ClipsDescendants=true,Name="Content",Position=UDim2.new(0,0,0,20),Size=UDim2.new(1,0,1,-20),}},
				{2,"Frame",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Name="ColorLine",Parent={1},Position=UDim2.new(0,10,0,5),Size=UDim2.new(1,-20,0,70),}},
				{3,"Frame",{BackgroundColor3=Color3.new(1,1,1),BorderSizePixel=0,Name="Gradient",Parent={2},Size=UDim2.new(1,0,1,0),}},
				{4,"UIGradient",{Parent={3},}},
				{5,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Name="Arrows",Parent={1},Position=UDim2.new(0,1,0,73),Size=UDim2.new(1,-2,0,16),}},
				{6,"Frame",{BackgroundColor3=Color3.new(0,0,0),BackgroundTransparency=0.5,BorderSizePixel=0,Name="Cursor",Parent={1},Position=UDim2.new(0,10,0,0),Size=UDim2.new(0,1,0,80),}},
				{7,"Frame",{BackgroundColor3=Color3.new(0.14901961386204,0.14901961386204,0.14901961386204),BorderColor3=Color3.new(0.12549020349979,0.12549020349979,0.12549020349979),Name="Time",Parent={1},Position=UDim2.new(0,40,0,95),Size=UDim2.new(0,100,0,20),}},
				{8,"TextBox",{BackgroundColor3=Color3.new(0.25098040699959,0.25098040699959,0.25098040699959),BackgroundTransparency=1,BorderColor3=Color3.new(0.37647062540054,0.37647062540054,0.37647062540054),ClipsDescendants=true,Font=3,Name="Input",Parent={7},Position=UDim2.new(0,2,0,0),Size=UDim2.new(0,98,0,20),Text="0",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=0,}},
				{9,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={7},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Time",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{10,"Frame",{BackgroundColor3=Color3.new(1,1,1),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),Name="ColorBox",Parent={1},Position=UDim2.new(0,220,0,95),Size=UDim2.new(0,20,0,20),}},
				{11,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Title",Parent={10},Position=UDim2.new(0,-40,0,0),Size=UDim2.new(0,34,1,0),Text="Color",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,TextXAlignment=1,}},
				{12,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),BorderSizePixel=0,Font=3,Name="Close",Parent={1},Position=UDim2.new(1,-90,0,95),Size=UDim2.new(0,80,0,20),Text="Close",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,}},
				{13,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),BorderSizePixel=0,Font=3,Name="Reset",Parent={1},Position=UDim2.new(1,-180,0,95),Size=UDim2.new(0,80,0,20),Text="Reset",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,}},
				{14,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderColor3=Color3.new(0.21568627655506,0.21568627655506,0.21568627655506),BorderSizePixel=0,Font=3,Name="Delete",Parent={1},Position=UDim2.new(0,280,0,95),Size=UDim2.new(0,80,0,20),Text="Delete",TextColor3=Color3.new(0.86274516582489,0.86274516582489,0.86274516582489),TextSize=14,}},
				{15,"Frame",{BackgroundTransparency=1,Name="Arrow",Parent={1},Size=UDim2.new(0,16,0,16),Visible=false,}},
				{16,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={15},Position=UDim2.new(0,8,0,3),Size=UDim2.new(0,1,0,2),}},
				{17,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={15},Position=UDim2.new(0,7,0,5),Size=UDim2.new(0,3,0,2),}},
				{18,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={15},Position=UDim2.new(0,6,0,7),Size=UDim2.new(0,5,0,2),}},
				{19,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={15},Position=UDim2.new(0,5,0,9),Size=UDim2.new(0,7,0,2),}},
				{20,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={15},Position=UDim2.new(0,4,0,11),Size=UDim2.new(0,9,0,2),}},
			})
			local window = Lib.Window.new()
			window.Resizable = false
			window:Resize(650,150)
			window:SetTitle("ColorSequence Editor")
			newMt.Window = window
			newMt.Gui = window.Gui
			for i,v in pairs(guiContents:GetChildren()) do
				v.Parent = window.GuiElems.Content
			end
			local gui = window.Gui
			local pickerGui = gui.Main
			local pickerTopBar = pickerGui.TopBar
			local pickerFrame = pickerGui.Content
			local colorLine = pickerFrame.ColorLine
			local gradient = colorLine.Gradient.UIGradient
			local arrowFrame = pickerFrame.Arrows
			local arrow = pickerFrame.Arrow
			local cursor = pickerFrame.Cursor
			local timeBox = pickerFrame.Time.Input
			local colorBox = pickerFrame.ColorBox
			local deleteButton = pickerFrame.Delete
			local resetButton = pickerFrame.Reset
			local closeButton = pickerFrame.Close
			local topClose = pickerTopBar.Close

			local user = cloneref(game:GetService("UserInputService"))
			local mouse = cloneref(game:GetService("Players")).LocalPlayer:GetMouse()

			local colors = {{Color3.new(1,0,1),0},{Color3.new(0.2,0.9,0.2),0.2},{Color3.new(0.4,0.5,0.9),0.7},{Color3.new(0.6,1,1),1}}
			local resetSequence = nil

			local beginPoint = colors[1]
			local endPoint = colors[#colors]

			local currentlySelected = nil
			local currentPoint = nil

			local sequenceLine = Instance.new("Frame")
			sequenceLine.BorderSizePixel = 0
			sequenceLine.Size = UDim2.new(0,1,1,0)

			newMt.Sequence = ColorSequence.new(Color3.new(1,1,1))
			local function buildSequence(noupdate)
				local newPoints = {}
				table.sort(colors,function(a,b) return a[2] < b[2] end)
				for i,v in pairs(colors) do
					table.insert(newPoints,ColorSequenceKeypoint.new(v[2],v[1]))
				end
				newMt.Sequence = ColorSequence.new(newPoints)
				if not noupdate then newMt.OnSelect:Fire(newMt.Sequence) end
			end

			local function round(num,places)
				local multi = 10^places
				return math.floor(num*multi + 0.5)/multi
			end

			local function updateInputs(point)
				if point then
					currentPoint = point
					local raw = point[2]
					timeBox.Text = round(raw,(raw < 0.01 and 5) or (raw < 0.1 and 4) or 3)
					colorBox.BackgroundColor3 = point[1]
				end
			end

			local function placeArrow(ind,point)
				local newArrow = arrow:Clone()
				newArrow.Position = UDim2.new(0,ind-1,0,0)
				newArrow.Visible = true
				newArrow.Parent = arrowFrame

				newArrow.InputBegan:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						cursor.Visible = true
						cursor.Position = UDim2.new(0,9 + newArrow.Position.X.Offset,0,0)
					end
					if input.UserInputType == Enum.UserInputType.MouseButton1 then
						updateInputs(point)
						if point == beginPoint or point == endPoint or currentlySelected then return end

						local mouseEvent,releaseEvent
						currentlySelected = true

						releaseEvent = user.InputEnded:Connect(function(input)
							if input.UserInputType ~= Enum.UserInputType.MouseButton1 then return end
							mouseEvent:Disconnect()
							releaseEvent:Disconnect()
							currentlySelected = nil
							cursor.Visible = false
						end)

						mouseEvent = user.InputChanged:Connect(function(input)
							if input.UserInputType == Enum.UserInputType.MouseMovement then
								local maxSize = colorLine.AbsoluteSize.X-1
								local relativeX = mouse.X - colorLine.AbsolutePosition.X
								if relativeX < 0 then relativeX = 0 end
								if relativeX > maxSize then relativeX = maxSize end
								local raw = relativeX/maxSize
								point[2] = relativeX/maxSize
								updateInputs(point)
								cursor.Visible = true
								cursor.Position = UDim2.new(0,9 + newArrow.Position.X.Offset,0,0)
								buildSequence()
								newMt:Redraw()
							end
						end)
					end
				end)

				newArrow.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType.MouseMovement then
						cursor.Visible = false
					end
				end)

				return newArrow
			end

			local function placeArrows()
				for i,v in pairs(colors) do
					v[3] = placeArrow(math.floor((colorLine.AbsoluteSize.X-1) * v[2]) + 1,v)
				end
			end

			local function redraw(self)
				gradient.Color = newMt.Sequence or ColorSequence.new(Color3.new(1,1,1))

				for i = 2,#colors do
					local nextColor = colors[i]
					local endPos = math.floor((colorLine.AbsoluteSize.X-1) * nextColor[2]) + 1
					nextColor[3].Position = UDim2.new(0,endPos,0,0)
				end		
			end
			newMt.Redraw = redraw

			local function loadSequence(self,seq)
				resetSequence = seq
				for i,v in pairs(colors) do if v[3] then v[3]:Destroy() end end
				colors = {}
				currentlySelected = nil
				for i,v in pairs(seq.Keypoints) do
					local newPoint = {v.Value,v.Time}
					newPoint[3] = placeArrow(v.Time,newPoint)
					table.insert(colors,newPoint)
				end
				beginPoint = colors[1]
				endPoint = colors[#colors]
				currentlySelected = nil
				updateInputs(colors[1])
				buildSequence(true)
				redraw()
			end
			newMt.SetSequence = loadSequence

			local function buttonAnimations(button,inverse)
				button.InputBegan:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then button.BackgroundTransparency = (inverse and 0.5 or 0.4) end end)
				button.InputEnded:Connect(function(input) if input.UserInputType == Enum.UserInputType.MouseMovement then button.BackgroundTransparency = (inverse and 1 or 0) end end)
			end

			colorLine.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 and #colors < 20 then
					local maxSize = colorLine.AbsoluteSize.X-1
					local relativeX = mouse.X - colorLine.AbsolutePosition.X
					if relativeX < 0 then relativeX = 0 end
					if relativeX > maxSize then relativeX = maxSize end

					local raw = relativeX/maxSize
					local fromColor = nil
					local toColor = nil
					for i,col in pairs(colors) do
						if col[2] >= raw then
							fromColor = colors[math.max(i-1,1)]
							toColor = colors[i]
							break
						end
					end
					local lerpColor = fromColor[1]:lerp(toColor[1],(raw-fromColor[2])/(toColor[2]-fromColor[2]))
					local newPoint = {lerpColor,raw}
					newPoint[3] = placeArrow(newPoint[2],newPoint)
					table.insert(colors,newPoint)
					updateInputs(newPoint)
					buildSequence()
					redraw()
				end
			end)

			colorLine.InputChanged:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement then
					local maxSize = colorLine.AbsoluteSize.X-1
					local relativeX = mouse.X - colorLine.AbsolutePosition.X
					if relativeX < 0 then relativeX = 0 end
					if relativeX > maxSize then relativeX = maxSize end
					cursor.Visible = true
					cursor.Position = UDim2.new(0,10 + relativeX,0,0)
				end
			end)

			colorLine.InputEnded:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseMovement then
					local inArrow = false
					for i,v in pairs(colors) do
						if Lib.CheckMouseInGui(v[3]) then
							inArrow = v[3]
						end
					end
					cursor.Visible = inArrow and true or false
					if inArrow then cursor.Position = UDim2.new(0,9 + inArrow.Position.X.Offset,0,0) end
				end
			end)

			timeBox:GetPropertyChangedSignal("Text"):Connect(function()
				local point = currentPoint
				local num = tonumber(timeBox.Text)
				if point and num and point ~= beginPoint and point ~= endPoint then
					num = math.clamp(num,0,1)
					point[2] = num
					buildSequence()
					redraw()
				end
			end)

			colorBox.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 then
					local editor = newMt.ColorPicker
					if not editor then
						editor = Lib.ColorPicker.new()
						editor.Window:SetTitle("ColorSequence Color Picker")

						editor.OnSelect:Connect(function(col)
							if currentPoint then
								currentPoint[1] = col
							end
							buildSequence()
							redraw()
						end)

						newMt.ColorPicker = editor
					end

					editor.Window:ShowAndFocus()
				end
			end)

			deleteButton.MouseButton1Click:Connect(function()
				if currentPoint and currentPoint ~= beginPoint and currentPoint ~= endPoint then
					for i,v in pairs(colors) do
						if v == currentPoint then
							v[3]:Destroy()
							table.remove(colors,i)
							break
						end
					end
					currentlySelected = nil
					updateInputs(colors[1])
					buildSequence()
					redraw()
				end
			end)

			resetButton.MouseButton1Click:Connect(function()
				if resetSequence then
					newMt:SetSequence(resetSequence)
				end
			end)

			closeButton.MouseButton1Click:Connect(function()
				window:Close()
			end)

			topClose.MouseButton1Click:Connect(function()
				window:Close()
			end)

			buttonAnimations(deleteButton)
			buttonAnimations(resetButton)
			buttonAnimations(closeButton)

			placeArrows()
			redraw()

			newMt.Show = function(self)
				window:Show()
			end

			return newMt
		end

		return {new = new}
	end)()

	Lib.ViewportTextBox = (function()
		local textService = cloneref(game:GetService("TextService"))

		local props = {
			OffsetX = 0,
			TextBox = PH,
			CursorPos = -1,
			Gui = PH,
			View = PH
		}
		local funcs = {}
		funcs.Update = function(self)
			local cursorPos = self.CursorPos or -1
			local text = self.TextBox.Text
			if text == "" then self.TextBox.Position = UDim2.new(0,0,0,0) return end
			if cursorPos == -1 then return end

			local cursorText = text:sub(1,cursorPos-1)
			local pos = nil
			local leftEnd = -self.TextBox.Position.X.Offset
			local rightEnd = leftEnd + self.View.AbsoluteSize.X

			local totalTextSize = textService:GetTextSize(text,self.TextBox.TextSize,self.TextBox.Font,Vector2.new(999999999,100)).X
			local cursorTextSize = textService:GetTextSize(cursorText,self.TextBox.TextSize,self.TextBox.Font,Vector2.new(999999999,100)).X

			if cursorTextSize > rightEnd then
				pos = math.max(-1,cursorTextSize - self.View.AbsoluteSize.X + 2)
			elseif cursorTextSize < leftEnd then
				pos = math.max(-1,cursorTextSize-2)
			elseif totalTextSize < rightEnd then
				pos = math.max(-1,totalTextSize - self.View.AbsoluteSize.X + 2)
			end

			if pos then
				self.TextBox.Position = UDim2.new(0,-pos,0,0)
				self.TextBox.Size = UDim2.new(1,pos,1,0)
			end
		end

		funcs.GetText = function(self)
			return self.TextBox.Text
		end

		funcs.SetText = function(self,text)
			self.TextBox.Text = text
		end

		local mt = getGuiMT(props,funcs)

		local function convert(textbox)
			local obj = initObj(props,mt)

			local view = Instance.new("Frame")
			view.BackgroundTransparency = textbox.BackgroundTransparency
			view.BackgroundColor3 = textbox.BackgroundColor3
			view.BorderSizePixel = textbox.BorderSizePixel
			view.BorderColor3 = textbox.BorderColor3
			view.Position = textbox.Position
			view.Size = textbox.Size
			view.ClipsDescendants = true
			view.Name = textbox.Name
			textbox.BackgroundTransparency = 1
			textbox.Position = UDim2.new(0,0,0,0)
			textbox.Size = UDim2.new(1,0,1,0)
			textbox.TextXAlignment = Enum.TextXAlignment.Left
			textbox.Name = "Input"

			obj.TextBox = textbox
			obj.View = view
			obj.Gui = view

			textbox.Changed:Connect(function(prop)
				if prop == "Text" or prop == "CursorPosition" or prop == "AbsoluteSize" then
					local cursorPos = obj.TextBox.CursorPosition
					if cursorPos ~= -1 then obj.CursorPos = cursorPos end
					obj:Update()
				end
			end)

			obj:Update()

			view.Parent = textbox.Parent
			textbox.Parent = view

			return obj
		end

		local function new()
			local textBox = Instance.new("TextBox")
			textBox.Size = UDim2.new(0,100,0,20)
			textBox.BackgroundColor3 = Settings.Theme.TextBox
			textBox.BorderColor3 = Settings.Theme.Outline3
			textBox.ClearTextOnFocus = false
			textBox.TextColor3 = Settings.Theme.Text
			textBox.Font = Enum.Font.SourceSans
			textBox.TextSize = 14
			textBox.Text = ""
			return convert(textBox)
		end

		return {new = new, convert = convert}
	end)()

	Lib.Label = (function()
		local props,funcs = {},{}

		local mt = getGuiMT(props,funcs)

		local function new()
			local label = Instance.new("TextLabel")
			label.BackgroundTransparency = 1
			label.TextXAlignment = Enum.TextXAlignment.Left
			label.TextColor3 = Settings.Theme.Text
			label.TextTransparency = 0.1
			label.Size = UDim2.new(0,100,0,20)
			label.Font = Enum.Font.SourceSans
			label.TextSize = 14

			local obj = setmetatable({
				Gui = label
			},mt)
			return obj
		end

		return {new = new}
	end)()

	Lib.Frame = (function()
		local props,funcs = {},{}

		local mt = getGuiMT(props,funcs)

		local function new()
			local fr = Instance.new("Frame")
			fr.BackgroundColor3 = Settings.Theme.Main1
			fr.BorderColor3 = Settings.Theme.Outline1
			fr.Size = UDim2.new(0,50,0,50)

			local obj = setmetatable({
				Gui = fr
			},mt)
			return obj
		end

		return {new = new}
	end)()

	Lib.Button = (function()
		local props = {
			Gui = PH,
			Anim = PH,
			Disabled = false,
			OnClick = SIGNAL,
			OnDown = SIGNAL,
			OnUp = SIGNAL,
			AllowedButtons = {1}
		}
		local funcs = {}
		local tableFind = table.find

		funcs.Trigger = function(self,event,button)
			if not self.Disabled and tableFind(self.AllowedButtons,button) then
				self["On"..event]:Fire(button)
			end
		end

		funcs.SetDisabled = function(self,dis)
			self.Disabled = dis

			if dis then
				self.Anim:Disable()
				self.Gui.TextTransparency = 0.5
			else
				self.Anim.Enable()
				self.Gui.TextTransparency = 0
			end
		end

		local mt = getGuiMT(props,funcs)

		local function new()
			local b = Instance.new("TextButton")
			b.AutoButtonColor = false
			b.TextColor3 = Settings.Theme.Text
			b.TextTransparency = 0.1
			b.Size = UDim2.new(0,100,0,20)
			b.Font = Enum.Font.SourceSans
			b.TextSize = 14
			b.BackgroundColor3 = Settings.Theme.Button
			b.BorderColor3 = Settings.Theme.Outline2

			local obj = initObj(props,mt)
			obj.Gui = b
			obj.Anim = Lib.ButtonAnim(b,{Mode = 2, StartColor = Settings.Theme.Button, HoverColor = Settings.Theme.ButtonHover, PressColor = Settings.Theme.ButtonPress, OutlineColor = Settings.Theme.Outline2})

			b.MouseButton1Click:Connect(function() obj:Trigger("Click",1) end)
			b.MouseButton1Down:Connect(function() obj:Trigger("Down",1) end)
			b.MouseButton1Up:Connect(function() obj:Trigger("Up",1) end)

			b.MouseButton2Click:Connect(function() obj:Trigger("Click",2) end)
			b.MouseButton2Down:Connect(function() obj:Trigger("Down",2) end)
			b.MouseButton2Up:Connect(function() obj:Trigger("Up",2) end)

			return obj
		end

		return {new = new}
	end)()

	Lib.DropDown = (function()
		local props = {
			Gui = PH,
			Anim = PH,
			Context = PH,
			Selected = PH,
			Disabled = false,
			CanBeEmpty = true,
			Options = {},
			GuiElems = {},
			OnSelect = SIGNAL
		}
		local funcs = {}

		funcs.Update = function(self)
			local options = self.Options

			if #options > 0 then
				if not self.Selected then
					if not self.CanBeEmpty then
						self.Selected = options[1]
						self.GuiElems.Label.Text = options[1]
					else
						self.GuiElems.Label.Text = "- Select -"
					end
				else
					self.GuiElems.Label.Text = self.Selected
				end
			else
				self.GuiElems.Label.Text = "- Select -"
			end
		end

		funcs.ShowOptions = function(self)
			local context = self.Context

			context.Width = self.Gui.AbsoluteSize.X
			context.ReverseYOffset = self.Gui.AbsoluteSize.Y
			context:Show(self.Gui.AbsolutePosition.X, self.Gui.AbsolutePosition.Y + context.ReverseYOffset)
		end

		funcs.SetOptions = function(self,opts)
			self.Options = opts

			local context = self.Context
			local options = self.Options
			context:Clear()

			local onClick = function(option) self.Selected = option self.OnSelect:Fire(option) self:Update() end

			if self.CanBeEmpty then
				context:Add({Name = "- Select -", OnClick = function() self.Selected = nil self.OnSelect:Fire(nil) self:Update() end})
			end

			for i = 1,#options do
				context:Add({Name = options[i], OnClick = onClick})
			end

			self:Update()
		end

		funcs.SetSelected = function(self,opt)
			self.Selected = type(opt) == "number" and self.Options[opt] or opt
			self:Update()
		end

		local mt = getGuiMT(props,funcs)

		local function new()
			local f = Instance.new("TextButton")
			f.AutoButtonColor = false
			f.Text = ""
			f.Size = UDim2.new(0,100,0,20)
			f.BackgroundColor3 = Settings.Theme.TextBox
			f.BorderColor3 = Settings.Theme.Outline3

			local label = Lib.Label.new()
			label.Position = UDim2.new(0,2,0,0)
			label.Size = UDim2.new(1,-22,1,0)
			label.TextTruncate = Enum.TextTruncate.AtEnd
			label.Parent = f
			local arrow = create({
				{1,"Frame",{BackgroundTransparency=1,Name="EnumArrow",Position=UDim2.new(1,-16,0,2),Size=UDim2.new(0,16,0,16),}},
				{2,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={1},Position=UDim2.new(0,8,0,9),Size=UDim2.new(0,1,0,1),}},
				{3,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={1},Position=UDim2.new(0,7,0,8),Size=UDim2.new(0,3,0,1),}},
				{4,"Frame",{BackgroundColor3=Color3.new(0.86274510622025,0.86274510622025,0.86274510622025),BorderSizePixel=0,Parent={1},Position=UDim2.new(0,6,0,7),Size=UDim2.new(0,5,0,1),}},
			})
			arrow.Parent = f

			local obj = initObj(props,mt)
			obj.Gui = f
			obj.Anim = Lib.ButtonAnim(f,{Mode = 2, StartColor = Settings.Theme.TextBox, LerpTo = Settings.Theme.Button, LerpDelta = 0.15})
			obj.Context = Lib.ContextMenu.new()
			obj.Context.Iconless = true
			obj.Context.MaxHeight = 200
			obj.Selected = nil
			obj.GuiElems = {Label = label}
			f.MouseButton1Down:Connect(function() obj:ShowOptions() end)
			obj:Update()
			return obj
		end

		return {new = new}
	end)()

	Lib.ClickSystem = (function()
		local props = {
			LastItem = PH,
			OnDown = SIGNAL,
			OnRelease = SIGNAL,
			AllowedButtons = {1},
			Combo = 0,
			MaxCombo = 2,
			ComboTime = 0.5,
			Items = {},
			ItemCons = {},
			ClickId = -1,
			LastButton = ""
		}
		local funcs = {}
		local tostring = tostring

		local disconnect = function(con)
			local pos = table.find(con.Signal.Connections,con)
			if pos then table.remove(con.Signal.Connections,pos) end
		end

		funcs.Trigger = function(self,item,button)
			if table.find(self.AllowedButtons,button) then
				if self.LastButton ~= button or self.LastItem ~= item or self.Combo == self.MaxCombo or tick() - self.ClickId > self.ComboTime then
					self.Combo = 0
					self.LastButton = button
					self.LastItem = item
				end
				self.Combo = self.Combo + 1
				self.ClickId = tick()

				local release
				release = service.UserInputService.InputEnded:Connect(function(input)
					if input.UserInputType == Enum.UserInputType["MouseButton"..button] then
						release:Disconnect()
						if Lib.CheckMouseInGui(item) and self.LastButton == button and self.LastItem == item then
							self["OnRelease"]:Fire(item,self.Combo,button)
						end
					end
				end)

				self["OnDown"]:Fire(item,self.Combo,button)
			end
		end

		funcs.Add = function(self,item)
			if table.find(self.Items,item) then return end

			local cons = {}
			cons[1] = item.MouseButton1Down:Connect(function() self:Trigger(item,1) end)
			cons[2] = item.MouseButton2Down:Connect(function() self:Trigger(item,2) end)

			self.ItemCons[item] = cons
			self.Items[#self.Items+1] = item
		end

		funcs.Remove = function(self,item)
			local ind = table.find(self.Items,item)
			if not ind then return end

			for i,v in pairs(self.ItemCons[item]) do
				v:Disconnect()
			end
			self.ItemCons[item] = nil
			table.remove(self.Items,ind)
		end

		local mt = {__index = funcs}

		local function new()
			local obj = initObj(props,mt)

			return obj
		end

		return {new = new}
	end)()

	return Lib
end

return {InitDeps = initDeps, InitAfterMain = initAfterMain, Main = main}
end
}

-- Main vars
local Main, Explorer, Properties, ScriptViewer, DefaultSettings, Notebook, Serializer, Lib
local API, RMD

-- Default Settings
DefaultSettings = (function()
	local rgb = Color3.fromRGB
	return {
		Explorer = {
			_Recurse = true,
			Sorting = true,
			TeleportToOffset = Vector3.new(0,0,0),
			ClickToRename = true,
			AutoUpdateSearch = true,
			AutoUpdateMode = 0, -- 0 Default, 1 no tree update, 2 no descendant events, 3 frozen
			PartSelectionBox = true,
			GuiSelectionBox = true,
			CopyPathUseGetChildren = true
		},
		Properties = {
			_Recurse = true,
			MaxConflictCheck = 50,
			ShowDeprecated = false,
			ShowHidden = false,
			ClearOnFocus = false,
			LoadstringInput = true,
			NumberRounding = 3,
			ShowAttributes = false,
			MaxAttributes = 50,
			ScaleType = 1 -- 0 Full Name Shown, 1 Equal Halves
		},
		Theme = {
			_Recurse = true,
			Main1 = rgb(52,52,52),
			Main2 = rgb(45,45,45),
			Outline1 = rgb(33,33,33), -- Mainly frames
			Outline2 = rgb(55,55,55), -- Mainly button
			Outline3 = rgb(30,30,30), -- Mainly textbox
			TextBox = rgb(38,38,38),
			Menu = rgb(32,32,32),
			ListSelection = rgb(11,90,175),
			Button = rgb(60,60,60),
			ButtonHover = rgb(68,68,68),
			ButtonPress = rgb(40,40,40),
			Highlight = rgb(75,75,75),
			Text = rgb(255,255,255),
			PlaceholderText = rgb(100,100,100),
			Important = rgb(255,0,0),
			ExplorerIconMap = "",
			MiscIconMap = "",
			Syntax = {
				Text = rgb(204,204,204),
				Background = rgb(36,36,36),
				Selection = rgb(255,255,255),
				SelectionBack = rgb(11,90,175),
				Operator = rgb(204,204,204),
				Number = rgb(255,198,0),
				String = rgb(173,241,149),
				Comment = rgb(102,102,102),
				Keyword = rgb(248,109,124),
				Error = rgb(255,0,0),
				FindBackground = rgb(141,118,0),
				MatchingWord = rgb(85,85,85),
				BuiltIn = rgb(132,214,247),
				CurrentLine = rgb(45,50,65),
				LocalMethod = rgb(253,251,172),
				LocalProperty = rgb(97,161,241),
				Nil = rgb(255,198,0),
				Bool = rgb(255,198,0),
				Function = rgb(248,109,124),
				Local = rgb(248,109,124),
				Self = rgb(248,109,124),
				FunctionName = rgb(253,251,172),
				Bracket = rgb(204,204,204)
			},
		}
	}
end)()

-- Vars
local Settings = {}
local Apps = {}
local env = {}
local service = setmetatable({},{__index = function(self,name)
	local serv = cloneref(game:GetService(name))
	self[name] = serv
	return serv
end})
local plr = service.Players.LocalPlayer or service.Players.PlayerAdded:wait()

local create = function(data)
	local insts = {}
	for i,v in pairs(data) do insts[v[1]] = Instance.new(v[2]) end
	
	for _,v in pairs(data) do
		for prop,val in pairs(v[3]) do
			if type(val) == "table" then
				insts[v[1]][prop] = insts[val[1]]
			else
				insts[v[1]][prop] = val
			end
		end
	end
	
	return insts[1]
end

local createSimple = function(class,props)
	local inst = Instance.new(class)
	for i,v in next,props do
		inst[i] = v
	end
	return inst
end

Main = (function()
	local Main = {}
	
	Main.ModuleList = {"Explorer","Properties","ScriptViewer"}
	Main.Elevated = false
	Main.MissingEnv = {}
	Main.Version = "" -- Beta 1.0.0
	Main.Mouse = plr:GetMouse()
	Main.AppControls = {}
	Main.Apps = Apps
	Main.MenuApps = {}
	
	Main.DisplayOrders = {
		SideWindow = 8,
		Window = 10,
		Menu = 100000,
		Core = 101000
	}
	
	Main.GetInitDeps = function()
		return {
			Main = Main,
			Lib = Lib,
			Apps = Apps,
			Settings = Settings,
			
			API = API,
			RMD = RMD,
			env = env,
			service = service,
			plr = plr,
			create = create,
			createSimple = createSimple
		}
	end
	
	Main.Error = function(str)
		if rconsoleprint then
			rconsoleprint("DEX ERROR: "..tostring(str).."\n")
			wait(9e9)
		else
			error(str)
		end
	end
	
	Main.LoadModule = function(name)
		if Main.Elevated then -- If you don't have filesystem api then ur outta luck tbh
			local control
			
			if EmbeddedModules then -- Offline Modules
				control = EmbeddedModules[name]()
				
				if not control then Main.Error("Missing Embedded Module: "..name) end
			end
			
			Main.AppControls[name] = control
			control.InitDeps(Main.GetInitDeps())

			local moduleData = control.Main()
			Apps[name] = moduleData
			return moduleData
		else
			local module = script:WaitForChild("Modules"):WaitForChild(name,2)
			if not module then Main.Error("CANNOT FIND MODULE "..name) end
			
			local control = require(module)
			Main.AppControls[name] = control
			control.InitDeps(Main.GetInitDeps())
			
			local moduleData = control.Main()
			Apps[name] = moduleData
			return moduleData
		end
	end
	
	Main.LoadModules = function()
		for i,v in pairs(Main.ModuleList) do
			local s,e = pcall(Main.LoadModule,v)
			if not s then
				Main.Error("FAILED LOADING " + v + " CAUSE " + e)
			end
		end
		
		-- Init Major Apps and define them in modules
		Explorer = Apps.Explorer
		Properties = Apps.Properties
		ScriptViewer = Apps.ScriptViewer
		Notebook = Apps.Notebook
		local appTable = {
			Explorer = Explorer,
			Properties = Properties,
			ScriptViewer = ScriptViewer,
			Notebook = Notebook
		}
		
		Main.AppControls.Lib.InitAfterMain(appTable)
		for i,v in pairs(Main.ModuleList) do
			local control = Main.AppControls[v]
			if control then
				control.InitAfterMain(appTable)
			end
		end
	end

    Main.InitEnv = function()
        setmetatable(env, {__newindex = function(self, name, func)
            if not func then Main.MissingEnv[#Main.MissingEnv + 1] = name return end
            rawset(self, name, func)
        end})

        -- file
        env.readfile = readfile
        env.writefile = writefile
        env.appendfile = appendfile
        env.makefolder = makefolder
        env.listfiles = listfiles
        env.loadfile = loadfile
        env.movefileas = movefileas
        env.saveinstance = saveinstance

        -- debug
        env.getupvalues = (debug and debug.getupvalues) or getupvalues or getupvals
        env.getconstants = (debug and debug.getconstants) or getconstants or getconsts
        env.getinfo = (debug and (debug.getinfo or debug.info)) or getinfo
        env.islclosure = islclosure or is_l_closure or is_lclosure
        env.checkcaller = checkcaller
        --env.getreg = getreg
        env.getgc = getgc or get_gc_objects
        env.base64encode = crypt and crypt.base64 and crypt.base64.encode
        env.getscriptbytecode = getscriptbytecode

        -- other
        --env.setfflag = setfflag
        env.request = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
        env.decompile = decompile or (env.getscriptbytecode and env.request and env.base64encode and function(scr)
            local s, bytecode = pcall(env.getscriptbytecode, scr)
            if not s then
                return "failed to get bytecode " .. tostring(bytecode)
            end

            local response = env.request({
                Url = "https://unluau.lonegladiator.dev/unluau/decompile",
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = service.HttpService:JSONEncode({
                    version = 5,
                    bytecode = env.base64encode(bytecode)
                })
            })

            local decoded = service.HttpService:JSONDecode(response.Body)
            if decoded.status ~= "ok" then
                return "decompilation failed: " .. tostring(decoded.status)
            end

            return decoded.output
        end)
        env.protectgui = protect_gui or (syn and syn.protect_gui)
        env.gethui = gethui or get_hidden_gui
        env.setclipboard = setclipboard or toclipboard or set_clipboard or (Clipboard and Clipboard.set)
        env.getnilinstances = getnilinstances or get_nil_instances
        env.getloadedmodules = getloadedmodules

        -- if identifyexecutor and type(identifyexecutor) == "function" then Main.Executor = identifyexecutor() end

        Main.GuiHolder = Main.Elevated and service.CoreGui or plr:FindFirstChildWhichIsA("PlayerGui")

        setmetatable(env, nil)
    end

	Main.LoadSettings = function()
		local s,data = pcall(env.readfile or error,"DexSettings.json")
		if s and data and data ~= "" then
			local s,decoded = service.HttpService:JSONDecode(data)
			if s and decoded then
				for i,v in next,decoded do
					
				end
			else
				-- TODO: Notification
			end
		else
			Main.ResetSettings()
		end
	end
	
	Main.ResetSettings = function()
		local function recur(t,res)
			for set,val in pairs(t) do
				if type(val) == "table" and val._Recurse then
					if type(res[set]) ~= "table" then
						res[set] = {}
					end
					recur(val,res[set])
				else
					res[set] = val
				end
			end
			return res
		end
		recur(DefaultSettings,Settings)
	end
	
	Main.FetchAPI = function()
		local api,rawAPI
		if Main.Elevated then
			if Main.LocalDepsUpToDate() then
				local localAPI = Lib.ReadFile("dex/rbx_api.dat")
				if localAPI then 
					rawAPI = localAPI
				else
					Main.DepsVersionData[1] = ""
				end
			end
			rawAPI = rawAPI or game:HttpGet("http://setup.roblox.com/"..Main.RobloxVersion.."-API-Dump.json")
		else
			if script:FindFirstChild("API") then
				rawAPI = require(script.API)
			else
				error("NO API EXISTS")
			end
		end
		Main.RawAPI = rawAPI
		api = service.HttpService:JSONDecode(rawAPI)
		
		local classes,enums = {},{}
		local categoryOrder,seenCategories = {},{}
		
		local function insertAbove(t,item,aboveItem)
			local findPos = table.find(t,item)
			if not findPos then return end
			table.remove(t,findPos)

			local pos = table.find(t,aboveItem)
			if not pos then return end
			table.insert(t,pos,item)
		end
		
		for _,class in pairs(api.Classes) do
			local newClass = {}
			newClass.Name = class.Name
			newClass.Superclass = class.Superclass
			newClass.Properties = {}
			newClass.Functions = {}
			newClass.Events = {}
			newClass.Callbacks = {}
			newClass.Tags = {}
			
			if class.Tags then for c,tag in pairs(class.Tags) do newClass.Tags[tag] = true end end
			for __,member in pairs(class.Members) do
				local newMember = {}
				newMember.Name = member.Name
				newMember.Class = class.Name
				newMember.Security = member.Security
				newMember.Tags ={}
				if member.Tags then for c,tag in pairs(member.Tags) do newMember.Tags[tag] = true end end
				
				local mType = member.MemberType
				if mType == "Property" then
					local propCategory = member.Category or "Other"
					propCategory = propCategory:match("^%s*(.-)%s*$")
					if not seenCategories[propCategory] then
						categoryOrder[#categoryOrder+1] = propCategory
						seenCategories[propCategory] = true
					end
					newMember.ValueType = member.ValueType
					newMember.Category = propCategory
					newMember.Serialization = member.Serialization
					table.insert(newClass.Properties,newMember)
				elseif mType == "Function" then
					newMember.Parameters = {}
					newMember.ReturnType = member.ReturnType.Name
					for c,param in pairs(member.Parameters) do
						table.insert(newMember.Parameters,{Name = param.Name, Type = param.Type.Name})
					end
					table.insert(newClass.Functions,newMember)
				elseif mType == "Event" then
					newMember.Parameters = {}
					for c,param in pairs(member.Parameters) do
						table.insert(newMember.Parameters,{Name = param.Name, Type = param.Type.Name})
					end
					table.insert(newClass.Events,newMember)
				end
			end
			
			classes[class.Name] = newClass
		end
		
		for _,class in pairs(classes) do
			class.Superclass = classes[class.Superclass]
		end
		
		for _,enum in pairs(api.Enums) do
			local newEnum = {}
			newEnum.Name = enum.Name
			newEnum.Items = {}
			newEnum.Tags = {}
			
			if enum.Tags then for c,tag in pairs(enum.Tags) do newEnum.Tags[tag] = true end end
			for __,item in pairs(enum.Items) do
				local newItem = {}
				newItem.Name = item.Name
				newItem.Value = item.Value
				table.insert(newEnum.Items,newItem)
			end
			
			enums[enum.Name] = newEnum
		end
		
		local function getMember(class,member)
			if not classes[class] or not classes[class][member] then return end
	        local result = {}
	
	        local currentClass = classes[class]
	        while currentClass do
	            for _,entry in pairs(currentClass[member]) do
	                result[#result+1] = entry
	            end
	            currentClass = currentClass.Superclass
	        end
	
	        table.sort(result,function(a,b) return a.Name < b.Name end)
	        return result
		end
		
		insertAbove(categoryOrder,"Behavior","Tuning")
		insertAbove(categoryOrder,"Appearance","Data")
		insertAbove(categoryOrder,"Attachments","Axes")
		insertAbove(categoryOrder,"Cylinder","Slider")
		insertAbove(categoryOrder,"Localization","Jump Settings")
		insertAbove(categoryOrder,"Surface","Motion")
		insertAbove(categoryOrder,"Surface Inputs","Surface")
		insertAbove(categoryOrder,"Part","Surface Inputs")
		insertAbove(categoryOrder,"Assembly","Surface Inputs")
		insertAbove(categoryOrder,"Character","Controls")
		categoryOrder[#categoryOrder+1] = "Unscriptable"
		categoryOrder[#categoryOrder+1] = "Attributes"
		
		local categoryOrderMap = {}
		for i = 1,#categoryOrder do
			categoryOrderMap[categoryOrder[i]] = i
		end
		
		return {
			Classes = classes,
			Enums = enums,
			CategoryOrder = categoryOrderMap,
			GetMember = getMember
		}
	end
	
	Main.FetchRMD = function()
		local rawXML
		if Main.Elevated then
			if Main.LocalDepsUpToDate() then
				local localRMD = Lib.ReadFile("dex/rbx_rmd.dat")
				if localRMD then 
					rawXML = localRMD
				else
					Main.DepsVersionData[1] = ""
				end
			end
			rawXML = rawXML or game:HttpGet("https://raw.githubusercontent.com/CloneTrooper1019/Roblox-Client-Tracker/roblox/ReflectionMetadata.xml")
		else
			if script:FindFirstChild("RMD") then
				rawXML = require(script.RMD)
			else
				error("NO RMD EXISTS")
			end
		end
		Main.RawRMD = rawXML
		local parsed = Lib.ParseXML(rawXML)
		local classList = parsed.children[1].children[1].children
		local enumList = parsed.children[1].children[2].children
		local propertyOrders = {}
		
		local classes,enums = {},{}
		for _,class in pairs(classList) do
			local className = ""
			for _,child in pairs(class.children) do
				if child.tag == "Properties" then
					local data = {Properties = {}, Functions = {}}
					local props = child.children
					for _,prop in pairs(props) do
						local name = prop.attrs.name
						name = name:sub(1,1):upper()..name:sub(2)
						data[name] = prop.children[1].text
					end
					className = data.Name
					classes[className] = data
				elseif child.attrs.class == "ReflectionMetadataProperties" then
					local members = child.children
					for _,member in pairs(members) do
						if member.attrs.class == "ReflectionMetadataMember" then
							local data = {}
							if member.children[1].tag == "Properties" then
								local props = member.children[1].children
								for _,prop in pairs(props) do
									if prop.attrs then
										local name = prop.attrs.name
										name = name:sub(1,1):upper()..name:sub(2)
										data[name] = prop.children[1].text
									end
								end
								if data.PropertyOrder then
									local orders = propertyOrders[className]
									if not orders then orders = {} propertyOrders[className] = orders end
									orders[data.Name] = tonumber(data.PropertyOrder)
								end
								classes[className].Properties[data.Name] = data
							end
						end
					end
				elseif child.attrs.class == "ReflectionMetadataFunctions" then
					local members = child.children
					for _,member in pairs(members) do
						if member.attrs.class == "ReflectionMetadataMember" then
							local data = {}
							if member.children[1].tag == "Properties" then
								local props = member.children[1].children
								for _,prop in pairs(props) do
									if prop.attrs then
										local name = prop.attrs.name
										name = name:sub(1,1):upper()..name:sub(2)
										data[name] = prop.children[1].text
									end
								end
								classes[className].Functions[data.Name] = data
							end
						end
					end
				end
			end
		end
		
		for _,enum in pairs(enumList) do
			local enumName = ""
			for _,child in pairs(enum.children) do
				if child.tag == "Properties" then
					local data = {Items = {}}
					local props = child.children
					for _,prop in pairs(props) do
						local name = prop.attrs.name
						name = name:sub(1,1):upper()..name:sub(2)
						data[name] = prop.children[1].text
					end
					enumName = data.Name
					enums[enumName] = data
				elseif child.attrs.class == "ReflectionMetadataEnumItem" then
					local data = {}
					if child.children[1].tag == "Properties" then
						local props = child.children[1].children
						for _,prop in pairs(props) do
							local name = prop.attrs.name
							name = name:sub(1,1):upper()..name:sub(2)
							data[name] = prop.children[1].text
						end
						enums[enumName].Items[data.Name] = data
					end
				end
			end
		end
		
		return {Classes = classes, Enums = enums, PropertyOrders = propertyOrders}
	end

    Main.ShowGui = function(gui)
        if env.gethui then
            gui.Parent = env.gethui()
        elseif env.protectgui then
            env.protectgui(gui)
            gui.Parent = Main.GuiHolder
        else
            gui.Parent = Main.GuiHolder
        end
    end

	Main.CreateIntro = function(initStatus) -- TODO: Must theme and show errors
		local gui = create({
			{1,"ScreenGui",{Name="Intro",}},
			{2,"Frame",{Active=true,BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BorderSizePixel=0,Name="Main",Parent={1},Position=UDim2.new(0.5,-175,0.5,-100),Size=UDim2.new(0,350,0,200),}},
			{3,"Frame",{BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderSizePixel=0,ClipsDescendants=true,Name="Holder",Parent={2},Size=UDim2.new(1,0,1,0),}},
			{4,"UIGradient",{Parent={3},Rotation=30,Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,1,0),}),}},
			{5,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=4,Name="Title",Parent={3},Position=UDim2.new(0,-190,0,15),Size=UDim2.new(0,100,0,50),Text="Dex",TextColor3=Color3.new(1,1,1),TextSize=50,TextTransparency=1,}},
			{6,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Desc",Parent={3},Position=UDim2.new(0,-230,0,60),Size=UDim2.new(0,180,0,25),Text="Ultimate Debugging Suite",TextColor3=Color3.new(1,1,1),TextSize=18,TextTransparency=1,}},
			{7,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="StatusText",Parent={3},Position=UDim2.new(0,20,0,110),Size=UDim2.new(0,180,0,25),Text="Fetching API",TextColor3=Color3.new(1,1,1),TextSize=14,TextTransparency=1,}},
			{8,"Frame",{BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BorderSizePixel=0,Name="ProgressBar",Parent={3},Position=UDim2.new(0,110,0,145),Size=UDim2.new(0,0,0,4),}},
			{9,"Frame",{BackgroundColor3=Color3.new(0.2392156869173,0.56078433990479,0.86274510622025),BorderSizePixel=0,Name="Bar",Parent={8},Size=UDim2.new(0,0,1,0),}},
			{10,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://2764171053",ImageColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),Parent={8},ScaleType=1,Size=UDim2.new(1,0,1,0),SliceCenter=Rect.new(2,2,254,254),}},
			{11,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Creator",Parent={2},Position=UDim2.new(1,-110,1,-20),Size=UDim2.new(0,105,0,20),Text="Developed by Moon",TextColor3=Color3.new(1,1,1),TextSize=14,TextXAlignment=1,}},
			{12,"UIGradient",{Parent={11},Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,1,0),}),}},
			{13,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Version",Parent={2},Position=UDim2.new(1,-110,1,-35),Size=UDim2.new(0,105,0,20),Text=Main.Version,TextColor3=Color3.new(1,1,1),TextSize=14,TextXAlignment=1,}},
			{14,"UIGradient",{Parent={13},Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,1,0),}),}},
			{15,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Image="rbxassetid://1427967925",Name="Outlines",Parent={2},Position=UDim2.new(0,-5,0,-5),ScaleType=1,Size=UDim2.new(1,10,1,10),SliceCenter=Rect.new(6,6,25,25),TileSize=UDim2.new(0,20,0,20),}},
			{16,"UIGradient",{Parent={15},Rotation=-30,Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,1,0),}),}},
			{17,"UIGradient",{Parent={2},Rotation=-30,Transparency=NumberSequence.new({NumberSequenceKeypoint.new(0,1,0),NumberSequenceKeypoint.new(1,1,0),}),}},
		})
		Main.ShowGui(gui)
		local backGradient = gui.Main.UIGradient
		local outlinesGradient = gui.Main.Outlines.UIGradient
		local holderGradient = gui.Main.Holder.UIGradient
		local titleText = gui.Main.Holder.Title
		local descText = gui.Main.Holder.Desc
		local versionText = gui.Main.Version
		local versionGradient = versionText.UIGradient
		local creatorText = gui.Main.Creator
		local creatorGradient = creatorText.UIGradient
		local statusText = gui.Main.Holder.StatusText
		local progressBar = gui.Main.Holder.ProgressBar
		local tweenS = service.TweenService
		
		local renderStepped = service.RunService.RenderStepped
		local signalWait = renderStepped.wait
		local fastwait = function(s)
			if not s then return signalWait(renderStepped) end
			local start = tick()
			while tick() - start < s do signalWait(renderStepped) end
		end
		
		statusText.Text = initStatus
		
		local function tweenNumber(n,ti,func)
			local tweenVal = Instance.new("IntValue")
			tweenVal.Value = 0
			tweenVal.Changed:Connect(func)
			local tween = tweenS:Create(tweenVal,ti,{Value = n})
			tween:Play()
			tween.Completed:Connect(function()
				tweenVal:Destroy()
			end)
		end
		
		local ti = TweenInfo.new(0.4,Enum.EasingStyle.Quad,Enum.EasingDirection.Out)
		tweenNumber(100,ti,function(val)
			    val = val/200
				local start = NumberSequenceKeypoint.new(0,0)
				local a1 = NumberSequenceKeypoint.new(val,0)
				local a2 = NumberSequenceKeypoint.new(math.min(0.5,val+math.min(0.05,val)),1)
				if a1.Time == a2.Time then a2 = a1 end
				local b1 = NumberSequenceKeypoint.new(1-val,0)
				local b2 = NumberSequenceKeypoint.new(math.max(0.5,1-val-math.min(0.05,val)),1)
				if b1.Time == b2.Time then b2 = b1 end
				local goal = NumberSequenceKeypoint.new(1,0)
				backGradient.Transparency = NumberSequence.new({start,a1,a2,b2,b1,goal})
				outlinesGradient.Transparency = NumberSequence.new({start,a1,a2,b2,b1,goal})
		end)
		
		fastwait(0.4)
		
		tweenNumber(100,ti,function(val)
			val = val/166.66
			local start = NumberSequenceKeypoint.new(0,0)
			local a1 = NumberSequenceKeypoint.new(val,0)
			local a2 = NumberSequenceKeypoint.new(val+0.01,1)
			local goal = NumberSequenceKeypoint.new(1,1)
			holderGradient.Transparency = NumberSequence.new({start,a1,a2,goal})
		end)
		
		tweenS:Create(titleText,ti,{Position = UDim2.new(0,60,0,15), TextTransparency = 0}):Play()
		tweenS:Create(descText,ti,{Position = UDim2.new(0,20,0,60), TextTransparency = 0}):Play()
		
		local function rightTextTransparency(obj)
			tweenNumber(100,ti,function(val)
				val = val/100
				local a1 = NumberSequenceKeypoint.new(1-val,0)
				local a2 = NumberSequenceKeypoint.new(math.max(0,1-val-0.01),1)
				if a1.Time == a2.Time then a2 = a1 end
				local start = NumberSequenceKeypoint.new(0,a1 == a2 and 0 or 1)
				local goal = NumberSequenceKeypoint.new(1,0)
				obj.Transparency = NumberSequence.new({start,a2,a1,goal})
			end)
		end
		rightTextTransparency(versionGradient)
		rightTextTransparency(creatorGradient)
		
		fastwait(0.9)
		
		local progressTI = TweenInfo.new(0.25,Enum.EasingStyle.Quad,Enum.EasingDirection.Out)
		
		tweenS:Create(statusText,progressTI,{Position = UDim2.new(0,20,0,120), TextTransparency = 0}):Play()
		tweenS:Create(progressBar,progressTI,{Position = UDim2.new(0,60,0,145), Size = UDim2.new(0,100,0,4)}):Play()
		
		fastwait(0.25)
		
		local function setProgress(text,n)
			statusText.Text = text
			tweenS:Create(progressBar.Bar,progressTI,{Size = UDim2.new(n,0,1,0)}):Play()
		end
		
		local function close()
			tweenS:Create(titleText,progressTI,{TextTransparency = 1}):Play()
			tweenS:Create(descText,progressTI,{TextTransparency = 1}):Play()
			tweenS:Create(versionText,progressTI,{TextTransparency = 1}):Play()
			tweenS:Create(creatorText,progressTI,{TextTransparency = 1}):Play()
			tweenS:Create(statusText,progressTI,{TextTransparency = 1}):Play()
			tweenS:Create(progressBar,progressTI,{BackgroundTransparency = 1}):Play()
			tweenS:Create(progressBar.Bar,progressTI,{BackgroundTransparency = 1}):Play()
			tweenS:Create(progressBar.ImageLabel,progressTI,{ImageTransparency = 1}):Play()
			
			tweenNumber(100,TweenInfo.new(0.4,Enum.EasingStyle.Back,Enum.EasingDirection.In),function(val)
				val = val/250
				local start = NumberSequenceKeypoint.new(0,0)
				local a1 = NumberSequenceKeypoint.new(0.6+val,0)
				local a2 = NumberSequenceKeypoint.new(math.min(1,0.601+val),1)
				if a1.Time == a2.Time then a2 = a1 end
				local goal = NumberSequenceKeypoint.new(1,a1 == a2 and 0 or 1)
				holderGradient.Transparency = NumberSequence.new({start,a1,a2,goal})
			end)
			
			fastwait(0.5)
			gui.Main.BackgroundTransparency = 1
			outlinesGradient.Rotation = 30
			
			tweenNumber(100,ti,function(val)
				val = val/100
				local start = NumberSequenceKeypoint.new(0,1)
				local a1 = NumberSequenceKeypoint.new(val,1)
				local a2 = NumberSequenceKeypoint.new(math.min(1,val+math.min(0.05,val)),0)
				if a1.Time == a2.Time then a2 = a1 end
				local goal = NumberSequenceKeypoint.new(1,a1 == a2 and 1 or 0)
				outlinesGradient.Transparency = NumberSequence.new({start,a1,a2,goal})
				holderGradient.Transparency = NumberSequence.new({start,a1,a2,goal})
			end)
			
			fastwait(0.45)
			gui:Destroy()
		end
		
		return {SetProgress = setProgress, Close = close}
	end
	
	Main.CreateApp = function(data)
		if Main.MenuApps[data.Name] then return end -- TODO: Handle conflict
		local control = {}
		
		local app = Main.AppTemplate:Clone()
		
		local iconIndex = data.Icon
		if data.IconMap and iconIndex then
			if type(iconIndex) == "number" then
				data.IconMap:Display(app.Main.Icon,iconIndex)
			elseif type(iconIndex) == "string" then
				data.IconMap:DisplayByKey(app.Main.Icon,iconIndex)
			end
		elseif type(iconIndex) == "string" then
			app.Main.Icon.Image = iconIndex
		else
			app.Main.Icon.Image = ""
		end
		
		local function updateState()
			app.Main.BackgroundTransparency = data.Open and 0 or (Lib.CheckMouseInGui(app.Main) and 0 or 1)
			app.Main.Highlight.Visible = data.Open
		end
		
		local function enable(silent)
			if data.Open then return end
			data.Open = true
			updateState()
			if not silent then
				if data.Window then data.Window:Show() end
				if data.OnClick then data.OnClick(data.Open) end
			end
		end
		
		local function disable(silent)
			if not data.Open then return end
			data.Open = false
			updateState()
			if not silent then
				if data.Window then data.Window:Hide() end
				if data.OnClick then data.OnClick(data.Open) end
			end
		end
		
		updateState()
		
		local ySize = service.TextService:GetTextSize(data.Name,14,Enum.Font.SourceSans,Vector2.new(62,999999)).Y
		app.Main.Size = UDim2.new(1,0,0,math.clamp(46+ySize,60,74))
		app.Main.AppName.Text = data.Name
		
		app.Main.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				app.Main.BackgroundTransparency = 0
				app.Main.BackgroundColor3 = Settings.Theme.ButtonHover
			end
		end)
		
		app.Main.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				app.Main.BackgroundTransparency = data.Open and 0 or 1
				app.Main.BackgroundColor3 = Settings.Theme.Button
			end
		end)
		
		app.Main.MouseButton1Click:Connect(function()
			if data.Open then disable() else enable() end
		end)
		
		local window = data.Window
		if window then
			window.OnActivate:Connect(function() enable(true) end)
			window.OnDeactivate:Connect(function() disable(true) end)
		end
		
		app.Visible = true
		app.Parent = Main.AppsContainer
		Main.AppsFrame.CanvasSize = UDim2.new(0,0,0,Main.AppsContainerGrid.AbsoluteCellCount.Y*82 + 8)
		
		control.Enable = enable
		control.Disable = disable
		Main.MenuApps[data.Name] = control
		return control
	end
	
	Main.SetMainGuiOpen = function(val)
		Main.MainGuiOpen = val
		
		Main.MainGui.OpenButton.Text = val and "X" or "Dex"
		if val then Main.MainGui.OpenButton.MainFrame.Visible = true end
		Main.MainGui.OpenButton.MainFrame:TweenSize(val and UDim2.new(0,224,0,200) or UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Quad,0.2,true)
		--Main.MainGui.OpenButton.BackgroundTransparency = val and 0 or (Lib.CheckMouseInGui(Main.MainGui.OpenButton) and 0 or 0.2)
		service.TweenService:Create(Main.MainGui.OpenButton,TweenInfo.new(0.2,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{BackgroundTransparency = val and 0 or (Lib.CheckMouseInGui(Main.MainGui.OpenButton) and 0 or 0.2)}):Play()
		
		if Main.MainGuiMouseEvent then Main.MainGuiMouseEvent:Disconnect() end
		
		if not val then
			local startTime = tick()
			Main.MainGuiCloseTime = startTime
			coroutine.wrap(function()
				Lib.FastWait(0.2)
				if not Main.MainGuiOpen and startTime == Main.MainGuiCloseTime then Main.MainGui.OpenButton.MainFrame.Visible = false end
			end)()
		else
			Main.MainGuiMouseEvent = service.UserInputService.InputBegan:Connect(function(input)
				if input.UserInputType == Enum.UserInputType.MouseButton1 and not Lib.CheckMouseInGui(Main.MainGui.OpenButton) and not Lib.CheckMouseInGui(Main.MainGui.OpenButton.MainFrame) then
					Main.SetMainGuiOpen(false)
				end
			end)
		end
	end
	
	Main.CreateMainGui = function()
		local gui = create({
			{1,"ScreenGui",{IgnoreGuiInset=true,Name="MainMenu",}},
			{2,"TextButton",{AnchorPoint=Vector2.new(0.5,0),AutoButtonColor=false,BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),BorderSizePixel=0,Font=4,Name="OpenButton",Parent={1},Position=UDim2.new(0.5,0,0,2),Size=UDim2.new(0,32,0,32),Text="Dex",TextColor3=Color3.new(1,1,1),TextSize=16,TextTransparency=0.20000000298023,}},
			{3,"UICorner",{CornerRadius=UDim.new(0,4),Parent={2},}},
			{4,"Frame",{AnchorPoint=Vector2.new(0.5,0),BackgroundColor3=Color3.new(0.17647059261799,0.17647059261799,0.17647059261799),ClipsDescendants=true,Name="MainFrame",Parent={2},Position=UDim2.new(0.5,0,1,-4),Size=UDim2.new(0,224,0,200),}},
			{5,"UICorner",{CornerRadius=UDim.new(0,4),Parent={4},}},
			{6,"Frame",{BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),Name="BottomFrame",Parent={4},Position=UDim2.new(0,0,1,-24),Size=UDim2.new(1,0,0,24),}},
			{7,"UICorner",{CornerRadius=UDim.new(0,4),Parent={6},}},
			{8,"Frame",{BackgroundColor3=Color3.new(0.20392157137394,0.20392157137394,0.20392157137394),BorderSizePixel=0,Name="CoverFrame",Parent={6},Size=UDim2.new(1,0,0,4),}},
			{9,"Frame",{BackgroundColor3=Color3.new(0.1294117718935,0.1294117718935,0.1294117718935),BorderSizePixel=0,Name="Line",Parent={8},Position=UDim2.new(0,0,0,-1),Size=UDim2.new(1,0,0,1),}},
			{10,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Settings",Parent={6},Position=UDim2.new(1,-48,0,0),Size=UDim2.new(0,24,1,0),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,}},
			{11,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://6578871732",ImageTransparency=0.20000000298023,Name="Icon",Parent={10},Position=UDim2.new(0,4,0,4),Size=UDim2.new(0,16,0,16),}},
			{12,"TextButton",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Font=3,Name="Information",Parent={6},Position=UDim2.new(1,-24,0,0),Size=UDim2.new(0,24,1,0),Text="",TextColor3=Color3.new(1,1,1),TextSize=14,}},
			{13,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://6578933307",ImageTransparency=0.20000000298023,Name="Icon",Parent={12},Position=UDim2.new(0,4,0,4),Size=UDim2.new(0,16,0,16),}},
			{14,"ScrollingFrame",{Active=true,AnchorPoint=Vector2.new(0.5,0),BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderColor3=Color3.new(0.1294117718935,0.1294117718935,0.1294117718935),BorderSizePixel=0,Name="AppsFrame",Parent={4},Position=UDim2.new(0.5,0,0,0),ScrollBarImageColor3=Color3.new(0,0,0),ScrollBarThickness=4,Size=UDim2.new(0,222,1,-25),}},
			{15,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Name="Container",Parent={14},Position=UDim2.new(0,7,0,8),Size=UDim2.new(1,-14,0,2),}},
			{16,"UIGridLayout",{CellSize=UDim2.new(0,66,0,74),Parent={15},SortOrder=2,}},
			{17,"Frame",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Name="App",Parent={1},Size=UDim2.new(0,100,0,100),Visible=false,}},
			{18,"TextButton",{AutoButtonColor=false,BackgroundColor3=Color3.new(0.2352941185236,0.2352941185236,0.2352941185236),BorderSizePixel=0,Font=3,Name="Main",Parent={17},Size=UDim2.new(1,0,0,60),Text="",TextColor3=Color3.new(0,0,0),TextSize=14,}},
			{19,"ImageLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,Image="rbxassetid://6579106223",ImageRectSize=Vector2.new(32,32),Name="Icon",Parent={18},Position=UDim2.new(0.5,-16,0,4),ScaleType=4,Size=UDim2.new(0,32,0,32),}},
			{20,"TextLabel",{BackgroundColor3=Color3.new(1,1,1),BackgroundTransparency=1,BorderSizePixel=0,Font=3,Name="AppName",Parent={18},Position=UDim2.new(0,2,0,38),Size=UDim2.new(1,-4,1,-40),Text="Explorer",TextColor3=Color3.new(1,1,1),TextSize=14,TextTransparency=0.10000000149012,TextTruncate=1,TextWrapped=true,TextYAlignment=0,}},
			{21,"Frame",{BackgroundColor3=Color3.new(0,0.66666668653488,1),BorderSizePixel=0,Name="Highlight",Parent={18},Position=UDim2.new(0,0,1,-2),Size=UDim2.new(1,0,0,2),}},
		})
		Main.MainGui = gui
		Main.AppsFrame = gui.OpenButton.MainFrame.AppsFrame
		Main.AppsContainer = Main.AppsFrame.Container
		Main.AppsContainerGrid = Main.AppsContainer.UIGridLayout
		Main.AppTemplate = gui.App
		Main.MainGuiOpen = false
		
		local openButton = gui.OpenButton
		openButton.BackgroundTransparency = 0.2
		openButton.MainFrame.Size = UDim2.new(0,0,0,0)
		openButton.MainFrame.Visible = false
		openButton.MouseButton1Click:Connect(function()
			Main.SetMainGuiOpen(not Main.MainGuiOpen)
		end)
		
		openButton.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				service.TweenService:Create(Main.MainGui.OpenButton,TweenInfo.new(0,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{BackgroundTransparency = 0}):Play()
			end
		end)

		openButton.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement then
				service.TweenService:Create(Main.MainGui.OpenButton,TweenInfo.new(0,Enum.EasingStyle.Quad,Enum.EasingDirection.Out),{BackgroundTransparency = Main.MainGuiOpen and 0 or 0.2}):Play()
			end
		end)
		
		-- Create Main Apps
		Main.CreateApp({Name = "Explorer", IconMap = Main.LargeIcons, Icon = "Explorer", Open = true, Window = Explorer.Window})
		
		Main.CreateApp({Name = "Properties", IconMap = Main.LargeIcons, Icon = "Properties", Open = true, Window = Properties.Window})
		
		Main.CreateApp({Name = "Script Viewer", IconMap = Main.LargeIcons, Icon = "Script_Viewer", Window = ScriptViewer.Window})

		local cptsOnMouseClick = nil
		Main.CreateApp({Name = "Click part to select", IconMap = Main.LargeIcons, Icon = 6, OnClick = function(callback)
			if callback then
				local mouse = Main.Mouse
				cptsOnMouseClick = mouse.Button1Down:Connect(function()
					pcall(function()
						local object = mouse.Target
						if nodes[object] then
							selection:Set(nodes[object])
							Explorer.ViewNode(nodes[object])
						end
					end)
				end)
			else if cptsOnMouseClick ~= nil then cptsOnMouseClick:Disconnect() cptsOnMouseClick = nil end end
		end})
		
		Lib.ShowGui(gui)
	end
	
	Main.SetupFilesystem = function()
		if not env.writefile or not env.makefolder then return end
		local writefile, makefolder = env.writefile, env.makefolder
		makefolder("dex")
		makefolder("dex/assets")
		makefolder("dex/saved")
		makefolder("dex/plugins")
		makefolder("dex/ModuleCache")
	end
	
	Main.LocalDepsUpToDate = function()
		return Main.DepsVersionData and Main.ClientVersion == Main.DepsVersionData[1]
	end
	
	Main.Init = function()
		Main.Elevated = pcall(function() local a = cloneref(game:GetService("CoreGui")):GetFullName() end)
		Main.InitEnv()
		Main.LoadSettings()
		Main.SetupFilesystem()
		
		-- Load Lib
		local intro = Main.CreateIntro("Initializing Library")
		Lib = Main.LoadModule("Lib")
		Lib.FastWait()
		
		-- Init other stuff
		--Main.IncompatibleTest()
		
		-- Init icons
		Main.MiscIcons = Lib.IconMap.new("rbxassetid://6511490623",256,256,16,16)
		Main.MiscIcons:SetDict({
			Reference = 0,             Cut = 1,                         Cut_Disabled = 2,      Copy = 3,               Copy_Disabled = 4,    Paste = 5,                Paste_Disabled = 6,
			Delete = 7,                Delete_Disabled = 8,             Group = 9,             Group_Disabled = 10,    Ungroup = 11,         Ungroup_Disabled = 12,    TeleportTo = 13,
			Rename = 14,               JumpToParent = 15,               ExploreData = 16,      Save = 17,              CallFunction = 18,    CallRemote = 19,          Undo = 20,
			Undo_Disabled = 21,        Redo = 22,                       Redo_Disabled = 23,    Expand_Over = 24,       Expand = 25,          Collapse_Over = 26,       Collapse = 27,
			SelectChildren = 28,       SelectChildren_Disabled = 29,    InsertObject = 30,     ViewScript = 31,        AddStar = 32,         RemoveStar = 33,          Script_Disabled = 34,
			LocalScript_Disabled = 35, Play = 36,                       Pause = 37,            Rename_Disabled = 38
		})
		Main.LargeIcons = Lib.IconMap.new("rbxassetid://6579106223",256,256,32,32)
		Main.LargeIcons:SetDict({
			Explorer = 0, Properties = 1, Script_Viewer = 2,
		})
		
		-- Fetch version if needed
		intro.SetProgress("Fetching Roblox Version",0.2)
		if Main.Elevated then
			local fileVer = Lib.ReadFile("dex/deps_version.dat")
			Main.ClientVersion = Version()
			if fileVer then
				Main.DepsVersionData = string.split(fileVer,"\n")
				if Main.LocalDepsUpToDate() then
					Main.RobloxVersion = Main.DepsVersionData[2]
				end
			end
			Main.RobloxVersion = Main.RobloxVersion or game:HttpGet("http://setup.roblox.com/versionQTStudio")
		end
		
		-- Fetch external deps
		intro.SetProgress("Fetching API",0.35)
		API = Main.FetchAPI()
		Lib.FastWait()
		intro.SetProgress("Fetching RMD",0.5)
		RMD = Main.FetchRMD()
		Lib.FastWait()
		
		-- Save external deps locally if needed
		if Main.Elevated and env.writefile and not Main.LocalDepsUpToDate() then
			env.writefile("dex/deps_version.dat",Main.ClientVersion.."\n"..Main.RobloxVersion)
			env.writefile("dex/rbx_api.dat",Main.RawAPI)
			env.writefile("dex/rbx_rmd.dat",Main.RawRMD)
		end
		
		-- Load other modules
		intro.SetProgress("Loading Modules",0.75)
		Main.AppControls.Lib.InitDeps(Main.GetInitDeps()) -- Missing deps now available
		Main.LoadModules()
		Lib.FastWait()
		
		-- Init other modules
		intro.SetProgress("Initializing Modules",0.9)
		Explorer.Init()
		Properties.Init()
		ScriptViewer.Init()
		Lib.FastWait()
		
		-- Done
		intro.SetProgress("Complete",1)
		coroutine.wrap(function()
			Lib.FastWait(1.25)
			intro.Close()
		end)()
		
		-- Init window system, create main menu, show explorer and properties
		Lib.Window.Init()
		Main.CreateMainGui()
		Explorer.Window:Show({Align = "right", Pos = 1, Size = 0.5, Silent = true})
		Properties.Window:Show({Align = "right", Pos = 2, Size = 0.5, Silent = true})
		Lib.DeferFunc(function() Lib.Window.ToggleSide("right") end)
	end
	
	return Main
end)()

-- Start
Main.Init()
